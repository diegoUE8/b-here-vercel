/**
 * @license beta-bhere-development v1.0.28
 * (c) 2023 Luca Zampetti <lzampetti@gmail.com>
 * License: MIT
 */

(function(g,f){typeof exports==='object'&&typeof module!=='undefined'?f(require('rxcomp'),require('rxcomp-form'),require('rxjs'),require('rxjs/operators'),require('three'),require('html2canvas')):typeof define==='function'&&define.amd?define(['rxcomp','rxcomp-form','rxjs','rxjs/operators','three','html2canvas'],f):(g=typeof globalThis!=='undefined'?globalThis:g||self,f(g.rxcomp,g.rxcomp.form,g.rxjs,g.rxjs.operators,g.THREE,g.html2canvas));})(this,(function(rxcomp,rxcompForm,rxjs,operators,three,html2canvas){'use strict';function _interopDefaultLegacy(e){return e&&typeof e==='object'&&'default'in e?e:{'default':e}}var html2canvas__default=/*#__PURE__*/_interopDefaultLegacy(html2canvas);const CHUNK_REMOTE =
/* html */
`
<!-- remote sidebar -->
<div class="group--remote" [class]="remoteClass" *if="state.live">
	<div class="agora-stream" (toggleControl)="onToggleControl($event)" (toggleSpy)="onToggleSpy($event)" agora-stream [stream]="remote" type="remote" *for="let remote of remotes">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info" [class]="{ spyed: state.spying == streamId, controlling: state.controlling == streamId }">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
			<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			<button type="button" class="btn--control" [title]="'title_control' | label" (click)="onToggleControl(streamId)" *if="state.role === 'publisher'">
				<svg class="control" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
			</button>
			<button type="button" class="btn--spy" [title]="'title_spy' | label" (click)="onToggleSpy(streamId)" *if="state.role === 'publisher'">
				<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
			</button>
		</div>
	</div>
	<div class="group--members" *if="state.mode == 'virtual-tour'">
		<div class="members">
			<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
			<span class="members__count" [innerHTML]="state.membersCount"></span>
		</div>
		<div class="credits">
			<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
				<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
			</a>
		</div>
	</div>
</div>
<!-- remote screen -->
<div class="group--remote-screen" *if="remoteScreen">
	<div class="agora-stream" agora-stream [stream]="remoteScreen" type="remote">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
		</div>
	</div>
</div>
`;
const CHUNK_SERVICE =
/* html */
`
<!-- service -->
<div class="group--service">
	<button type="button" class="btn--back" [title]="'title_back' | label" (click)="onBack($event)" *if="isBackButtonVisible">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
	</button>
	<button type="button" class="btn--view-mode" [title]="'title_view_mode' | label" (click)="toggleMode($event)" *if="state.mode != 'embed'">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'virtual-tour'"><use xlink:href="#live-meeting"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'live-meeting'"><use xlink:href="#virtual-tour"></use></svg>
	</button>
	<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
	</button>
	<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
	</button>
	<button type="button" class="btn--navmap" [title]="'title_navmap' | label" [class]="{ active: state.showNavmap }" (click)="toggleNavmap($event)" *if="navmap && state.mode != 'live-meeting'">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navmap"></use></svg>
	</button>
</div>
`;
const CHUNK_LOCAL =
/* html */
`
<!-- local streams -->
<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
	<button type="button" class="btn--silence" [title]="'title_silence' | label" [class]="{ active: state.silencing }" (click)="onToggleSilence()" *if="state.role === 'publisher'">
		<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
	</button>
	<button type="button" class="btn--control" [title]="'title_control' | label" [class]="{ active: state.controlling == state.uid }" (click)="onToggleControl(state.uid)" *if="state.role == 'publisher'">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
	</button>
	<div class="agora-stream" *if="!local"></div>
	<div class="agora-stream" agora-stream [stream]="local" type="local" *if="local">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
		</div>
	</div>
	<div class="agora-stream agora-stream--screen" agora-stream [stream]="screen" type="local" *if="screen && hasScreenViewItem">
		<div class="agora-stream__player"></div>
	</div>
</div>
`;
const CHUNK_LOCAL_SMART_DEVICE =
/* html */
`
<!-- local streams -->
<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
	<div class="agora-stream" agora-stream [stream]="local" type="local" *if="local">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
		</div>
	</div>
</div>
`;
const CHUNK_CONTROLS =
/* html */
`
<!-- controls -->
<div class="group--controls" *if="state.live">
	<div class="group--actions">
		<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
		</button>
		<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
		</button>
		<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
		</button>
		<button type="button" class="btn--screen" [title]="'title_share_screen' | label" [class]="{ active: screen }" (click)="toggleScreen()" *if="('screenShare' | flag) && (state.role == 'publisher' || state.role == 'attendee' || controlling)">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#screen"></use></svg>
		</button>
		<button type="button" class="btn--chat" [title]="'title_chat' | label" [class]="{ active: state.chatDirty }" (click)="toggleChat()" *if="('chat' | flag)">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#chat"></use></svg>
		</button>
		<button type="button" class="btn--navinfo" [title]="'title_navinfo' | label" [class]="{ active: state.showNavInfo }" (click)="toggleNavInfo()" *if="showNavInfoToggler">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navinfo"></use></svg>
		</button>
	</div>
</div>
`;
const CHUNK_CONTROLS_SMART_DEVICE =
/* html */
`
<!-- controls -->
<div class="group--controls" *if="state.live">
	<div class="group--actions">
		<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
		</button>
		<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
		</button>
		<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
		</button>
	</div>
</div>
`;
const CHUNK_MEMBERS =
/* html */
`
<!-- members -->
<div class="group--members" *if="state.mode == 'live-meeting'">
	<div class="members">
		<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
		<span class="members__count" [innerHTML]="state.membersCount"></span>
	</div>
	<div class="credits">
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
	</div>
</div>
`;
const CHUNK_MEMBERS_SMART_DEVICE =
/* html */
`
<!-- members -->
<div class="group--members">
	<div class="members">
		<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
		<span class="members__count" [innerHTML]="state.membersCount"></span>
	</div>
	<div class="credits">
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
	</div>
</div>
`;
const CHUNK_MEDIA =
/* html */
`
<!-- media -->
<div class="group--media" media-player>
	<button type="button" class="btn--play" [title]="'title_play' | label" (click)="onPlay()" *if="!playing">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#play"></use></svg>
	</button>
	<button type="button" class="btn--pause" [title]="'title_pause' | label" (click)="onPause()" *if="playing">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#pause"></use></svg>
	</button>
	<div class="track" (click)="onTrack($event)">
		<div class="track__progress" [style]="{ transform: 'scale(' + this.progress + ', 1)'}"></div>
	</div>
</div>
`;
const CHUNK_AR_VR =
/* html */
`
<!-- ar-vr -->
<div class="group--ar-vr">
	<button type="button" class="btn--ar" [title]="'title_ar' | label" [href]="view?.ar" (click)="tryInAr()" *if="view?.ar">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#ar"></use></svg> <span>Try in AR</span>
	</button>
	<button type="button" class="btn--vr" [title]="'title_vr' | label" [class]="{ disabled: vrService.isDisabled() }" (click)="vrService.toggleVR()">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#vr"></use></svg> <span [innerHTML]="vrService.getLabel()"></span>
	</button>
</div>
`;
const CHUNK_LIKE =
/* html */
`
<!-- like -->
<div class="group--heart" *if="view && ('like' | flag)">
	<svg class="love" [class]="{ active: view.showLove }" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#heart"></use></svg>
	<button type="button" class="btn--heart" [class]="{ active: view.showLove }" (click)="addLike($event)">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#heart"></use></svg>
		<span class="badge" [innerHTML]="view.likes" *if="view.likes"></span>
	</button>
</div>
<div class="group--spacer" *if="!view || !('like' | flag)"></div>
`;
const CHUNK_CHAT =
/* html */
`
<!-- chat -->
<div class="group--chat" *if="state.chat" agora-chat (close)="onChatClose()"></div>
`;
const CHUNK_LOCK =
/* html */
`
<!-- lock -->
<div class="ui__lock" [class]="{ spying: spying }" *if="locked || controlling"></div>
`;
const CHUNK_NAVMAP =
/* html */
`
<!-- navmap -->
<div class="group--navmap" *if="navmap && state.showNavmap && state.mode != 'live-meeting'">
	<img draggable="false" [src]="navmap.asset | asset" *if="navmap.asset" />
	<div class="navmap__item" [style]="{ left: item.position[0] * 100 + '%', top: item.position[1] * 100 + '%' }" (click)="onNavmapItem(item)" *for="let item of navmap.items">
		<img draggable="false" [src]="'textures/ui/nav-point.png' | asset" />
		<div class="title" [innerHTML]="item.title" *if="item.title"></div>
	</div>
</div>
`;
const CHUNK_BACKGROUND =
/* html */
`
<!-- background -->
<div class="background" [class]="{ 'background--image': ('background.image' | env), 'background--video': ('background.video' | env) }" *if="state.status != 'connected'">
	<img [src]="'background.image' | env | asset" *if="'background.image' | env" />
	<video [src]="'background.video' | env | asset" *if="'background.video' | env" oncanplay="this.muted = true; this.classList.add('ready');" playsinline autoplay muted loop></video>
</div>
`;
const CHUNK_LOGO =
/* html */
`
<!-- logo -->
<a class="btn--logo" [routerLink]="':lang.access' | route" *if="state.status != 'connected'">
	<img [src]="'logo' | env" *if="'logo' | env" />
	<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
</a>
`;
const CHUNK_CREDITS =
/* html */
`
<!-- credits -->
<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener" *if="state.status != 'connected'">
	<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
</a>
`;
const CHUNK_COPYRIGHT =
/* html */
`
<!-- copyright -->
<span *if="'gdprRoutes' | flag"> <span [innerHTML]="'copyright' | label"></span> <span *if="'privacy_policy' | label">-</span> <a [routerLink]="':lang.privacy' | route" class="btn--colophon" [innerHTML]="'privacy_policy' | label"></a> <span *if="'terms_of_service' | label">-</span> <a [routerLink]="':lang.terms' | route" class="btn--colophon" [innerHTML]="'terms_of_service' | label"></a></span>
`;
const CHUNK_LANGUAGE =
/* html */
`
<!-- language -->
<div class="group--language" language *if="state.status != 'connected'"></div>
`;
const CHUNK_VIRTUAL_TOUR =
/* html */
`
<!-- Virtual Tour -->
<div class="ui virtual-tour" [class]="uiClass" *if="state.status == 'connected' && isVirtualTourUser">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	${CHUNK_REMOTE}
	<div class="group--header">
		${CHUNK_SERVICE}
		${CHUNK_LOCAL}
	</div>
	<div class="group--footer">
		${CHUNK_CONTROLS}
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
	${CHUNK_MEMBERS}
	${CHUNK_CHAT}
	${CHUNK_LOCK}
	${CHUNK_NAVMAP}
</div>
`;
const CHUNK_SMART_DEVICE =
/* html */
`
<!-- Smart Device -->
<div class="ui remotes" [class]="uiClass" *if="state.status == 'connected' && state.role == 'smart-device'">
	<div class="ui__body"></div>
	<!-- remote sidebar -->
	<div class="group--remote" [class]="'group--remote--' + remotes.length" *if="state.live">
		<div class="agora-stream" (toggleSpy)="onToggleSpy($event)" agora-stream [stream]="remote" type="remote" *for="let remote of remotes">
			<div class="agora-stream__player"></div>
			<div class="agora-stream__info">
				<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
				<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
				<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			</div>
		</div>
	</div>
	<!-- remote screen -->
	<div class="group--remote-screen" *if="remoteScreen && !hasScreenViewItem">
		<div class="agora-stream" agora-stream [stream]="remoteScreen" type="remote">
			<div class="agora-stream__player"></div>
			<div class="agora-stream__info">
				<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			</div>
		</div>
	</div>
	<div class="group--header">
		${CHUNK_LOCAL_SMART_DEVICE}
	</div>
	<div class="group--footer">
		${CHUNK_CONTROLS_SMART_DEVICE}
	</div>
	${CHUNK_MEMBERS_SMART_DEVICE}
</div>
`;
const CHUNK_SELF_SERVICE_TOUR =
/* html */
`
<!-- Self Service Tour -->
<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'self-service-tour'">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	<div class="group--header">
		${CHUNK_SERVICE}
	</div>
	<div class="group--footer">
		<div class="group--spacer"></div>
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
	${CHUNK_NAVMAP}
</div>
`;
const CHUNK_EMBED =
/* html */
`
<!-- Embed -->
<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'embed'">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	<div class="group--header">
		${CHUNK_SERVICE}
	</div>
	<div class="group--footer">
		<div class="group--spacer"></div>
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
</div>
`;const environmentServed = {
  appKey: '8b0cae93d47a44e48e97e7fd0404be4e',
  channelName: 'BHere',
  flags: {
    production: true,
    useProxy: false,
    useToken: false,
    useExtendedUserInfo: false,
    useEncryptedUrl: false,
    gdprRoutes: false,
    selfService: true,
    guidedTourRequest: true,
    guidedTourAccess: true,
    ssoLogin: false,
    ssoRegister: false,
    editor: false,
    editorAssetScreen: false,
    menu: true,
    menuEmbed: false,
    navmaps: false,
    screenShare: false,
    chat: false,
    ar: true,
    like: true,
    hideNavInfo: true,
    useIframe: true,
    attendee: true,
    streamer: true,
    viewer: true,
    smartDevice: true,
    selfServiceProposition: false,
    navInfoAnimated: false,
    navInfoImportantAnimated: false,
    navMoveAnimated: false,
    navMoveImportantAnimated: false,
    navPointAnimated: false,
    navPointImportantAnimated: false,
    navTitleAnimated: false,
    navTitleImportantAnimated: false,
    navTransparentAnimated: false,
    navTransparentImportantAnimated: false,
    useTextureEnvironment: true,
    usePaths: false,
    antialias: true,
    alpha: false,
    premultipliedAlpha: false // maxQuality: false,

  },
  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  profiles: {
    // streamer: "480p_1", // 640 x 480 x 15
    streamer: "480p_2",
    // 640 x 480 x 30
    // streamer: "480p_3", // 480 x 480 x 15
    // streamer: "480p_4", // 640 x 480 x 30
    // streamer: "480p_6", // 480 x 480 x 30
    // streamer: "480p_8", // 848, 480 x 15
    // streamer: "480p_9", // 848, 480 x 30
    // streamer: "480p_10", // 640 x 480 x 10
    // streamer: "720p_1", // 1280 x 720 x 15
    // streamer: "720p_2", // 1280 x 720 x 30
    // streamer: "720p_3", // 1280 x 720 x 30
    // streamer: "720p_5", // 960 x 720 x 15
    // streamer: "720p_6", // 960 x 720 x 30
    // streamer: "1080p_1", // 1920 x 1080 x 15
    // streamer: "1080p_2", // 1920 x 1080 x 30
    // streamer: "1080p_3", // 1920 x 1080 x 30
    // streamer: "1080p_5", // 1920 x 1080 x 60
    // attendee: "720p_2", // 1920 x 1080 x 30
    attendee: "1080p_2",
    // 1920 x 1080 x 30
    // publisher: "720p_2", // 1920 x 1080 x 30
    publisher: "1080p_2",
    // 1920 x 1080 x 30
    // screen: "480p_1", // 640 × 480 x 5
    // screen: "480p_2", // 640 × 480 x 30
    // screen: "720p_1", // 1280 × 720 x 5
    screen: "720p_2" // 1280 × 720 x 30
    // screen: "1080p_1", // 1920 × 1080 x 5
    // screen: "1080p_2", // 1920 × 1080 30

  },
  logo: null,

  /*
  background: {
  	// image: 'img/background.jpg',
  	video: 'img/background.mp4',
  },
  */
  selfServiceAudio: null,
  // 'audio/self-service.mp3',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room', 'room-3d', 'media'],
    disabledViewItemTypes: ['texture']
  },
  assets: '/Modules/B-Here/Client/docs/',
  dist: '/Modules/B-Here/Client/dist/',
  workers: {
    image: '/Modules/B-Here/Client/docs/js/workers/image.service.worker.js',
    prefetch: '/Modules/B-Here/Client/docs/js/workers/prefetch.service.worker.js'
  },
  textures: {
    envMap: 'textures/envMap/studio_small_03_2k.hdr',
    grid: 'textures/grid/grid.jpg'
  },
  toneMappingExposure: 1,
  githubDocs: 'https://raw.githubusercontent.com/actarian/b-here/beta-bhere-sso/docs/',
  template: {
    email: {
      supportRequest: '/template/modules/b-here/email/support-request.cshtml'
    }
  }
};const environmentStatic = {
  appKey: '8b0cae93d47a44e48e97e7fd0404be4e',
  channelName: 'BHere',
  flags: {
    production: false,
    useProxy: true,
    useToken: false,
    useExtendedUserInfo: true,
    useEncryptedUrl: true,
    gdprRoutes: true,
    selfService: true,
    guidedTourRequest: true,
    guidedTourAccess: true,
    ssoLogin: false,
    ssoRegister: false,
    editor: true,
    editorAssetScreen: true,
    menu: true,
    menuEmbed: true,
    navmaps: true,
    screenShare: true,
    chat: true,
    ar: true,
    like: true,
    hideNavInfo: true,
    useIframe: true,
    attendee: true,
    streamer: true,
    viewer: true,
    smartDevice: true,
    selfServiceProposition: false,
    navInfoAnimated: false,
    navInfoImportantAnimated: false,
    navMoveAnimated: true,
    navMoveImportantAnimated: true,
    navPointAnimated: false,
    navPointImportantAnimated: false,
    navTitleAnimated: false,
    navTitleImportantAnimated: false,
    navTransparentAnimated: true,
    navTransparentImportantAnimated: true,
    useTextureEnvironment: true,
    usePaths: true,
    antialias: true,
    alpha: false,
    premultipliedAlpha: false
  },
  sso: {
    issuer: 'bhere-sso',
    origin: `http://localhost:3010`,
    loginUrl: `http://localhost:3010/sso/login?redirectUrl={redirectUrl}`,
    logoutUrl: `http://localhost:3010/sso/logout?redirectUrl={redirectUrl}`,
    registerUrl: `http://localhost:3010/sso/register?redirectUrl={redirectUrl}`,
    verifyTokenUrl: `http://localhost:3010/sso/verifytoken?verifyToken={verifytoken}`
  },
  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  profiles: {
    // streamer: "480p_1", // 640 x 480 x 15
    streamer: "480p_2",
    // 640 x 480 x 30
    // streamer: "480p_3", // 480 x 480 x 15
    // streamer: "480p_4", // 640 x 480 x 30
    // streamer: "480p_6", // 480 x 480 x 30
    // streamer: "480p_8", // 848, 480 x 15
    // streamer: "480p_9", // 848, 480 x 30
    // streamer: "480p_10", // 640 x 480 x 10
    // streamer: "720p_1", // 1280 x 720 x 15
    // streamer: "720p_2", // 1280 x 720 x 30
    // streamer: "720p_3", // 1280 x 720 x 30
    // streamer: "720p_5", // 960 x 720 x 15
    // streamer: "720p_6", // 960 x 720 x 30
    // streamer: "1080p_1", // 1920 x 1080 x 15
    // streamer: "1080p_2", // 1920 x 1080 x 30
    // streamer: "1080p_3", // 1920 x 1080 x 30
    // streamer: "1080p_5", // 1920 x 1080 x 60
    // attendee: "720p_2", // 1920 x 1080 x 30
    attendee: "1080p_2",
    // 1920 x 1080 x 30
    // publisher: "720p_2", // 1920 x 1080 x 30
    publisher: "1080p_2",
    // 1920 x 1080 x 30
    // screen: "480p_1", // 640 × 480 x 5
    // screen: "480p_2", // 640 × 480 x 30
    // screen: "720p_1", // 1280 × 720 x 5
    // screen: "720p_2", // 1280 × 720 x 30
    // screen: "1080p_1", // 1920 × 1080 x 5
    screen: "1080p_2" // 1920 × 1080 30

  },
  logo: null,

  /*
  background: {
  	// image: 'img/background.jpg',
  	video: 'img/background.mp4',
  },
  */
  selfServiceAudio: null,
  // 'audio/self-service.mp3',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room'],
    disabledViewItemTypes: ['texture']
  },
  assets: '/docs/',
  dist: '/dist/',
  workers: {
    image: './js/workers/image.service.worker.js',
    prefetch: './js/workers/prefetch.service.worker.js'
  },
  textures: {
    envMap: 'textures/envMap/studio_small_03_2k.hdr',
    grid: 'textures/grid/grid.jpg'
  },
  toneMappingExposure: 1,
  githubDocs: 'https://raw.githubusercontent.com/actarian/b-here/beta-bhere-sso/docs/',
  template: {
    email: {
      supportRequest: '/email/support-request.html'
    }
  }
};class Utils {
  static merge(target, source) {
    // override null values
    if (source === null) {
      return source;
    } // assign new values


    if (!target) {
      if (source && typeof source === 'object') {
        return Object.assign({}, source);
      } else {
        return source;
      }
    } // merge objects


    if (source && typeof source === 'object') {
      Object.keys(source).forEach(key => {
        const value = source[key];

        if (typeof value === 'object' && !Array.isArray(value)) {
          target[key] = this.merge(target[key], value);
        } else {
          target[key] = value;
        }
      });
    }

    return target;
  }

}const NODE = typeof module !== 'undefined' && module.exports;
const PARAMS = NODE ? {
  get: () => {}
} : new URLSearchParams(window.location.search);
const DEBUG = PARAMS.get('debug') != null;
NODE ? null : document.querySelector('base').getAttribute('href');
const HEROKU = NODE ? false : window && window.location.host.indexOf('herokuapp') !== -1;
const VERCEL = NODE ? false : window && window.location.host.indexOf('vercel.app') !== -1;
const DEPLOYED = HEROKU || VERCEL;
const STATIC = NODE ? false : DEPLOYED || window && (window.location.port === '41789' || window.location.port === '5000' || window.location.port === '6443' || window.location.host === 'actarian.github.io');
const DEVELOPMENT = NODE ? false : window && ['localhost', '127.0.0.1', '0.0.0.0'].indexOf(window.location.host.split(':')[0]) !== -1;
const PRODUCTION = !DEVELOPMENT;
const ENV = {
  STATIC,
  DEVELOPMENT,
  PRODUCTION
};
class Environment {
  get STATIC() {
    return ENV.STATIC;
  }

  set STATIC(STATIC) {
    ENV.STATIC = STATIC === true || STATIC === 'true';
    console.log('Environment.STATIC.set', ENV.STATIC);
  }

  get href() {
    if (DEPLOYED) {
      return this.githubDocs;
    } else {
      return this.assets;
    }
  }

  getAbsoluteUrl(path, params) {
    let url = `${window.location.origin}${path}`; // let url = `${window.location.protocol}//${window.location.host}${path}`;

    Object.keys(params).forEach(key => {
      url = url.replace(`$${key}`, params[key]);
    });
    return url;
  }

  getPath(path) {
    return this.isLocal(path) ? this.href + path : path;
  }

  isLocal(path) {
    return path.indexOf('://') === -1;
  }

  merge(options) {
    if (options) {
      Utils.merge(this, options);
    }
  }

  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }

}
const defaultOptions$3 = {
  port: 5000,
  // fontFamily: 'GT Walsheim, sans-serif',
  fontFamily: 'Work Sans, sans-serif',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room', 'room-3d', 'media'],
    disabledViewItemTypes: ['texture']
  },
  renderOrder: {
    panorama: 0,
    room: 10,
    plane: 20,
    tile: 30,
    model: 40,
    banner: 50,
    nav: 60,
    panel: 70,
    menu: 80,
    debug: 90,
    pointer: 100
  }
};
const defaultAppOptions = {
  channelName: 'BHere',
  flags: {
    heroku: HEROKU,
    vercel: VERCEL,
    deployed: DEPLOYED
  },
  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  url: {},
  languages: ['it', 'en'],
  defaultLanguage: 'it',
  labels: {},
  data: {},
  fields: []
};
const environmentOptions = window.STATIC ? environmentStatic : environmentServed;
let options = Object.assign(defaultOptions$3, defaultAppOptions, environmentOptions);
options = Utils.merge(options, window.bhere);
const environment = new Environment(options);
console.log('environment', environment);/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign$3 = function() {
    __assign$3 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$3.apply(this, arguments);
};/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign$2 = function() {
    __assign$2 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};var makeOptions = function makeOptions(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return {
    arrayFormat: opts.arrayFormat || 'none',
    booleanFormat: opts.booleanFormat || 'none',
    nullFormat: opts.nullFormat || 'default'
  };
};

var encodeValue = function encodeValue(value) {
  return encodeURIComponent(value);
};

var decodeValue = function decodeValue(value) {
  return decodeURIComponent(value);
};

var encodeBoolean = function encodeBoolean(name, value, opts) {
  if (opts.booleanFormat === 'empty-true' && value) {
    return name;
  }

  var encodedValue;

  if (opts.booleanFormat === 'unicode') {
    encodedValue = value ? '✓' : '✗';
  } else {
    encodedValue = value.toString();
  }

  return name + "=" + encodedValue;
};

var encodeNull = function encodeNull(name, opts) {
  if (opts.nullFormat === 'hidden') {
    return '';
  }

  if (opts.nullFormat === 'string') {
    return name + "=null";
  }

  return name;
};

var getNameEncoder = function getNameEncoder(opts) {
  if (opts.arrayFormat === 'index') {
    return function (name, index) {
      return name + "[" + index + "]";
    };
  }

  if (opts.arrayFormat === 'brackets') {
    return function (name) {
      return name + "[]";
    };
  }

  return function (name) {
    return name;
  };
};

var encodeArray = function encodeArray(name, arr, opts) {
  var encodeName = getNameEncoder(opts);
  return arr.map(function (val, index) {
    return encodeName(name, index) + "=" + encodeValue(val);
  }).join('&');
};
var encode = function encode(name, value, opts) {
  if (value === null) {
    return encodeNull(name, opts);
  }

  if (typeof value === 'boolean') {
    return encodeBoolean(name, value, opts);
  }

  if (Array.isArray(value)) {
    return encodeArray(name, value, opts);
  }

  return name + "=" + encodeValue(value);
};
var decode = function decode(value, opts) {
  if (value === undefined) {
    return opts.booleanFormat === 'empty-true' ? true : null;
  }

  if (opts.booleanFormat === 'string') {
    if (value === 'true') {
      return true;
    }

    if (value === 'false') {
      return false;
    }
  }

  if (opts.booleanFormat === 'unicode') {
    if (decodeValue(value) === '✓') {
      return true;
    }

    if (decodeValue(value) === '✗') {
      return false;
    }
  }

  if (opts.nullFormat === 'string') {
    if (value === 'null') {
      return null;
    }
  }

  return decodeValue(value);
};

var getSearch$1 = function getSearch(path) {
  var pos = path.indexOf('?');

  if (pos === -1) {
    return path;
  }

  return path.slice(pos + 1);
};
var isSerialisable = function isSerialisable(val) {
  return val !== undefined;
};
var parseName = function parseName(name) {
  var bracketPosition = name.indexOf('[');
  var hasBrackets = bracketPosition !== -1;
  return {
    hasBrackets: hasBrackets,
    name: hasBrackets ? name.slice(0, bracketPosition) : name
  };
};

/**
 * Parse a querystring and return an object of parameters
 */

var parse = function parse(path, opts) {
  var options = makeOptions(opts);
  return getSearch$1(path).split('&').reduce(function (params, param) {
    var _a = param.split('='),
        rawName = _a[0],
        value = _a[1];

    var _b = parseName(rawName),
        hasBrackets = _b.hasBrackets,
        name = _b.name;

    var currentValue = params[name];
    var decodedValue = decode(value, options);

    if (currentValue === undefined) {
      params[name] = hasBrackets ? [decodedValue] : decodedValue;
    } else {
      params[name] = (Array.isArray(currentValue) ? currentValue : [currentValue]).concat(decodedValue);
    }

    return params;
  }, {});
};
/**
 * Build a querystring from an object of parameters
 */

var build = function build(params, opts) {
  var options = makeOptions(opts);
  return Object.keys(params).filter(function (paramName) {
    return isSerialisable(params[paramName]);
  }).map(function (paramName) {
    return encode(paramName, params[paramName], options);
  }).filter(Boolean).join('&');
};
/**
 * Remove a list of parameters from a querystring
 */

var omit = function omit(path, paramsToOmit, opts) {
  var options = makeOptions(opts);
  var searchPart = getSearch$1(path);

  if (searchPart === '') {
    return {
      querystring: '',
      removedParams: {}
    };
  }

  var _a = path.split('&').reduce(function (_a, chunk) {
    var left = _a[0],
        right = _a[1];
    var rawName = chunk.split('=')[0];
    var name = parseName(rawName).name;
    return paramsToOmit.indexOf(name) === -1 ? [left.concat(chunk), right] : [left, right.concat(chunk)];
  }, [[], []]),
      kept = _a[0],
      removed = _a[1];

  return {
    querystring: kept.join('&'),
    removedParams: parse(removed.join('&'), options)
  };
};/**
 * We encode using encodeURIComponent but we want to
 * preserver certain characters which are commonly used
 * (sub delimiters and ':')
 *
 * https://www.ietf.org/rfc/rfc3986.txt
 *
 * reserved    = gen-delims / sub-delims
 *
 * gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
 *
 * sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="
 */
var excludeSubDelimiters = /[^!$'()*+,;|:]/g;
var encodeURIComponentExcludingSubDelims = function encodeURIComponentExcludingSubDelims(segment) {
  return segment.replace(excludeSubDelimiters, function (match) {
    return encodeURIComponent(match);
  });
};
var encodingMethods = {
  "default": encodeURIComponentExcludingSubDelims,
  uri: encodeURI,
  uriComponent: encodeURIComponent,
  none: function none(val) {
    return val;
  },
  legacy: encodeURI
};
var decodingMethods = {
  "default": decodeURIComponent,
  uri: decodeURI,
  uriComponent: decodeURIComponent,
  none: function none(val) {
    return val;
  },
  legacy: decodeURIComponent
};
var encodeParam = function encodeParam(param, encoding, isSpatParam) {
  var encoder = encodingMethods[encoding] || encodeURIComponentExcludingSubDelims;

  if (isSpatParam) {
    return String(param).split('/').map(encoder).join('/');
  }

  return encoder(String(param));
};
var decodeParam = function decodeParam(param, encoding) {
  return (decodingMethods[encoding] || decodeURIComponent)(param);
};

var defaultOrConstrained = function defaultOrConstrained(match) {
  return '(' + (match ? match.replace(/(^<|>$)/g, '') : "[a-zA-Z0-9-_.~%':|=+\\*@$]+") + ')';
};
var rules = [{
  name: 'url-parameter',
  pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
  regex: function regex(match) {
    return new RegExp(defaultOrConstrained(match[2]));
  }
}, {
  name: 'url-parameter-splat',
  pattern: /^\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,
  regex: /([^?]*)/
}, {
  name: 'url-parameter-matrix',
  pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
  regex: function regex(match) {
    return new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]));
  }
}, {
  name: 'query-parameter',
  pattern: /^(?:\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/
}, {
  name: 'delimiter',
  pattern: /^(\/|\?)/,
  regex: function regex(match) {
    return new RegExp('\\' + match[0]);
  }
}, {
  name: 'sub-delimiter',
  pattern: /^(!|&|-|_|\.|;)/,
  regex: function regex(match) {
    return new RegExp(match[0]);
  }
}, {
  name: 'fragment',
  pattern: /^([0-9a-zA-Z]+)/,
  regex: function regex(match) {
    return new RegExp(match[0]);
  }
}];

var tokenise = function tokenise(str, tokens) {
  if (tokens === void 0) {
    tokens = [];
  } // Look for a matching rule


  var matched = rules.some(function (rule) {
    var match = str.match(rule.pattern);

    if (!match) {
      return false;
    }

    tokens.push({
      type: rule.name,
      match: match[0],
      val: match.slice(1, 2),
      otherVal: match.slice(2),
      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex
    });

    if (match[0].length < str.length) {
      tokens = tokenise(str.substr(match[0].length), tokens);
    }

    return true;
  }); // If no rules matched, throw an error (possible malformed path)

  if (!matched) {
    throw new Error("Could not parse path '" + str + "'");
  }

  return tokens;
};

var exists$1 = function exists(val) {
  return val !== undefined && val !== null;
};

var optTrailingSlash = function optTrailingSlash(source, strictTrailingSlash) {
  if (strictTrailingSlash) {
    return source;
  }

  if (source === '\\/') {
    return source;
  }

  return source.replace(/\\\/$/, '') + '(?:\\/)?';
};

var upToDelimiter = function upToDelimiter(source, delimiter) {
  if (!delimiter) {
    return source;
  }

  return /(\/)$/.test(source) ? source : source + '(\\/|\\?|\\.|;|$)';
};

var appendQueryParam = function appendQueryParam(params, param, val) {
  if (val === void 0) {
    val = '';
  }

  var existingVal = params[param];

  if (existingVal === undefined) {
    params[param] = val;
  } else {
    params[param] = Array.isArray(existingVal) ? existingVal.concat(val) : [existingVal, val];
  }

  return params;
};

var defaultOptions$2 = {
  urlParamsEncoding: 'default'
};

var Path$1 =
/*#__PURE__*/

/** @class */
function () {
  function Path(path, options) {
    if (!path) {
      throw new Error('Missing path in Path constructor');
    }

    this.path = path;
    this.options = __assign$2(__assign$2({}, defaultOptions$2), options);
    this.tokens = tokenise(path);
    this.hasUrlParams = this.tokens.filter(function (t) {
      return /^url-parameter/.test(t.type);
    }).length > 0;
    this.hasSpatParam = this.tokens.filter(function (t) {
      return /splat$/.test(t.type);
    }).length > 0;
    this.hasMatrixParams = this.tokens.filter(function (t) {
      return /matrix$/.test(t.type);
    }).length > 0;
    this.hasQueryParams = this.tokens.filter(function (t) {
      return /^query-parameter/.test(t.type);
    }).length > 0; // Extract named parameters from tokens

    this.spatParams = this.getParams('url-parameter-splat');
    this.urlParams = this.getParams(/^url-parameter/); // Query params

    this.queryParams = this.getParams('query-parameter'); // All params

    this.params = this.urlParams.concat(this.queryParams); // Check if hasQueryParams
    // Regular expressions for url part only (full and partial match)

    this.source = this.tokens.filter(function (t) {
      return t.regex !== undefined;
    }).map(function (t) {
      return t.regex.source;
    }).join('');
  }

  Path.createPath = function (path, options) {
    return new Path(path, options);
  };

  Path.prototype.isQueryParam = function (name) {
    return this.queryParams.indexOf(name) !== -1;
  };

  Path.prototype.isSpatParam = function (name) {
    return this.spatParams.indexOf(name) !== -1;
  };

  Path.prototype.test = function (path, opts) {
    var _this = this;

    var options = __assign$2(__assign$2({
      caseSensitive: false,
      strictTrailingSlash: false
    }, this.options), opts); // trailingSlash: falsy => non optional, truthy => optional


    var source = optTrailingSlash(this.source, options.strictTrailingSlash); // Check if exact match

    var match = this.urlTest(path, source + (this.hasQueryParams ? '(\\?.*$|$)' : '$'), options.caseSensitive, options.urlParamsEncoding); // If no match, or no query params, no need to go further

    if (!match || !this.hasQueryParams) {
      return match;
    } // Extract query params


    var queryParams = parse(path, options.queryParams);
    var unexpectedQueryParams = Object.keys(queryParams).filter(function (p) {
      return !_this.isQueryParam(p);
    });

    if (unexpectedQueryParams.length === 0) {
      // Extend url match
      Object.keys(queryParams).forEach( // @ts-ignore
      function (p) {
        return match[p] = queryParams[p];
      });
      return match;
    }

    return null;
  };

  Path.prototype.partialTest = function (path, opts) {
    var _this = this;

    var options = __assign$2(__assign$2({
      caseSensitive: false,
      delimited: true
    }, this.options), opts); // Check if partial match (start of given path matches regex)
    // trailingSlash: falsy => non optional, truthy => optional


    var source = upToDelimiter(this.source, options.delimited);
    var match = this.urlTest(path, source, options.caseSensitive, options.urlParamsEncoding);

    if (!match) {
      return match;
    }

    if (!this.hasQueryParams) {
      return match;
    }

    var queryParams = parse(path, options.queryParams);
    Object.keys(queryParams).filter(function (p) {
      return _this.isQueryParam(p);
    }).forEach(function (p) {
      return appendQueryParam(match, p, queryParams[p]);
    });
    return match;
  };

  Path.prototype.build = function (params, opts) {
    var _this = this;

    if (params === void 0) {
      params = {};
    }

    var options = __assign$2(__assign$2({
      ignoreConstraints: false,
      ignoreSearch: false,
      queryParams: {}
    }, this.options), opts);

    var encodedUrlParams = Object.keys(params).filter(function (p) {
      return !_this.isQueryParam(p);
    }).reduce(function (acc, key) {
      if (!exists$1(params[key])) {
        return acc;
      }

      var val = params[key];

      var isSpatParam = _this.isSpatParam(key);

      if (typeof val === 'boolean') {
        acc[key] = val;
      } else if (Array.isArray(val)) {
        acc[key] = val.map(function (v) {
          return encodeParam(v, options.urlParamsEncoding, isSpatParam);
        });
      } else {
        acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam);
      }

      return acc;
    }, {}); // Check all params are provided (not search parameters which are optional)

    if (this.urlParams.some(function (p) {
      return !exists$1(params[p]);
    })) {
      var missingParameters = this.urlParams.filter(function (p) {
        return !exists$1(params[p]);
      });
      throw new Error("Cannot build path: '" + this.path + "' requires missing parameters { " + missingParameters.join(', ') + ' }');
    } // Check constraints


    if (!options.ignoreConstraints) {
      var constraintsPassed = this.tokens.filter(function (t) {
        return /^url-parameter/.test(t.type) && !/-splat$/.test(t.type);
      }).every(function (t) {
        return new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(encodedUrlParams[t.val]);
      });

      if (!constraintsPassed) {
        throw new Error("Some parameters of '" + this.path + "' are of invalid format");
      }
    }

    var base = this.tokens.filter(function (t) {
      return /^query-parameter/.test(t.type) === false;
    }).map(function (t) {
      if (t.type === 'url-parameter-matrix') {
        return ";" + t.val + "=" + encodedUrlParams[t.val[0]];
      }

      return /^url-parameter/.test(t.type) ? encodedUrlParams[t.val[0]] : t.match;
    }).join('');

    if (options.ignoreSearch) {
      return base;
    }

    var searchParams = this.queryParams.filter(function (p) {
      return Object.keys(params).indexOf(p) !== -1;
    }).reduce(function (sparams, paramName) {
      sparams[paramName] = params[paramName];
      return sparams;
    }, {});
    var searchPart = build(searchParams, options.queryParams);
    return searchPart ? base + '?' + searchPart : base;
  };

  Path.prototype.getParams = function (type) {
    var predicate = type instanceof RegExp ? function (t) {
      return type.test(t.type);
    } : function (t) {
      return t.type === type;
    };
    return this.tokens.filter(predicate).map(function (t) {
      return t.val[0];
    });
  };

  Path.prototype.urlTest = function (path, source, caseSensitive, urlParamsEncoding) {
    var _this = this;

    var regex = new RegExp('^' + source, caseSensitive ? '' : 'i');
    var match = path.match(regex);

    if (!match) {
      return null;
    } else if (!this.urlParams.length) {
      return {};
    } // Reduce named params to key-value pairs


    return match.slice(1, this.urlParams.length + 1).reduce(function (params, m, i) {
      params[_this.urlParams[i]] = decodeParam(m, urlParamsEncoding);
      return params;
    }, {});
  };

  return Path;
}();var getMetaFromSegments = function getMetaFromSegments(segments) {
  var accName = '';
  return segments.reduce(function (meta, segment) {
    var _a, _b, _c, _d;

    var urlParams = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.urlParams.reduce(function (params, p) {
      params[p] = 'url';
      return params;
    }, {}), _b !== null && _b !== void 0 ? _b : {});
    var allParams = (_d = (_c = segment.parser) === null || _c === void 0 ? void 0 : _c.queryParams.reduce(function (params, p) {
      params[p] = 'query';
      return params;
    }, urlParams), _d !== null && _d !== void 0 ? _d : {});

    if (segment.name !== undefined) {
      accName = accName ? accName + '.' + segment.name : segment.name;
      meta[accName] = allParams;
    }

    return meta;
  }, {});
};
var buildStateFromMatch = function buildStateFromMatch(match) {
  if (!match || !match.segments || !match.segments.length) {
    return null;
  }

  var name = match.segments.map(function (segment) {
    return segment.name;
  }).filter(function (name) {
    return name;
  }).join('.');
  var params = match.params;
  return {
    name: name,
    params: params,
    meta: getMetaFromSegments(match.segments)
  };
};
var buildPathFromSegments = function buildPathFromSegments(segments, params, options) {
  if (params === void 0) {
    params = {};
  }

  if (options === void 0) {
    options = {};
  }

  var _a = options.queryParamsMode,
      queryParamsMode = _a === void 0 ? 'default' : _a,
      _b = options.trailingSlashMode,
      trailingSlashMode = _b === void 0 ? 'default' : _b;
  var searchParams = [];
  var nonSearchParams = [];

  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    var parser = segment.parser;

    if (parser) {
      searchParams.push.apply(searchParams, parser.queryParams);
      nonSearchParams.push.apply(nonSearchParams, parser.urlParams);
      nonSearchParams.push.apply(nonSearchParams, parser.spatParams);
    }
  }

  if (queryParamsMode === 'loose') {
    var extraParams = Object.keys(params).reduce(function (acc, p) {
      return searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1 ? acc.concat(p) : acc;
    }, []);
    searchParams.push.apply(searchParams, extraParams);
  }

  var searchParamsObject = searchParams.reduce(function (acc, paramName) {
    if (Object.keys(params).indexOf(paramName) !== -1) {
      acc[paramName] = params[paramName];
    }

    return acc;
  }, {});
  var searchPart = build(searchParamsObject, options.queryParams);
  var path = segments.reduce(function (path, segment) {
    var _a, _b;

    var segmentPath = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.build(params, {
      ignoreSearch: true,
      queryParams: options.queryParams,
      urlParamsEncoding: options.urlParamsEncoding
    }), _b !== null && _b !== void 0 ? _b : '');
    return segment.absolute ? segmentPath : path + segmentPath;
  }, '') // remove repeated slashes
  .replace(/\/\/{1,}/g, '/');
  var finalPath = path;

  if (trailingSlashMode === 'always') {
    finalPath = /\/$/.test(path) ? path : path + "/";
  } else if (trailingSlashMode === 'never' && path !== '/') {
    finalPath = /\/$/.test(path) ? path.slice(0, -1) : path;
  }

  return finalPath + (searchPart ? '?' + searchPart : '');
};
var getPathFromSegments = function getPathFromSegments(segments) {
  return segments ? segments.map(function (segment) {
    return segment.path;
  }).join('') : null;
};

var getPath = function getPath(path) {
  return path.split('?')[0];
};

var getSearch = function getSearch(path) {
  return path.split('?')[1] || '';
};

var matchChildren = function matchChildren(nodes, pathSegment, currentMatch, options, consumedBefore) {
  if (options === void 0) {
    options = {};
  }

  var _a = options.queryParamsMode,
      queryParamsMode = _a === void 0 ? 'default' : _a,
      _b = options.strictTrailingSlash,
      strictTrailingSlash = _b === void 0 ? false : _b,
      _c = options.strongMatching,
      strongMatching = _c === void 0 ? true : _c,
      _d = options.caseSensitive,
      caseSensitive = _d === void 0 ? false : _d;
  var isRoot = nodes.length === 1 && nodes[0].name === '';

  var _loop_1 = function _loop_1(child) {
    // Partially match path
    var match = null;
    var remainingPath = void 0;
    var segment = pathSegment;

    if (consumedBefore === '/' && child.path === '/') {
      // when we encounter repeating slashes we add the slash
      // back to the URL to make it de facto pathless
      segment = '/' + pathSegment;
    }

    if (!child.children.length) {
      match = child.parser.test(segment, {
        caseSensitive: caseSensitive,
        strictTrailingSlash: strictTrailingSlash,
        queryParams: options.queryParams,
        urlParamsEncoding: options.urlParamsEncoding
      });
    }

    if (!match) {
      match = child.parser.partialTest(segment, {
        delimited: strongMatching,
        caseSensitive: caseSensitive,
        queryParams: options.queryParams,
        urlParamsEncoding: options.urlParamsEncoding
      });
    }

    if (match) {
      // Remove consumed segment from path
      var consumedPath = child.parser.build(match, {
        ignoreSearch: true,
        urlParamsEncoding: options.urlParamsEncoding
      });

      if (!strictTrailingSlash && !child.children.length) {
        consumedPath = consumedPath.replace(/\/$/, '');
      } // Can't create a regexp from the path because it might contain a
      // regexp character.


      if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {
        remainingPath = segment.slice(consumedPath.length);
      } else {
        remainingPath = segment;
      }

      if (!strictTrailingSlash && !child.children.length) {
        remainingPath = remainingPath.replace(/^\/\?/, '?');
      }

      var querystring = omit(getSearch(segment.replace(consumedPath, '')), child.parser.queryParams, options.queryParams).querystring;
      remainingPath = getPath(remainingPath) + (querystring ? "?" + querystring : '');

      if (!strictTrailingSlash && !isRoot && remainingPath === '/' && !/\/$/.test(consumedPath)) {
        remainingPath = '';
      }

      currentMatch.segments.push(child);
      Object.keys(match).forEach(function (param) {
        return currentMatch.params[param] = match[param];
      });

      if (!isRoot && !remainingPath.length) {
        return {
          value: currentMatch
        };
      }

      if (!isRoot && queryParamsMode !== 'strict' && remainingPath.indexOf('?') === 0) {
        // unmatched queryParams in non strict mode
        var remainingQueryParams_1 = parse(remainingPath.slice(1), options.queryParams);
        Object.keys(remainingQueryParams_1).forEach(function (name) {
          return currentMatch.params[name] = remainingQueryParams_1[name];
        });
        return {
          value: currentMatch
        };
      } // Continue matching on non absolute children


      var children = child.getNonAbsoluteChildren(); // If no children to match against but unmatched path left

      if (!children.length) {
        return {
          value: null
        };
      }

      return {
        value: matchChildren(children, remainingPath, currentMatch, options, consumedPath)
      };
    }
  }; // for (child of node.children) {


  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var child = nodes_1[_i];

    var state_1 = _loop_1(child);

    if (typeof state_1 === "object") return state_1.value;
  }

  return null;
};

function sortChildren(children) {
  var originalChildren = children.slice(0);
  return children.sort(sortPredicate(originalChildren));
}

var sortPredicate = function sortPredicate(originalChildren) {
  return function (left, right) {
    var _a, _b, _c, _d, _e, _f;

    var leftPath = left.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\/$/, '$1');
    var rightPath = right.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\/$/, '$1'); // '/' last

    if (leftPath === '/') {
      return 1;
    }

    if (rightPath === '/') {
      return -1;
    } // Spat params last


    if ((_a = left.parser) === null || _a === void 0 ? void 0 : _a.hasSpatParam) {
      return 1;
    }

    if ((_b = right.parser) === null || _b === void 0 ? void 0 : _b.hasSpatParam) {
      return -1;
    } // No spat, number of segments (less segments last)


    var leftSegments = (leftPath.match(/\//g) || []).length;
    var rightSegments = (rightPath.match(/\//g) || []).length;

    if (leftSegments < rightSegments) {
      return 1;
    }

    if (leftSegments > rightSegments) {
      return -1;
    } // Same number of segments, number of URL params ascending


    var leftParamsCount = (_d = (_c = left.parser) === null || _c === void 0 ? void 0 : _c.urlParams.length, _d !== null && _d !== void 0 ? _d : 0);
    var rightParamsCount = (_f = (_e = right.parser) === null || _e === void 0 ? void 0 : _e.urlParams.length, _f !== null && _f !== void 0 ? _f : 0);

    if (leftParamsCount < rightParamsCount) {
      return -1;
    }

    if (leftParamsCount > rightParamsCount) {
      return 1;
    } // Same number of segments and params, last segment length descending


    var leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length;
    var rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length;

    if (leftParamLength < rightParamLength) {
      return 1;
    }

    if (leftParamLength > rightParamLength) {
      return -1;
    } // Same last segment length, preserve definition order. Note that we
    // cannot just return 0, as sort is not guaranteed to be a stable sort.


    return originalChildren.indexOf(left) - originalChildren.indexOf(right);
  };
};

var RouteNode =
/*#__PURE__*/

/** @class */
function () {
  function RouteNode(name, path, childRoutes, options) {
    if (name === void 0) {
      name = '';
    }

    if (path === void 0) {
      path = '';
    }

    if (childRoutes === void 0) {
      childRoutes = [];
    }

    if (options === void 0) {
      options = {};
    }

    this.name = name;
    this.absolute = /^~/.test(path);
    this.path = this.absolute ? path.slice(1) : path;
    this.parser = this.path ? new Path$1(this.path) : null;
    this.children = [];
    this.parent = options.parent;
    this.checkParents();
    this.add(childRoutes, options.onAdd, options.finalSort ? false : options.sort !== false);

    if (options.finalSort) {
      this.sortDescendants();
    }

    return this;
  }

  RouteNode.prototype.getParentSegments = function (segments) {
    if (segments === void 0) {
      segments = [];
    }

    return this.parent && this.parent.parser ? this.parent.getParentSegments(segments.concat(this.parent)) : segments.reverse();
  };

  RouteNode.prototype.setParent = function (parent) {
    this.parent = parent;
    this.checkParents();
  };

  RouteNode.prototype.setPath = function (path) {
    if (path === void 0) {
      path = '';
    }

    this.path = path;
    this.parser = path ? new Path$1(path) : null;
  };

  RouteNode.prototype.add = function (route, cb, sort) {
    var _this = this;

    if (sort === void 0) {
      sort = true;
    }

    if (route === undefined || route === null) {
      return this;
    }

    if (route instanceof Array) {
      route.forEach(function (r) {
        return _this.add(r, cb, sort);
      });
      return this;
    }

    if (!(route instanceof RouteNode) && !(route instanceof Object)) {
      throw new Error('RouteNode.add() expects routes to be an Object or an instance of RouteNode.');
    } else if (route instanceof RouteNode) {
      route.setParent(this);
      this.addRouteNode(route, sort);
    } else {
      if (!route.name || !route.path) {
        throw new Error('RouteNode.add() expects routes to have a name and a path defined.');
      }

      var routeNode = new RouteNode(route.name, route.path, route.children, {
        finalSort: false,
        onAdd: cb,
        parent: this,
        sort: sort
      });
      var fullName = routeNode.getParentSegments([routeNode]).map(function (_) {
        return _.name;
      }).join('.');

      if (cb) {
        cb(__assign$3(__assign$3({}, route), {
          name: fullName
        }));
      }

      this.addRouteNode(routeNode, sort);
    }

    return this;
  };

  RouteNode.prototype.addNode = function (name, path) {
    this.add(new RouteNode(name, path));
    return this;
  };

  RouteNode.prototype.getPath = function (routeName) {
    var segmentsByName = this.getSegmentsByName(routeName);
    return segmentsByName ? getPathFromSegments(segmentsByName) : null;
  };

  RouteNode.prototype.getNonAbsoluteChildren = function () {
    return this.children.filter(function (child) {
      return !child.absolute;
    });
  };

  RouteNode.prototype.sortChildren = function () {
    if (this.children.length) {
      sortChildren(this.children);
    }
  };

  RouteNode.prototype.sortDescendants = function () {
    this.sortChildren();
    this.children.forEach(function (child) {
      return child.sortDescendants();
    });
  };

  RouteNode.prototype.buildPath = function (routeName, params, options) {
    if (params === void 0) {
      params = {};
    }

    if (options === void 0) {
      options = {};
    }

    var segments = this.getSegmentsByName(routeName);

    if (!segments) {
      throw new Error("[route-node][buildPath] '{routeName}' is not defined");
    }

    return buildPathFromSegments(segments, params, options);
  };

  RouteNode.prototype.buildState = function (name, params) {
    if (params === void 0) {
      params = {};
    }

    var segments = this.getSegmentsByName(name);

    if (!segments || !segments.length) {
      return null;
    }

    return {
      name: name,
      params: params,
      meta: getMetaFromSegments(segments)
    };
  };

  RouteNode.prototype.matchPath = function (path, options) {
    if (options === void 0) {
      options = {};
    }

    if (path === '' && !options.strictTrailingSlash) {
      path = '/';
    }

    var match = this.getSegmentsMatchingPath(path, options);

    if (!match) {
      return null;
    }

    var matchedSegments = match.segments;

    if (matchedSegments[0].absolute) {
      var firstSegmentParams = matchedSegments[0].getParentSegments();
      matchedSegments.reverse();
      matchedSegments.push.apply(matchedSegments, firstSegmentParams);
      matchedSegments.reverse();
    }

    var lastSegment = matchedSegments[matchedSegments.length - 1];
    var lastSegmentSlashChild = lastSegment.findSlashChild();

    if (lastSegmentSlashChild) {
      matchedSegments.push(lastSegmentSlashChild);
    }

    return buildStateFromMatch(match);
  };

  RouteNode.prototype.addRouteNode = function (route, sort) {
    if (sort === void 0) {
      sort = true;
    }

    var names = route.name.split('.');

    if (names.length === 1) {
      // Check duplicated routes
      if (this.children.map(function (child) {
        return child.name;
      }).indexOf(route.name) !== -1) {
        throw new Error("Alias \"" + route.name + "\" is already defined in route node");
      } // Check duplicated paths


      if (this.children.map(function (child) {
        return child.path;
      }).indexOf(route.path) !== -1) {
        throw new Error("Path \"" + route.path + "\" is already defined in route node");
      }

      this.children.push(route);

      if (sort) {
        this.sortChildren();
      }
    } else {
      // Locate parent node
      var segments = this.getSegmentsByName(names.slice(0, -1).join('.'));

      if (segments) {
        route.name = names[names.length - 1];
        segments[segments.length - 1].add(route);
      } else {
        throw new Error("Could not add route named '" + route.name + "', parent is missing.");
      }
    }

    return this;
  };

  RouteNode.prototype.checkParents = function () {
    if (this.absolute && this.hasParentsParams()) {
      throw new Error('[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters');
    }
  };

  RouteNode.prototype.hasParentsParams = function () {
    if (this.parent && this.parent.parser) {
      var parser = this.parent.parser;
      var hasParams = parser.hasUrlParams || parser.hasSpatParam || parser.hasMatrixParams || parser.hasQueryParams;
      return hasParams || this.parent.hasParentsParams();
    }

    return false;
  };

  RouteNode.prototype.findAbsoluteChildren = function () {
    return this.children.reduce(function (absoluteChildren, child) {
      return absoluteChildren.concat(child.absolute ? child : []).concat(child.findAbsoluteChildren());
    }, []);
  };

  RouteNode.prototype.findSlashChild = function () {
    var slashChildren = this.getNonAbsoluteChildren().filter(function (child) {
      return child.parser && /^\/(\?|$)/.test(child.parser.path);
    });
    return slashChildren[0];
  };

  RouteNode.prototype.getSegmentsByName = function (routeName) {
    var findSegmentByName = function findSegmentByName(name, routes) {
      var filteredRoutes = routes.filter(function (r) {
        return r.name === name;
      });
      return filteredRoutes.length ? filteredRoutes[0] : undefined;
    };

    var segments = [];
    var routes = this.parser ? [this] : this.children;
    var names = (this.parser ? [''] : []).concat(routeName.split('.'));
    var matched = names.every(function (name) {
      var segment = findSegmentByName(name, routes);

      if (segment) {
        routes = segment.children;
        segments.push(segment);
        return true;
      }

      return false;
    });
    return matched ? segments : null;
  };

  RouteNode.prototype.getSegmentsMatchingPath = function (path, options) {
    var topLevelNodes = this.parser ? [this] : this.children;
    var startingNodes = topLevelNodes.reduce(function (nodes, node) {
      return nodes.concat(node, node.findAbsoluteChildren());
    }, []);
    var currentMatch = {
      segments: [],
      params: {}
    };
    var finalMatch = matchChildren(startingNodes, path, currentMatch, options);

    if (finalMatch && finalMatch.segments.length === 1 && finalMatch.segments[0].name === '') {
      return null;
    }

    return finalMatch;
  };

  return RouteNode;
}();function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}/* global window */

var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = symbolObservablePonyfill(root);var nameToIDs = function (name) {
    return name
        .split('.')
        .reduce(function (ids, name) {
        return ids.concat(ids.length ? ids[ids.length - 1] + '.' + name : name);
    }, []);
};
var exists = function (val) { return val !== undefined && val !== null; };
var hasMetaParams = function (state) { return state && state.meta && state.meta.params; };
var extractSegmentParams = function (name, state) {
    if (!hasMetaParams(state) || !exists(state.meta.params[name]))
        return {};
    return Object.keys(state.meta.params[name]).reduce(function (params, p) {
        params[p] = state.params[p];
        return params;
    }, {});
};
function transitionPath(toState, fromState) {
    var toStateOptions = (toState.meta && toState.meta && toState.meta.options) || {};
    var fromStateIds = fromState ? nameToIDs(fromState.name) : [];
    var toStateIds = nameToIDs(toState.name);
    var maxI = Math.min(fromStateIds.length, toStateIds.length);
    function pointOfDifference() {
        var i;
        var _loop_1 = function () {
            var left = fromStateIds[i];
            var right = toStateIds[i];
            if (left !== right)
                return { value: i };
            var leftParams = extractSegmentParams(left, toState);
            var rightParams = extractSegmentParams(right, fromState);
            if (Object.keys(leftParams).length !==
                Object.keys(rightParams).length)
                return { value: i };
            if (Object.keys(leftParams).length === 0)
                return "continue";
            var different = Object.keys(leftParams).some(function (p) { return rightParams[p] !== leftParams[p]; });
            if (different) {
                return { value: i };
            }
        };
        for (i = 0; i < maxI; i += 1) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return i;
    }
    var i;
    if (!fromState || toStateOptions.reload) {
        i = 0;
    }
    else if (!hasMetaParams(fromState) && !hasMetaParams(toState)) {
        i = 0;
    }
    else {
        i = pointOfDifference();
    }
    var toDeactivate = fromStateIds.slice(i).reverse();
    var toActivate = toStateIds.slice(i);
    var intersection = fromState && i > 0 ? fromStateIds[i - 1] : '';
    return {
        intersection: intersection,
        toDeactivate: toDeactivate,
        toActivate: toActivate
    };
}/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

var defaultOptions$1 = {
    trailingSlashMode: 'default',
    queryParamsMode: 'default',
    strictTrailingSlash: false,
    autoCleanUp: true,
    allowNotFound: false,
    strongMatching: true,
    rewritePathOnMatch: true,
    caseSensitive: false,
    urlParamsEncoding: 'default'
};
function withOptions(options) {
    return function (router) {
        var routerOptions = __assign$1(__assign$1({}, defaultOptions$1), options);
        router.getOptions = function () { return routerOptions; };
        router.setOption = function (option, value) {
            routerOptions[option] = value;
            return router;
        };
        return router;
    };
}

var errorCodes = {
    ROUTER_NOT_STARTED: 'NOT_STARTED',
    NO_START_PATH_OR_STATE: 'NO_START_PATH_OR_STATE',
    ROUTER_ALREADY_STARTED: 'ALREADY_STARTED',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND',
    SAME_STATES: 'SAME_STATES',
    CANNOT_DEACTIVATE: 'CANNOT_DEACTIVATE',
    CANNOT_ACTIVATE: 'CANNOT_ACTIVATE',
    TRANSITION_ERR: 'TRANSITION_ERR',
    TRANSITION_CANCELLED: 'CANCELLED'
};
var constants = {
    UNKNOWN_ROUTE: '@@router5/UNKNOWN_ROUTE',
    ROUTER_START: '$start',
    ROUTER_STOP: '$stop',
    TRANSITION_START: '$$start',
    TRANSITION_CANCEL: '$$cancel',
    TRANSITION_SUCCESS: '$$success',
    TRANSITION_ERROR: '$$error'
};

function withRoutes(routes) {
    return function (router) {
        router.forward = function (fromRoute, toRoute) {
            router.config.forwardMap[fromRoute] = toRoute;
            return router;
        };
        var rootNode = routes instanceof RouteNode
            ? routes
            : new RouteNode('', '', routes, { onAdd: onRouteAdded });
        function onRouteAdded(route) {
            if (route.canActivate)
                router.canActivate(route.name, route.canActivate);
            if (route.forwardTo)
                router.forward(route.name, route.forwardTo);
            if (route.decodeParams)
                router.config.decoders[route.name] = route.decodeParams;
            if (route.encodeParams)
                router.config.encoders[route.name] = route.encodeParams;
            if (route.defaultParams)
                router.config.defaultParams[route.name] = route.defaultParams;
        }
        router.rootNode = rootNode;
        router.add = function (routes, finalSort) {
            rootNode.add(routes, onRouteAdded, !finalSort);
            if (finalSort) {
                rootNode.sortDescendants();
            }
            return router;
        };
        router.addNode = function (name, path, canActivateHandler) {
            rootNode.addNode(name, path);
            if (canActivateHandler)
                router.canActivate(name, canActivateHandler);
            return router;
        };
        router.isActive = function (name, params, strictEquality, ignoreQueryParams) {
            if (params === void 0) { params = {}; }
            if (strictEquality === void 0) { strictEquality = false; }
            if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
            var activeState = router.getState();
            if (!activeState)
                return false;
            if (strictEquality || activeState.name === name) {
                return router.areStatesEqual(router.makeState(name, params), activeState, ignoreQueryParams);
            }
            return router.areStatesDescendants(router.makeState(name, params), activeState);
        };
        router.buildPath = function (route, params) {
            if (route === constants.UNKNOWN_ROUTE) {
                return params.path;
            }
            var paramsWithDefault = __assign$1(__assign$1({}, router.config.defaultParams[route]), params);
            var _a = router.getOptions(), trailingSlashMode = _a.trailingSlashMode, queryParamsMode = _a.queryParamsMode, queryParams = _a.queryParams;
            var encodedParams = router.config.encoders[route]
                ? router.config.encoders[route](paramsWithDefault)
                : paramsWithDefault;
            return router.rootNode.buildPath(route, encodedParams, {
                trailingSlashMode: trailingSlashMode,
                queryParamsMode: queryParamsMode,
                queryParams: queryParams,
                urlParamsEncoding: router.getOptions().urlParamsEncoding
            });
        };
        router.matchPath = function (path, source) {
            var options = router.getOptions();
            var match = router.rootNode.matchPath(path, options);
            if (match) {
                var name_1 = match.name, params = match.params, meta = match.meta;
                var decodedParams = router.config.decoders[name_1]
                    ? router.config.decoders[name_1](params)
                    : params;
                var _a = router.forwardState(name_1, decodedParams), routeName = _a.name, routeParams = _a.params;
                var builtPath = options.rewritePathOnMatch === false
                    ? path
                    : router.buildPath(routeName, routeParams);
                return router.makeState(routeName, routeParams, builtPath, {
                    params: meta,
                    source: source
                });
            }
            return null;
        };
        router.setRootPath = function (rootPath) {
            router.rootNode.setPath(rootPath);
        };
        return router;
    };
}

function withDependencies(dependencies) {
    return function (router) {
        var routerDependencies = dependencies;
        router.setDependency = function (dependencyName, dependency) {
            routerDependencies[dependencyName] = dependency;
            return router;
        };
        router.setDependencies = function (deps) {
            Object.keys(deps).forEach(function (name) {
                return router.setDependency(name, deps[name]);
            });
            return router;
        };
        router.getDependencies = function () { return routerDependencies; };
        router.getInjectables = function () { return [router, router.getDependencies()]; };
        router.executeFactory = function (factoryFunction) {
            return factoryFunction.apply(void 0, router.getInjectables());
        };
        return router;
    };
}

function withState(router) {
    var stateId = 0;
    var routerState = null;
    router.getState = function () { return routerState; };
    router.setState = function (state) {
        routerState = state;
    };
    router.makeState = function (name, params, path, meta, forceId) { return ({
        name: name,
        params: __assign$1(__assign$1({}, router.config.defaultParams[name]), params),
        path: path,
        meta: meta
            ? __assign$1(__assign$1({}, meta), { id: forceId === undefined ? ++stateId : forceId }) : undefined
    }); };
    router.makeNotFoundState = function (path, options) {
        return router.makeState(constants.UNKNOWN_ROUTE, { path: path }, path, {
            options: options
        });
    };
    router.areStatesEqual = function (state1, state2, ignoreQueryParams) {
        if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
        if (state1.name !== state2.name)
            return false;
        var getUrlParams = function (name) {
            return router.rootNode
                //@ts-ignore
                .getSegmentsByName(name)
                .map(function (segment) { return segment.parser['urlParams']; })
                .reduce(function (params, p) { return params.concat(p); }, []);
        };
        var state1Params = ignoreQueryParams
            ? getUrlParams(state1.name)
            : Object.keys(state1.params);
        var state2Params = ignoreQueryParams
            ? getUrlParams(state2.name)
            : Object.keys(state2.params);
        return (state1Params.length === state2Params.length &&
            state1Params.every(function (p) { return state1.params[p] === state2.params[p]; }));
    };
    router.areStatesDescendants = function (parentState, childState) {
        var regex = new RegExp('^' + parentState.name + '\\.(.*)$');
        if (!regex.test(childState.name))
            return false;
        // If child state name extends parent state name, and all parent state params
        // are in child state params.
        return Object.keys(parentState.params).every(function (p) { return parentState.params[p] === childState.params[p]; });
    };
    router.forwardState = function (routeName, routeParams) {
        var name = router.config.forwardMap[routeName] || routeName;
        var params = __assign$1(__assign$1(__assign$1({}, router.config.defaultParams[routeName]), router.config.defaultParams[name]), routeParams);
        return {
            name: name,
            params: params
        };
    };
    router.buildState = function (routeName, routeParams) {
        var _a = router.forwardState(routeName, routeParams), name = _a.name, params = _a.params;
        return router.rootNode.buildState(name, params);
    };
    return router;
}

var eventsMap = {
    onStart: constants.ROUTER_START,
    onStop: constants.ROUTER_STOP,
    onTransitionSuccess: constants.TRANSITION_SUCCESS,
    onTransitionStart: constants.TRANSITION_START,
    onTransitionError: constants.TRANSITION_ERROR,
    onTransitionCancel: constants.TRANSITION_CANCEL
};
function withPlugins(router) {
    var routerPlugins = [];
    router.getPlugins = function () { return routerPlugins; };
    router.usePlugin = function () {
        var plugins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            plugins[_i] = arguments[_i];
        }
        var removePluginFns = plugins.map(function (plugin) {
            routerPlugins.push(plugin);
            return startPlugin(plugin);
        });
        return function () {
            routerPlugins = routerPlugins.filter(function (plugin) { return plugins.indexOf(plugin) === -1; });
            removePluginFns.forEach(function (removePlugin) { return removePlugin(); });
        };
    };
    function startPlugin(plugin) {
        var appliedPlugin = router.executeFactory(plugin);
        var removeEventListeners = Object.keys(eventsMap)
            .map(function (methodName) {
            if (appliedPlugin[methodName]) {
                return router.addEventListener(eventsMap[methodName], appliedPlugin[methodName]);
            }
        })
            .filter(Boolean);
        return function () {
            removeEventListeners.forEach(function (removeListener) { return removeListener(); });
            if (appliedPlugin.teardown) {
                appliedPlugin.teardown();
            }
        };
    }
    return router;
}

function withMiddleware(router) {
    var middlewareFactories = [];
    var middlewareFunctions = [];
    router.useMiddleware = function () {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        var removePluginFns = middlewares.map(function (middleware) {
            var middlewareFunction = router.executeFactory(middleware);
            middlewareFactories.push(middleware);
            middlewareFunctions.push(middlewareFunction);
            return function () {
                middlewareFactories = middlewareFactories.filter(function (m) { return m !== middleware; });
                middlewareFunctions = middlewareFunctions.filter(function (m) { return m !== middlewareFunction; });
            };
        });
        return function () { return removePluginFns.forEach(function (fn) { return fn(); }); };
    };
    router.clearMiddleware = function () {
        middlewareFactories = [];
        middlewareFunctions = [];
        return router;
    };
    router.getMiddlewareFactories = function () { return middlewareFactories; };
    router.getMiddlewareFunctions = function () { return middlewareFunctions; };
    return router;
}

function withObservability(router) {
    var callbacks = {};
    router.invokeEventListeners = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (callbacks[eventName] || []).forEach(function (cb) { return cb.apply(void 0, args); });
    };
    router.removeEventListener = function (eventName, cb) {
        callbacks[eventName] = callbacks[eventName].filter(function (_cb) { return _cb !== cb; });
    };
    router.addEventListener = function (eventName, cb) {
        callbacks[eventName] = (callbacks[eventName] || []).concat(cb);
        return function () { return router.removeEventListener(eventName, cb); };
    };
    function subscribe(listener) {
        var isObject = typeof listener === 'object';
        var finalListener = isObject ? listener.next.bind(listener) : listener;
        var unsubscribeHandler = router.addEventListener(constants.TRANSITION_SUCCESS, function (toState, fromState) {
            finalListener({
                route: toState,
                previousRoute: fromState
            });
        });
        return isObject
            ? { unsubscribe: unsubscribeHandler }
            : unsubscribeHandler;
    }
    function observable() {
        var _a;
        return _a = {
                subscribe: function (observer) {
                    if (typeof observer !== 'object' || observer === null) {
                        throw new TypeError('Expected the observer to be an object.');
                    }
                    return subscribe(observer);
                }
            },
            _a[result] = function () {
                return this;
            },
            _a;
    }
    router.subscribe = subscribe;
    //@ts-ignore
    router[result] = observable;
    //@ts-ignore
    router['@@observable'] = observable;
    return router;
}

function resolve(functions, _a, callback) {
    var isCancelled = _a.isCancelled, toState = _a.toState, fromState = _a.fromState, _b = _a.errorKey, errorKey = _b === void 0 ? undefined : _b;
    var remainingFunctions = Array.isArray(functions)
        ? functions
        : Object.keys(functions);
    var isState = function (obj) {
        return typeof obj === 'object' &&
            obj.name !== undefined &&
            obj.params !== undefined &&
            obj.path !== undefined;
    };
    var hasStateChanged = function (toState, fromState) {
        return fromState.name !== toState.name ||
            fromState.params !== toState.params ||
            fromState.path !== toState.path;
    };
    var mergeStates = function (toState, fromState) { return (__assign$1(__assign$1(__assign$1({}, fromState), toState), { meta: __assign$1(__assign$1({}, fromState.meta), toState.meta) })); };
    var processFn = function (stepFn, errBase, state, _done) {
        var done = function (err, newState) {
            if (err) {
                _done(err);
            }
            else if (newState && newState !== state && isState(newState)) {
                if (hasStateChanged(newState, state)) {
                    console.error('[router5][transition] Warning: state values (name, params, path) were changed during transition process.');
                }
                _done(null, mergeStates(newState, state));
            }
            else {
                _done(null, state);
            }
        };
        var res = stepFn.call(null, state, fromState, done);
        if (isCancelled()) {
            done(null);
        }
        else if (typeof res === 'boolean') {
            done(res ? null : errBase);
        }
        else if (isState(res)) {
            done(null, res);
        }
        else if (res && typeof res.then === 'function') {
            res.then(function (resVal) {
                if (resVal instanceof Error)
                    done({ error: resVal }, null);
                else
                    done(null, resVal);
            }, function (err) {
                if (err instanceof Error) {
                    console.error(err.stack || err);
                    done(__assign$1(__assign$1({}, errBase), { promiseError: err }), null);
                }
                else {
                    done(typeof err === 'object'
                        ? __assign$1(__assign$1({}, errBase), err) : errBase, null);
                }
            });
        }
        // else: wait for done to be called
    };
    var next = function (err, state) {
        var _a;
        if (isCancelled()) {
            callback();
        }
        else if (err) {
            callback(err);
        }
        else {
            if (!remainingFunctions.length) {
                callback(null, state);
            }
            else {
                var isMapped = typeof remainingFunctions[0] === 'string';
                var errBase = errorKey && isMapped
                    ? (_a = {}, _a[errorKey] = remainingFunctions[0], _a) : {};
                var stepFn = isMapped
                    ? functions[remainingFunctions[0]]
                    : remainingFunctions[0];
                remainingFunctions = remainingFunctions.slice(1);
                processFn(stepFn, errBase, state, next);
            }
        }
    };
    next(null, toState);
}

function transition(router, toState, fromState, opts, callback) {
    var cancelled = false;
    var completed = false;
    var options = router.getOptions();
    var _a = router.getLifecycleFunctions(), canDeactivateFunctions = _a[0], canActivateFunctions = _a[1];
    var middlewareFunctions = router.getMiddlewareFunctions();
    var isCancelled = function () { return cancelled; };
    var cancel = function () {
        if (!cancelled && !completed) {
            cancelled = true;
            callback({ code: errorCodes.TRANSITION_CANCELLED }, null);
        }
    };
    var done = function (err, state) {
        completed = true;
        if (isCancelled()) {
            return;
        }
        if (!err && options.autoCleanUp) {
            var activeSegments_1 = nameToIDs(toState.name);
            Object.keys(canDeactivateFunctions).forEach(function (name) {
                if (activeSegments_1.indexOf(name) === -1)
                    router.clearCanDeactivate(name);
            });
        }
        callback(err, state || toState);
    };
    var makeError = function (base, err) { return (__assign$1(__assign$1({}, base), (err instanceof Object ? err : { error: err }))); };
    var isUnknownRoute = toState.name === constants.UNKNOWN_ROUTE;
    var asyncBase = { isCancelled: isCancelled, toState: toState, fromState: fromState };
    var _b = transitionPath(toState, fromState), toDeactivate = _b.toDeactivate, toActivate = _b.toActivate;
    var canDeactivate = !fromState || opts.forceDeactivate
        ? []
        : function (toState, fromState, cb) {
            var canDeactivateFunctionMap = toDeactivate
                .filter(function (name) { return canDeactivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign$1(__assign$1({}, fnMap), (_a = {}, _a[name] = canDeactivateFunctions[name], _a)));
            }, {});
            resolve(canDeactivateFunctionMap, __assign$1(__assign$1({}, asyncBase), { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_DEACTIVATE }, err)
                    : null);
            });
        };
    var canActivate = isUnknownRoute
        ? []
        : function (toState, fromState, cb) {
            var canActivateFunctionMap = toActivate
                .filter(function (name) { return canActivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign$1(__assign$1({}, fnMap), (_a = {}, _a[name] = canActivateFunctions[name], _a)));
            }, {});
            resolve(canActivateFunctionMap, __assign$1(__assign$1({}, asyncBase), { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_ACTIVATE }, err)
                    : null);
            });
        };
    var middleware = !middlewareFunctions.length
        ? []
        : function (toState, fromState, cb) {
            return resolve(middlewareFunctions, __assign$1({}, asyncBase), function (err, state) {
                return cb(err
                    ? makeError({ code: errorCodes.TRANSITION_ERR }, err)
                    : null, state || toState);
            });
        };
    var pipeline = []
        .concat(canDeactivate)
        .concat(canActivate)
        .concat(middleware);
    resolve(pipeline, asyncBase, done);
    return cancel;
}

var noop$1 = function () { };
function withNavigation(router) {
    var cancelCurrentTransition;
    router.navigate = navigate;
    router.navigate = navigate;
    router.navigateToDefault = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var opts = typeof args[0] === 'object' ? args[0] : {};
        var done = args.length === 2
            ? args[1]
            : typeof args[0] === 'function'
                ? args[0]
                : noop$1;
        var options = router.getOptions();
        if (options.defaultRoute) {
            return navigate(options.defaultRoute, options.defaultParams, opts, done);
        }
        return function () { };
    };
    router.cancel = function () {
        if (cancelCurrentTransition) {
            cancelCurrentTransition('navigate');
            cancelCurrentTransition = null;
        }
        return router;
    };
    function navigate() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var name = args[0];
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop$1;
        var params = typeof args[1] === 'object' ? args[1] : {};
        var opts = typeof args[2] === 'object' ? args[2] : {};
        if (!router.isStarted()) {
            done({ code: errorCodes.ROUTER_NOT_STARTED });
            return;
        }
        var route = router.buildState(name, params);
        if (!route) {
            var err = { code: errorCodes.ROUTE_NOT_FOUND };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, null, router.getState(), err);
            return;
        }
        var toState = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta, options: opts });
        var sameStates = router.getState()
            ? router.areStatesEqual(router.getState(), toState, false)
            : false;
        // Do not proceed further if states are the same and no reload
        // (no deactivation and no callbacks)
        if (sameStates && !opts.reload && !opts.force) {
            var err = { code: errorCodes.SAME_STATES };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, toState, router.getState(), err);
            return;
        }
        var fromState = router.getState();
        if (opts.skipTransition) {
            done(null, toState);
            return noop$1;
        }
        // Transition
        return router.transitionToState(toState, fromState, opts, function (err, state) {
            if (err) {
                if (err.redirect) {
                    var _a = err.redirect, name_1 = _a.name, params_1 = _a.params;
                    navigate(name_1, params_1, __assign$1(__assign$1({}, opts), { force: true, redirected: true }), done);
                }
                else {
                    done(err);
                }
            }
            else {
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, fromState, opts);
                done(null, state);
            }
        });
    }
    router.transitionToState = function (toState, fromState, options, done) {
        if (options === void 0) { options = {}; }
        if (done === void 0) { done = noop$1; }
        router.cancel();
        router.invokeEventListeners(constants.TRANSITION_START, toState, fromState);
        cancelCurrentTransition = transition(router, toState, fromState, options, function (err, state) {
            cancelCurrentTransition = null;
            state = state || toState;
            if (err) {
                if (err.code === errorCodes.TRANSITION_CANCELLED) {
                    router.invokeEventListeners(constants.TRANSITION_CANCEL, toState, fromState);
                }
                else {
                    router.invokeEventListeners(constants.TRANSITION_ERROR, toState, fromState, err);
                }
                done(err);
            }
            else {
                router.setState(state);
                done(null, state);
            }
        });
        return cancelCurrentTransition;
    };
    return router;
}

var noop$1$1 = function () { };
function withRouterLifecycle(router) {
    var started = false;
    router.isStarted = function () { return started; };
    //@ts-ignore
    router.start = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var options = router.getOptions();
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop$1$1;
        var startPathOrState = typeof args[0] !== 'function' ? args[0] : undefined;
        if (started) {
            done({ code: errorCodes.ROUTER_ALREADY_STARTED });
            return router;
        }
        var startPath, startState;
        started = true;
        router.invokeEventListeners(constants.ROUTER_START);
        // callback
        var cb = function (err, state, invokeErrCb) {
            if (invokeErrCb === void 0) { invokeErrCb = true; }
            if (!err)
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, null, { replace: true });
            if (err && invokeErrCb)
                router.invokeEventListeners(constants.TRANSITION_ERROR, state, null, err);
            done(err, state);
        };
        if (startPathOrState === undefined && !options.defaultRoute) {
            return cb({ code: errorCodes.NO_START_PATH_OR_STATE });
        }
        if (typeof startPathOrState === 'string') {
            startPath = startPathOrState;
        }
        else if (typeof startPathOrState === 'object') {
            startState = startPathOrState;
        }
        if (!startState) {
            // If no supplied start state, get start state
            startState =
                startPath === undefined ? null : router.matchPath(startPath);
            // Navigate to default function
            var navigateToDefault_1 = function () {
                return router.navigateToDefault({ replace: true }, done);
            };
            var redirect_1 = function (route) {
                return router.navigate(route.name, route.params, { replace: true, reload: true, redirected: true }, done);
            };
            var transitionToState = function (state) {
                router.transitionToState(state, router.getState(), {}, function (err, state) {
                    if (!err)
                        cb(null, state);
                    else if (err.redirect)
                        redirect_1(err.redirect);
                    else if (options.defaultRoute)
                        navigateToDefault_1();
                    else
                        cb(err, null, false);
                });
            };
            // If matched start path
            if (startState) {
                transitionToState(startState);
            }
            else if (options.defaultRoute) {
                // If default, navigate to default
                navigateToDefault_1();
            }
            else if (options.allowNotFound) {
                transitionToState(router.makeNotFoundState(startPath, { replace: true }));
            }
            else {
                // No start match, no default => do nothing
                cb({ code: errorCodes.ROUTE_NOT_FOUND, path: startPath }, null);
            }
        }
        else {
            // Initialise router with provided start state
            router.setState(startState);
            cb(null, startState);
        }
        return router;
    };
    router.stop = function () {
        if (started) {
            router.setState(null);
            started = false;
            router.invokeEventListeners(constants.ROUTER_STOP);
        }
        return router;
    };
    return router;
}

var toFunction = function (val) { return (typeof val === 'function' ? val : function () { return function () { return val; }; }); };
function withRouteLifecycle(router) {
    var canDeactivateFactories = {};
    var canActivateFactories = {};
    var canDeactivateFunctions = {};
    var canActivateFunctions = {};
    router.getLifecycleFactories = function () {
        return [canDeactivateFactories, canActivateFactories];
    };
    router.getLifecycleFunctions = function () {
        return [canDeactivateFunctions, canActivateFunctions];
    };
    router.canDeactivate = function (name, canDeactivateHandler) {
        var factory = toFunction(canDeactivateHandler);
        canDeactivateFactories[name] = factory;
        canDeactivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    router.clearCanDeactivate = function (name) {
        canDeactivateFactories[name] = undefined;
        canDeactivateFunctions[name] = undefined;
        return router;
    };
    router.canActivate = function (name, canActivateHandler) {
        var factory = toFunction(canActivateHandler);
        canActivateFactories[name] = factory;
        canActivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    return router;
}

var pipe = function () {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (arg) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, arg);
    };
};
var createRouter = function (routes, options, dependencies) {
    if (routes === void 0) { routes = []; }
    if (options === void 0) { options = {}; }
    if (dependencies === void 0) { dependencies = {}; }
    var config = {
        decoders: {},
        encoders: {},
        defaultParams: {},
        forwardMap: {}
    };
    return pipe(withOptions(options), withDependencies(dependencies), withObservability, withState, withRouterLifecycle, withRouteLifecycle, withNavigation, withPlugins, withMiddleware, withRoutes(routes))({ config: config });
};

var createRouter$1 = createRouter;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var value = function (arg) { return function () { return arg; }; };
var noop = function () { };
var isBrowser = typeof window !== 'undefined' && window.history;
var getBase = function () { return window.location.pathname; };
var supportsPopStateOnHashChange = function () {
    return window.navigator.userAgent.indexOf('Trident') === -1;
};
var pushState = function (state, title, path) {
    return window.history.pushState(state, title, path);
};
var replaceState = function (state, title, path) {
    return window.history.replaceState(state, title, path);
};
var addPopstateListener = function (fn, opts) {
    var shouldAddHashChangeListener = opts.useHash && !supportsPopStateOnHashChange();
    window.addEventListener('popstate', fn);
    if (shouldAddHashChangeListener) {
        window.addEventListener('hashchange', fn);
    }
    return function () {
        window.removeEventListener('popstate', fn);
        if (shouldAddHashChangeListener) {
            window.removeEventListener('hashchange', fn);
        }
    };
};
var getLocation = function (opts) {
    var path = opts.useHash
        ? window.location.hash.replace(new RegExp('^#' + opts.hashPrefix), '')
        : window.location.pathname.replace(new RegExp('^' + opts.base), '');
    // Fix issue with browsers that don't URL encode characters (Edge)
    var correctedPath = safelyEncodePath(path);
    return (correctedPath || '/') + window.location.search;
};
var safelyEncodePath = function (path) {
    try {
        return encodeURI(decodeURI(path));
    }
    catch (_) {
        return path;
    }
};
var getState = function () { return window.history.state; };
var getHash = function () { return window.location.hash; };
var browser = {};
if (isBrowser) {
    browser = {
        getBase: getBase,
        pushState: pushState,
        replaceState: replaceState,
        addPopstateListener: addPopstateListener,
        getLocation: getLocation,
        getState: getState,
        getHash: getHash
    };
}
else {
    browser = {
        getBase: value(''),
        pushState: noop,
        replaceState: noop,
        addPopstateListener: noop,
        getLocation: value(''),
        getState: value(null),
        getHash: value('')
    };
}
var safeBrowser = browser;

var defaultOptions = {
    forceDeactivate: true,
    useHash: false,
    hashPrefix: '',
    base: '',
    mergeState: false,
    preserveHash: true
};
var source = 'popstate';
function browserPluginFactory(opts, browser) {
    if (browser === void 0) { browser = safeBrowser; }
    var options = __assign(__assign({}, defaultOptions), opts);
    var transitionOptions = {
        forceDeactivate: options.forceDeactivate,
        source: source
    };
    var removePopStateListener;
    return function browserPlugin(router) {
        var routerOptions = router.getOptions();
        var routerStart = router.start;
        router.buildUrl = function (route, params) {
            var base = options.base || '';
            var prefix = options.useHash ? "#" + options.hashPrefix : '';
            var path = router.buildPath(route, params);
            return base + prefix + path;
        };
        var urlToPath = function (url) {
            var match = url.match(/^(?:http|https):\/\/(?:[0-9a-z_\-.:]+?)(?=\/)(.*)$/);
            var path = match ? match[1] : url;
            var pathParts = path.match(/^(.+?)(#.+?)?(\?.+)?$/);
            if (!pathParts)
                throw new Error("[router5] Could not parse url " + url);
            var pathname = pathParts[1];
            var hash = pathParts[2] || '';
            var search = pathParts[3] || '';
            return ((options.useHash
                ? hash.replace(new RegExp('^#' + options.hashPrefix), '')
                : options.base
                    ? pathname.replace(new RegExp('^' + options.base), '')
                    : pathname) + search);
        };
        router.matchUrl = function (url) { return router.matchPath(urlToPath(url)); };
        router.start = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 0 || typeof args[0] === 'function') {
                routerStart.apply(void 0, __spreadArrays([browser.getLocation(options)], args));
            }
            else {
                routerStart.apply(void 0, args);
            }
            return router;
        };
        router.replaceHistoryState = function (name, params, title) {
            if (params === void 0) { params = {}; }
            if (title === void 0) { title = ''; }
            var route = router.buildState(name, params);
            var state = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta });
            var url = router.buildUrl(name, params);
            router.lastKnownState = state;
            browser.replaceState(state, title, url);
        };
        function updateBrowserState(state, url, replace) {
            var trimmedState = state
                ? {
                    meta: state.meta,
                    name: state.name,
                    params: state.params,
                    path: state.path
                }
                : state;
            var finalState = options.mergeState === true
                ? __assign(__assign({}, browser.getState()), trimmedState) : trimmedState;
            if (replace)
                browser.replaceState(finalState, '', url);
            else
                browser.pushState(finalState, '', url);
        }
        function onPopState(evt) {
            var routerState = router.getState();
            // Do nothing if no state or if last know state is poped state (it should never happen)
            var newState = !evt.state || !evt.state.name;
            var state = newState
                ? router.matchPath(browser.getLocation(options), source)
                : router.makeState(evt.state.name, evt.state.params, evt.state.path, __assign(__assign({}, evt.state.meta), { source: source }), evt.state.meta.id);
            var defaultRoute = routerOptions.defaultRoute, defaultParams = routerOptions.defaultParams;
            if (!state) {
                // If current state is already the default route, we will have a double entry
                // Navigating back and forth will emit SAME_STATES error
                defaultRoute &&
                    router.navigateToDefault(__assign(__assign({}, transitionOptions), { reload: true, replace: true }));
                return;
            }
            if (routerState &&
                router.areStatesEqual(state, routerState, false)) {
                return;
            }
            router.transitionToState(state, routerState, transitionOptions, function (err, toState) {
                if (err) {
                    if (err.redirect) {
                        var _a = err.redirect, name_1 = _a.name, params = _a.params;
                        router.navigate(name_1, params, __assign(__assign({}, transitionOptions), { replace: true, force: true, redirected: true }));
                    }
                    else if (err.code === errorCodes.CANNOT_DEACTIVATE) {
                        var url = router.buildUrl(routerState.name, routerState.params);
                        if (!newState) {
                            // Keep history state unchanged but use current URL
                            updateBrowserState(state, url, true);
                        }
                        // else do nothing or history will be messed up
                        // TODO: history.back()?
                    }
                    else {
                        // Force navigation to default state
                        defaultRoute &&
                            router.navigate(defaultRoute, defaultParams, __assign(__assign({}, transitionOptions), { reload: true, replace: true }));
                    }
                }
                else {
                    router.invokeEventListeners(constants.TRANSITION_SUCCESS, toState, routerState, { replace: true });
                }
            });
        }
        function onStart() {
            if (options.useHash && !options.base) {
                // Guess base
                options.base = browser.getBase();
            }
            removePopStateListener = browser.addPopstateListener(onPopState, options);
        }
        function teardown() {
            if (removePopStateListener) {
                removePopStateListener();
                removePopStateListener = undefined;
            }
        }
        function onTransitionSuccess(toState, fromState, opts) {
            var historyState = browser.getState();
            var hasState = historyState &&
                historyState.meta &&
                historyState.name &&
                historyState.params;
            var statesAreEqual = fromState && router.areStatesEqual(fromState, toState, false);
            var replace = opts.replace || !hasState || statesAreEqual;
            var url = router.buildUrl(toState.name, toState.params);
            if (fromState === null &&
                options.useHash === false &&
                options.preserveHash === true) {
                url += browser.getHash();
            }
            updateBrowserState(toState, url, replace);
        }
        return {
            onStart: onStart,
            onStop: teardown,
            teardown: teardown,
            onTransitionSuccess: onTransitionSuccess,
            onPopState: onPopState
        };
    };
}class RouterService {
  static get router() {
    return this.router_;
  }

  static get route() {
    let route = null;
    const router = this.router_;

    if (router) {
      route = router.getState(); // console.log('RouterService.get.route', route);
    }

    return route;
  }
  /*
  static event$_ = new Subject();
  static event$() {
  	const router = this.router_;
  	if (router) {
  		return from(router).pipe(
  			startWith({ route: router.getState(), previousRoute: null }),
  			tap(event => {
  				// console.log('RouterService.event$', event);
  				this.event$_.next(event);
  			}),
  		);
  	} else {
  		return EMPTY;
  	}
  }
  */


  static useBrowser(routes) {
    if (!(Array.isArray(routes) && routes.length)) {
      this.event$ = rxjs.EMPTY;
      return;
    }

    this.routes = routes;
    const router = createRouter$1(routes, {
      allowNotFound: false,
      autoCleanUp: true,
      defaultRoute: 'index',
      defaultParams: {},
      queryParams: {
        arrayFormat: 'default',
        nullFormat: 'default',
        booleanFormat: 'default'
      },
      queryParamsMode: 'default',
      trailingSlashMode: 'default',
      strictTrailingSlash: false,
      caseSensitive: false,
      urlParamsEncoding: 'default'
    });
    this.router_ = router;
    router.usePlugin(browserPluginFactory({
      useHash: false
    }));
    router.start();
    this.event$ = rxjs.from(router).pipe(operators.startWith({
      route: router.getState(),
      previousRoute: null
    }) // tap(event => { console.log('RouterService.event$', event); }),
    );
  }

  static useBrowser$(routes) {
    this.useBrowser(routes);
    return this.event$;
  }

  static setRouterLink(routerLink, routeParams, options) {
    if (routerLink === void 0) {
      routerLink = 'it.access';
    }

    if (routeParams === void 0) {
      routeParams = null;
    }

    if (options === void 0) {
      options = {
        reload: true
      };
    }

    const router = this.router_;

    if (router) {
      // router.matchUrl(routerLink);
      try {
        router.navigate(routerLink, routeParams, options);
      } catch (error) {
        console.log('RouterService.setRouterLink.error', error);
      }
    } // console.log('RouterService.setRouterLink', router, routerLink, routeParams, options);

  }

  static replaceHistoryState(name, params) {
    const router = this.router_;

    if (router) {
      // router.matchUrl(routerLink);
      try {
        router.replaceHistoryState(name, params);
      } catch (error) {
        console.log('RouterService.replaceHistoryState.error', error);
      }
    }
  }

  static setCurrentParams(params) {
    const router = this.router_;

    if (router) {
      try {
        const route = this.route;

        if (route) {
          router.replaceHistoryState(route.name, params);
        }
      } catch (error) {
        console.log('RouterService.setCurrentParams.error', error);
      }
    }
  }

  static buildPath(route, params) {
    if (params === void 0) {
      params = null;
    }

    let path = null;
    const router = this.router_;

    if (router) {
      try {
        path = router.buildPath(route, params);
      } catch (error) {
        console.log('RouterService.buildPath.error', error);
      }
    } // console.log('RouterService.buildPath', path, route, params);
    // router.buildUrl(routeName, routeParams)


    return path;
  }

  static buildUrl(routeName, routeParams) {
    if (routeParams === void 0) {
      routeParams = null;
    }

    let url = null;
    const router = this.router_;

    if (router) {
      try {
        url = router.buildUrl(routeName, routeParams);
      } catch (error) {
        console.log('RouterService.buildUrl.error', error);
      }
    } // console.log('RouterService.buildUrl', url, routeName, routeParams);


    return url;
  }

  static isActive(name, params, strictEquality, ignoreQueryParams) {
    if (strictEquality === void 0) {
      strictEquality = false;
    }

    if (ignoreQueryParams === void 0) {
      ignoreQueryParams = true;
    }

    let active = false;
    const router = this.router_;

    if (router) {
      try {
        active = router.isActive(name, params, strictEquality, ignoreQueryParams);
      } catch (error) {
        console.log('RouterService.isActive.error', error);
      }
    } // console.log('RouterService.isActive', active, name, params, strictEquality, ignoreQueryParams);


    return active;
  }

}
RouterService.routes = [];
RouterService.router_ = null;class StateService {
  static set state(state) {
    this.state$.next(state);
  }

  static get state() {
    return this.state$.getValue();
  }

  static patchState(state) {
    state = Object.assign({}, this.state, state);
    this.state = state;
  }

}
StateService.state$ = new rxjs.BehaviorSubject({});const RoleType = {
  Publisher: 'publisher',
  Attendee: 'attendee',
  Streamer: 'streamer',
  Viewer: 'viewer',
  SmartDevice: 'smart-device',
  SelfService: 'self-service',
  Embed: 'embed'
};
class User {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }

}const MEETING_ID_VALIDATOR = /^\d{9}-\d{4}-\d{13}(-\d+)?$/;
class MeetingId {
  get roleIndex() {
    return MeetingId.getRoleIndex(this.role);
  }

  set roleIndex(roleIndex) {
    const roleIndex_ = MeetingId.getRoleIndex(this.role);

    if (roleIndex_ !== roleIndex) {
      const key = Object.keys(RoleType)[roleIndex];
      this.role = RoleType[key];
    }
  }

  constructor(options) {
    this.userId = StateService.state.user ? StateService.state.user.id : 0;
    this.role = StateService.state.role || RoleType.Viewer;
    this.timestamp = new Date().valueOf().toString();
    this.pathId = null; // this.timestamp = (performance.now() * 10000000000000).toString();

    if (typeof options === 'string') {
      if (options.match(MEETING_ID_VALIDATOR)) {
        options = MeetingId.decompose(options);
      } else {
        console.warn('MeetingId', 'invalid meetingId', options);
        return null;
      }
    }

    if (typeof options === 'object') {
      if (options.id) {
        this.id = options.id;
      }

      if (options.userId) {
        this.userId = options.userId;
      }

      if (options.role) {
        this.role = options.role;
      }

      if (options.roleIndex) {
        this.roleIndex = options.roleIndex;
      }

      if (options.timestamp) {
        this.timestamp = options.timestamp;
      }

      if (options.pathId) {
        this.pathId = options.pathId;
      }
    } // console.log('MeetingId', this);

  }

  toString() {
    return MeetingId.compose(this.userId, this.roleIndex, this.timestamp, this.pathId);
  }

  toRoles() {
    const userId = this.userId;
    const timestamp = this.timestamp;
    const pathId = this.pathId;
    return {
      id: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Publisher), timestamp, pathId),
      idAttendee: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Attendee), timestamp, pathId),
      idStreamer: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Streamer), timestamp, pathId),
      idViewer: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Viewer), timestamp, pathId),
      idSmartDevice: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.SmartDevice), timestamp, pathId),
      idSelfService: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.SelfService), timestamp, pathId)
    };
  }

  static compose(userId, roleIndex, timestamp, pathId) {
    return `${MeetingId.padded(userId, 9)}-${MeetingId.padded(roleIndex, 4)}-${timestamp}${pathId ? `-${pathId}` : ''}`;
  }

  static decompose(meetingId) {
    const components = meetingId.split('-');
    return {
      userId: parseInt(components[0]),
      roleIndex: parseInt(components[1]),
      timestamp: parseInt(components[2]),
      pathId: components[3] ? parseInt(components[3]) : null
    };
  }

  static generateMeetingId() {
    const meetingId = new MeetingId();
    return meetingId.toRoles();
  }

  static getRoleIndex(role) {
    return Object.keys(RoleType).reduce((p, c, i) => {
      return RoleType[c] === role ? i : p;
    }, -1);
  }

  static padded(num, size) {
    const s = '000000000' + num;
    return s.substr(s.length - size);
  }

}class MeetingUrl {
  get meetingId() {
    return this.link ? new MeetingId(this.link) : null;
  }

  constructor(options) {
    /*
    this.link = LocationService.get('link') || null;
    this.name = LocationService.get('name') || null;
    this.firstName = LocationService.get('firstName') || null;
    this.lastName = LocationService.get('lastName') || null;
    this.email = LocationService.get('email') || null;
    this.role = LocationService.get('role') || null;
    this.viewId = LocationService.has('viewId') ? parseInt(LocationService.get('viewId')) : null;
    this.pathId = LocationService.has('pathId') ? parseInt(LocationService.get('pathId')) : null;
    this.embedViewId = LocationService.has('embedViewId') ? parseInt(LocationService.get('embedViewId')) : null;
    this.support = LocationService.has('support') ? (LocationService.get('support') === 'true') : false;
    */
    options = options || window.location.href;

    if (typeof options === 'string') {
      options = MeetingUrl.decompose(options);
    }

    if (typeof options === 'object') {
      Object.assign(this, options);

      if (options.user) {
        const name = MeetingUrl.getName(options.user);

        if (name) {
          this.name = name;
        }

        if (environment.flags.useExtendedUserInfo) {
          const firstName = MeetingUrl.getFirstName(options.user);

          if (firstName) {
            this.firstName = firstName;
          }

          const lastName = MeetingUrl.getLastName(options.user);

          if (lastName) {
            this.lastName = lastName;
          }

          const email = MeetingUrl.getEmail(options.user);

          if (email) {
            this.email = email;
          }
        }
      }

      if (options.name) {
        this.name = options.name;
      }

      if (environment.flags.useExtendedUserInfo) {
        if (options.firstName) {
          this.firstName = options.firstName;
        }

        if (options.lastName) {
          this.lastName = options.lastName;
        }

        if (options.email) {
          this.email = options.email;
        }
      }
    }

    this.link = this.link || null;
    this.name = this.name || null;
    this.firstName = this.firstName || null;
    this.lastName = this.lastName || null;
    this.email = this.email || null;
    this.role = this.role || null;
    this.viewId = this.viewId || null;
    this.pathId = this.pathId || null;
    this.embedViewId = this.embedViewId || null;
    this.support = this.support || false; // console.log('MeetingUrl', this);
  }

  toParams(shareable) {
    if (shareable === void 0) {
      shareable = false;
    }

    let params = {};

    if (this.link) {
      params.link = this.link;
    }

    if (environment.flags.useExtendedUserInfo) {
      if (this.firstName) {
        params.firstName = this.firstName;
      }

      if (this.lastName) {
        params.lastName = this.lastName;
      }

      if (this.email) {
        params.email = this.email;
      }
    } else {
      if (this.name) {
        params.name = this.name;
      }
    }

    if (this.role && !shareable) {
      params.role = this.role;
    }

    if (this.viewId) {
      params.viewId = this.viewId;
    }

    if (this.pathId) {
      params.pathId = this.pathId;
    }

    if (this.support) {
      params.support = this.support;
    }

    if (environment.flags.useEncryptedUrl) {
      params = {
        p: MeetingUrl.encrypt(params)
      };
    }

    return params;
  }

  toString(shareable) {
    if (shareable === void 0) {
      shareable = false;
    }

    let components;

    if (environment.flags.useExtendedUserInfo) {
      components = {
        link: this.link,
        firstName: this.firstName,
        lastName: this.lastName,
        email: this.email,
        role: shareable ? null : this.role,
        viewId: this.viewId,
        pathId: this.pathId,
        support: this.support
      };
    } else {
      components = {
        link: this.link,
        name: this.name,
        role: shareable ? null : this.role,
        viewId: this.viewId,
        pathId: this.pathId,
        support: this.support
      };
    }

    return MeetingUrl.compose(components);
  }

  toUrl() {
    const params = this.toParams();
    return MeetingUrl.getCurrentUrl(params);
  }

  toAccessCodeUrl() {
    const params = this.toParams();
    return MeetingUrl.getAccessCodeUrl(params);
  }

  toGuidedTourUrl() {
    const params = this.toParams();
    return MeetingUrl.getGuidedTourUrl(params);
  }

  copyToClipBoard(asAccessCode) {
    if (asAccessCode === void 0) {
      asAccessCode = false;
    }

    const input = document.createElement('input');
    input.style.position = 'absolute';
    input.style.top = '1000vh'; // input.style.visibility = 'hidden';

    document.querySelector('body').appendChild(input);
    const params = this.toParams(true);
    input.value = window.location.origin + (asAccessCode ? MeetingUrl.getAccessCodeUrl(params) : MeetingUrl.getGuidedTourUrl(params));
    input.focus();
    input.select();
    input.setSelectionRange(0, 99999);
    document.execCommand('copy');
    input.parentNode.removeChild(input);
    alert(`link copiato!\n ${input.value}`);
  }

  replaceUrl() {
    RouterService.setCurrentParams(this.toParams());
  }

  static replaceWithOptions(options) {
    const currentOptions = MeetingUrl.decompose(window.location.href);
    const meetingUrl = new MeetingUrl(Object.assign(currentOptions, options));
    meetingUrl.replaceUrl();
    return meetingUrl;
  }

  static replaceWithUser(user) {
    return this.replaceWithOptions({
      user
    });
  }

  static replaceWithName(name) {
    return this.replaceWithOptions({
      name
    });
  }

  static replaceWithLink(link) {
    return this.replaceWithOptions({
      link
    });
  }

  static getCurrentUrl(params) {
    if (params === void 0) {
      params = null;
    }

    const route = RouterService.route;

    if (route) {
      const routeName = route.name; // console.log('MeetingUrl.getCurrentUrl', routeName);

      return RouterService.buildUrl(routeName, params);
    }
  }

  static getAccessCodeUrl(params) {
    if (params === void 0) {
      params = null;
    }

    const route = RouterService.route;

    if (route) {
      const routeName = `${route.params.lang}.accessCode`; // console.log('MeetingUrl.getAccessCodeUrl', routeName);

      return RouterService.buildUrl(routeName, params);
    }
  }

  static getGuidedTourUrl(params) {
    if (params === void 0) {
      params = null;
    }

    const route = RouterService.route;

    if (route) {
      const routeName = `${route.params.lang}.guidedTour`; // console.log('MeetingUrl.getGuidedTourUrl', routeName);

      return RouterService.buildUrl(routeName, params);
    }
  }

  static getName(user) {
    return user && user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : null;
  }

  static getFirstName(user) {
    return user && user.firstName ? user.firstName : null;
  }

  static getLastName(user) {
    return user && user.lastName ? user.lastName : null;
  }

  static getEmail(user) {
    return user && user.email ? user.email : null;
  }

  static compose(components) {
    if (environment.flags.useEncryptedUrl) {
      const p = MeetingUrl.encrypt(components);
      return `?p=${p}`;
    } else {
      components = Object.keys(components).map(key => {
        return {
          key,
          value: components[key]
        };
      }).filter(x => x.value != null && x.value !== false).map(x => `${x.key}=${x.value}`);
      return `?${components.join('&')}`;
    }
  }

  static decompose(url) {
    let components = {};

    if (environment.flags.useEncryptedUrl) {
      const params = new URLSearchParams(url.split('?')[1]);

      if (params.has('p')) {
        components = MeetingUrl.decrypt(params.get('p'));
      }
    } else if (url.indexOf('?') > -1) {
      const params = new URLSearchParams(url.split('?')[1]);
      params.forEach((value, key) => {
        switch (key) {
          case 'viewId':
          case 'pathId':
          case 'embedViewId':
            value = value ? parseInt(value) : null;
            break;

          case 'support':
            value = value ? value === 'true' : false;
            break;
        }

        components[key] = value;
      });
    }

    return components;
  }

  static decrypt(p) {
    return JSON.parse(window.atob(p));
  }

  static encrypt(params) {
    return window.btoa(JSON.stringify(params));
  }

  static validateParams(components) {
    if (environment.flags.useEncryptedUrl) {
      const p = MeetingUrl.encrypt(components);
      return {
        p
      };
    } else {
      return components;
    }
  }

}class RouterOutletStructure extends rxcomp.Structure {
  // host;
  // outlet;
  // element;
  // instance;
  // route$_ = new ReplaySubject(1);
  getFactory(route) {
    let factory = null;
    const routes = RouterService.routes;
    const originalRoute = routes.find(x => x.name === route.name);

    if (originalRoute) {
      factory = originalRoute.factory;
    } // console.log('RouterOutletStructure.getFactory', originalRoute, routes, route);


    return factory;
  }

  onInit() {
    this.route$().pipe(operators.switchMap(route => this.factory$(route)), operators.takeUntil(this.unsubscribe$)).subscribe(event => {// console.log('RouterOutletStructure.route$', event);
    });
    /*
    this.route$().pipe(
    	switchMap(snapshot => this.factory$(snapshot)),
    	takeUntil(this.unsubscribe$)
    ).subscribe(() => {
    	// console.log(`RouterOutletStructure ActivatedRoutes: ["${RouterService.flatRoutes.filter(x => x.snapshot).map(x => x.snapshot?.extractedUrl).join('", "')}"]`);
    });
    if (this.host) {
    	this.route$_.next(this.host.route.childRoute);
    }
    */
  }

  route$() {
    return RouterService.event$.pipe(operators.map(event => {
      const route = event.route;
      this.route = route; // console.log('RouterOutletStructure.route', route);

      return route;
    }));
    /*
    const routes = this.routes;
    // console.log('RouterOutletStructure.route$', routes);
    if (routes) {
    	return RouterService.useBrowser$(routes).pipe(
    		map(event => {
    			// console.log('RouterOutletStructure.route$', event);
    			return event.route;
    		}),
    	);
    } else {
    	return EMPTY;
    }
    */
  }

  factory$(route) {
    const factory = this.getFactory(route); // console.log('RouterOutletStructure.factory$', route, factory);

    const {
      module,
      node
    } = rxcomp.getContext(this);

    {
      this.factory_ = factory;
      return rxjs.of(factory).pipe(operators.tap(() => {
        if (this.element) {
          this.element.parentNode.removeChild(this.element);
          module.remove(this.element, this);
          this.element = undefined;
          this.instance = undefined;
        }
      }), operators.map(() => {
        if (factory && factory.meta.template) {
          let element = document.createElement('div');
          element.innerHTML = factory.meta.template;

          if (element.children.length === 1) {
            element = element.firstElementChild;
          }

          node.appendChild(element);
          const instance = module.makeInstance(element, factory, factory.meta.selector, this, undefined, {
            route
          });
          module.compile(element, instance);
          this.instance = instance;
          this.element = element;
          return {
            element,
            instance
          };
        }
      }));
    }
  }

  onChanges() {
    /*
    if (this.host) {
    	this.route$_.next(this.host.route.childRoute);
    }
    */
  }
  /*
  route$() {
  	const source = this.host ? this.route$_ : RouterService.route$;
  	return source.pipe(
  		filter((snapshot) => {
  			this.route_ = snapshot; // !!!
  			if (this.snapshot_ && snapshot && this.snapshot_.component === snapshot.component) {
  				this.snapshot_.next(snapshot);
  				return false;
  			} else {
  				this.snapshot_ = snapshot;
  				return true;
  			}
  		}),
  	);
  }
  */

  /*
  factory$(snapshot) {
  	const { module, node } = getContext(this);
  	const factory = snapshot.component;
  	if (this.factory_ !== factory) {
  		this.factory_ = factory;
  		return this.onLeave$_(snapshot, this.element, this.instance).pipe(
  			tap(() => {
  				if (this.element) {
  					this.element.parentNode.removeChild(this.element);
  					module.remove(this.element, this);
  					this.element = undefined;
  					this.instance = undefined;
  				}
  			}),
  			switchMap(() => {
  				if (snapshot && factory && factory.meta.template) {
  					let element = document.createElement('div');
  					element.innerHTML = factory.meta.template;
  					if (element.children.length === 1) {
  						element = element.firstElementChild;
  					}
  					node.appendChild(element);
  					const instance = module.makeInstance(element, factory, factory.meta.selector, this, undefined, { route: snapshot });
  					module.compile(element, instance);
  					this.instance = instance;
  					this.element = element;
  					snapshot.element = element;
  					return this.onOnce$_(snapshot, element, instance).pipe(
  						switchMap(() => {
  							return this.onEnter$_(snapshot, element, instance);
  						})
  					);
  				} else {
  					return of(void 0);
  				}
  			})
  		);
  	} else {
  		return of(void 0);
  	}
  }
  */

  /*
  onOnce$_(snapshot, element, instance) {
  	if (!transitionOnced() && instance instanceof View && element) {
  		transitionOnce();
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof OnceTransition && x.matcher(snapshot.previousRoute?.path));
  		return transition ? asObservable([element, snapshot.previousRoute], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  
  onEnter$_(snapshot, element, instance) {
  	if (instance instanceof View && element) {
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof EnterTransition && x.matcher(snapshot.previousRoute?.path));
  		return transition ? asObservable([element, snapshot.previousRoute], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  
  onLeave$_(snapshot, element, instance) {
  	if (instance instanceof View && element) {
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof LeaveTransition && x.matcher(snapshot?.path));
  		return transition ? asObservable([element, snapshot], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  */


}
RouterOutletStructure.meta = {
  selector: 'router-outlet,[router-outlet]',
  hosts: {
    host: RouterOutletStructure
  }
};class AccessCodeComponent extends rxcomp.Component {
  onInit() {
    this.state = {};
    const meetingUrl = new MeetingUrl();

    if (!meetingUrl.link) {
      // !!!
      // RouterService.setRouterLink(MeetingUrl.getGuidedTourUrl());
      window.location.href = window.location.origin + MeetingUrl.getGuidedTourUrl();
    } else {
      const url = meetingUrl.toGuidedTourUrl();
      const {
        node
      } = rxcomp.getContext(this);
      new QRious({
        element: node.querySelector('.qrcode'),
        value: url,
        size: 256
      });
    }
  }

}
AccessCodeComponent.meta = {
  selector: '[access-code-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template:
  /* html */
  `
		<div class="page page--access-code">
			${CHUNK_BACKGROUND}
			<!-- access-code -->
			<div class="ui ui--info ui--info-centered">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_code_title' | label"></div>
						<div class="picture">
							<canvas class="qrcode"></canvas>
						</div>
					</div>
				</div>
			</div>
			${CHUNK_LOGO}
			${CHUNK_CREDITS}
			${CHUNK_LANGUAGE}
		</div>
	`
};function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}class ControlsComponent extends rxcomp.Component {
  get group() {
    if (this.formGroup) {
      return this.formGroup;
    } else {
      if (!this.host) {
        throw 'missing form collection';
      }

      return this.host.control;
    }
  }

  getControl(name) {
    return this.group.get(name);
  }

}
ControlsComponent.meta = {
  selector: '[controls]',
  inputs: ['formGroup', 'fields'],
  hosts: {
    host: rxcompForm.FormAbstractCollectionDirective
  },
  template:
  /* html */
  `
		<div *for="let field of fields">
			<div *if="['text', 'email', 'url'].indexOf(field.type) !== -1" control-text [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'select'" control-select [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'custom-select'" control-custom-select [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'textarea'" control-textarea [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'checkbox'" control-checkbox [control]="getControl(field.name)" [label]="field.label | label"></div>
			<input *if="field.type == 'hidden'" [name]="field.name" [formControl]="getControl(field.name)" value="" type="text" style="display:none !important;" />
		</div>
	`
};
function fieldsToFormControls(fields) {
  const controls = fields.reduce((p, c, i) => {
    const validators = [];

    if (c.required) {
      validators.push(c.type === 'checkbox' ? rxcompForm.Validators.RequiredTrueValidator() : rxcompForm.Validators.RequiredValidator());
    }

    if (c.type === 'email') {
      validators.push(rxcompForm.Validators.EmailValidator());
    }

    if (c.type === 'url') {
      validators.push(rxcompForm.Validators.PatternValidator('(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})'));
    }

    if (c.pattern != null) {
      validators.push(rxcompForm.Validators.PatternValidator(c.pattern));
    }

    p[c.name] = new rxcompForm.FormControl(c.value != null ? c.value : null, validators);

    if (c.type === 'select' || c.type === 'custom-select') {
      const options = (c.options || []).slice();
      options.unshift({
        id: null,
        name: 'select'
      }); // LabelPipe.transform('select')

      p[c.name].options = options;
    }

    return p;
  }, {});
  return controls;
}
function fieldsToFormGroup(fields) {
  return new rxcompForm.FormGroup(fieldsToFormControls(fields));
}
function patchFields(fields, form) {
  const testValues = fields.reduce((p, c, i) => {
    if (c.test) {
      p[c.name] = c.test;
    }

    return p;
  }, {});
  form.patch(testValues);
}class LabelPipe extends rxcomp.Pipe {
  static get labels() {
    return environment.labels;
  }

  static transform(key) {
    switch (key) {
      case '@copy':
        return this.getCopy();
    }

    const labels = LabelPipe.labels;
    let label = labels[key] != null ? labels[key] : key; // `#${key}#`;

    if (typeof label === 'string' && label.indexOf('@copy') !== -1) {
      label = label.replace('@copy', this.getCopy());
    }

    return label;
  }

  static getKeys() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    return LabelPipe.transform(keys.map(x => x.replace('-', '_')).join('_'));
  }

  static getCopy() {
    return `©${new Date().getFullYear()}`;
  }

}
LabelPipe.meta = {
  name: 'label'
};class LocationService {
  static has(key) {
    const params = new URLSearchParams(window.location.search); // console.log('LocationService.has', params);

    return params.has(key);
  }

  static get(key) {
    const params = new URLSearchParams(window.location.search); // console.log('LocationService.get', params);

    return params.get(key);
  }

  static set(keyOrValue, value) {
    const params = new URLSearchParams(window.location.search);

    if (typeof keyOrValue === 'string') {
      params.set(keyOrValue, value);
    } else {
      params.set(keyOrValue, '');
    }

    this.pushParams(params); // console.log('LocationService.set', params, keyOrValue, value);
  }

  static delete(key) {
    const params = new URLSearchParams(window.location.search); // console.log('LocationService.has', params);

    if (params.has(key)) {
      params.delete(key);
      this.pushParams(params);
    }
  }

  static pushParams(params) {
    if (window.history && window.history.pushState) {
      const title = document.title;
      const url = `${window.location.href.split('?')[0]}?${params.toString()}`;
      window.history.pushState(params.toString(), title, url);
    }
  }

  static replace(from, to) {
    const history = window.history;

    if (history && history.replaceState) {
      const location = window.location;
      const title = document.title;

      if (location.pathname === '/') {
        const url = location.origin + to + location.search;
        history.replaceState(history.state, title, url);
      } else if (location.href.indexOf(from) !== -1) {
        const url = location.href.replace(from, to);
        history.replaceState(history.state, title, url);
      }
    }
  }

  static deserialize(key) {
    const encoded = this.get('params');
    return this.decode(key, encoded);
  }

  static serialize(keyOrValue, value) {
    const params = this.deserialize();
    const encoded = this.encode(keyOrValue, value, params);
    this.set('params', encoded);
  }

  static decode(key, encoded) {
    let decoded = null;

    if (encoded) {
      const json = window.atob(encoded);
      decoded = JSON.parse(json);
    }

    if (key && decoded) {
      decoded = decoded[key];
    }

    return decoded || null;
  }

  static encode(keyOrValue, value, params) {
    params = params || {};
    let encoded = null;

    if (typeof keyOrValue === 'string') {
      params[keyOrValue] = value;
    } else {
      params = keyOrValue;
    }

    const json = JSON.stringify(params);
    encoded = window.btoa(json);
    return encoded;
  }

}class LanguageService {
  static get lang() {
    return this.lang$.getValue();
  }

  static set lang(lang) {
    if (this.lang !== lang) {
      this.lang$.next(lang);
    }
  }

  static setAlternates(language, alternates) {
    this.languages = alternates;
    this.lang = language; // console.log('LanguageService.setAlternates', language, alternates);
  }

  static setRoute(route, routes) {
    const language = route.params.lang; // console.log('LanguageService.setRoute', route, route.path, language);

    const alternates = environment.languages.map(lang => {
      const title = lang === 'it' ? 'Italiano' : 'English';
      const alternateName = route.name.replace(new RegExp(`(^${language}$)|(^${language}\.)`), (match, g1, g2, offset) => {
        // console.log('LanguageService.match', match, g1, g2, offset);
        return g1 ? lang : `${lang}.`;
      });
      const alternate = routes.find(x => x.name === alternateName); // console.log('LanguageService.alternate', lang, alternateName, alternate);

      if (alternate) {
        return {
          name: alternate.name,
          params: route.params,
          href: alternate.path,
          lang: alternate.defaultParams.lang,
          title
        };
      } else {
        return null;
      }
    }).filter(x => x !== null);
    this.setAlternates(language, alternates);
  }

  static get hasLanguages() {
    return this.languages.length > 1;
  }

  static get activeLanguage() {
    return this.languages.find(language => language.lang === this.lang);
  }

  static getDefaultLanguages() {
    return environment.alternates || [];
  }

  static getDefaultLanguage() {
    return environment.defaultLanguage || (this.languages ? this.languages[0].lang : null);
  }

  static setLanguage(language) {
    this.lang = language.lang;
  }

  static setLanguage$(language) {
    if (typeof language === 'string') {
      language = this.languages.find(x => x.lang === language);
    }

    if (!language) {
      return;
    }

    const url = environment.flags.production ? `/api/${language.lang}/labels/` : `./api/${language.lang}/labels.json`;
    return rxjs.from(fetch(url).then(response => {
      return response.json();
    })).pipe(operators.tap(labels => {
      environment.labels = labels;
      RouterService.replaceHistoryState(language.name, language.params);
      const from = this.activeLanguage.href.split('?')[0];
      const to = language.href.split('?')[0];
      LocationService.replace(from, to);
      this.lang = language.lang;
    }));
    /*
    return of(language).pipe(
    	tap(language => {
    		// LabelPipe.setLabels();
    		LocationService.replace(this.activeLanguage.href, language.href);
    		this.lang = language.lang;
    	}),
    );
    */
  }

  static setLanguage$_(language) {
    return rxjs.from(fetch(language.href).then(response => {
      return response.text();
    })).pipe(operators.tap(html => {
      // console.log('html', html);
      const labelsMatch = /(window\.labels\s*=\s*\n*\s*\{((\{.+?\})|.)+?\})/gms.exec(html);

      if (labelsMatch) {
        // console.log('labels', labelsMatch[0]);
        new Function(labelsMatch[0]).call(window);
        LabelPipe.setLabels();
      }

      const bhereMatch = /(window\.bhere\s*=\s*\n*\s*\{((\{.+?\})|.)+?\})/gms.exec(html);

      if (bhereMatch) {
        // console.log('bhere', bhereMatch[0]);
        const data = {};
        new Function(bhereMatch[0].replace('window', 'this')).call(data);

        if (data.bhere) {
          Utils.merge(environment, data.bhere);
        }
      }

      LocationService.replace(this.activeLanguage.href, language.href); // console.log(environment.labels);

      this.lang = language.lang;
    }));
  }

  static toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }

}
LanguageService.languages = LanguageService.getDefaultLanguages();
LanguageService.lang$ = new rxjs.BehaviorSubject(LanguageService.getDefaultLanguage());class RoutePipe extends rxcomp.Pipe {
  static transform(key) {
    return key.replace(':lang', LanguageService.lang);
  }

}
RoutePipe.meta = {
  name: 'route'
};const USE_AUTODETECT = false;
const VIDEO_PROFILES = [
/*
['120p_1', 160, 120, 15, 65, false]],
['120p_3', 120, 120, 15, 50, false]],
['180p_1', 320, 180, 15, 140, false]],
['180p_3', 180, 180, 15, 100, false]],
['180p_4', 240, 180, 15, 120, false]],
['240p_1', 320, 240, 15, 200, false]],
['240p_3', 240, 240, 15, 140, false]],
['240p_4', 424, 240, 15, 220, false]],
['360p_1', 640, 360, 15, 400, false]],
['360p_3', 360, 360, 15, 260, false]],
['360p_4', 640, 360, 30, 600, false]],
['360p_6', 360, 360, 30, 400, false]],
['360p_7', 480, 360, 15, 320, false]],
['360p_8', 480, 360, 30, 490, false]],
['360p_9', 640, 360, 15, 800, false]],
['360p_10', 640, 360, 24, 800, false]],
['360p_11', 640, 360, 24, 1000, false]],
*/
['480p_1', 640, 480, 15, 500, true], ['480p_2', 640, 480, 30, 1000, true], ['480p_3', 480, 480, 15, 400, true], ['480p_4', 640, 480, 30, 750, true], ['480p_6', 480, 480, 30, 600, true], ['480p_8', 848, 480, 15, 610, true], ['480p_9', 848, 480, 30, 930, true], ['480p_10', 640, 480, 10, 400, true], ['720p_1', 1280, 720, 15, 1130, true], ['720p_2', 1280, 720, 30, 2000, true], ['720p_3', 1280, 720, 30, 1710, true], ['720p_5', 960, 720, 15, 910, true], ['720p_6', 960, 720, 30, 1380, true], ['1080p_1', 1920, 1080, 15, 2080, false], ['1080p_2', 1920, 1080, 30, 3000, false], ['1080p_3', 1920, 1080, 30, 3150, false], ['1080p_5', 1920, 1080, 60, 4780, false]];
const StreamQualities = VIDEO_PROFILES.map(a => {
  return {
    profile: a[0],
    resolution: {
      width: a[1],
      height: a[2]
    },
    frameRate: {
      min: a[3],
      max: a[3]
    },
    bitrate: {
      min: a[4],
      max: a[4]
    },
    compatible: a[5]
  };
});
/*
export const StreamQualities = [{
	// id: 1,
	// name: '4K 2160p 3840x2160',
	profile: '4K',
	resolution: {
		width: 3840,
		height: 2160
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 8910,
		max: 13500
	}
}, {
	// id: 2,
	// name: 'HD 1440p 2560×1440',
	profile: '1440p',
	resolution: {
		width: 2560,
		height: 1440
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 4850,
		max: 7350
	}
}, {
	// id: 3,
	// name: 'HD 1080p 1920x1080',
	profile: '1080p',
	resolution: {
		width: 1920,
		height: 1080
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 2080,
		max: 4780
	}
}, {
	// id: 4,
	// name: 'LOW 720p 1280x720',
	profile: '720p_3',
	resolution: {
		width: 1280,
		height: 720
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 1130,
		max: 1710
	}
}, {
	// id: 5,
	// name: 'LOWEST 240p 320x240',
	profile: '240p_1',
	resolution: {
		width: 320,
		height: 240
	},
	frameRate: {
		min: 15,
		max: 15
	},
	bitrate: {
		min: 140,
		max: 200
	}
}];
*/

function getStreamQuality(state) {
  let profile = environment.profiles.streamer;

  switch (state.role) {
    case RoleType.Publisher:
    case RoleType.SmartDevice:
      profile = environment.profiles.publisher || environment.profiles.streamer;
      break;

    case RoleType.Attendee:
      profile = environment.profiles.attendee || environment.profiles.streamer;
      break;
  }

  return StreamQualities.find(x => x.profile === profile);
}
/*
export function getStreamQuality(state) {
	const lowestQuality = StreamQualities[StreamQualities.length - 1];
	const highestQuality = environment.flags.maxQuality ? StreamQualities[0] : StreamQualities[StreamQualities.length - 2];
	return (state.role === RoleType.Publisher || state.role === RoleType.SmartDevice) ? highestQuality : lowestQuality;
}
*/

const AgoraStatus = {
  Idle: 'idle',
  Checklist: 'checklist',
  Link: 'link',
  Login: 'login',
  Name: 'name',
  Device: 'device',
  ShouldConnect: 'should-connect',
  Connecting: 'connecting',
  Connected: 'connected',
  Disconnected: 'disconnected'
};
const MessageType = {
  AgoraEvent: 'agoraEvent',
  Ping: 'ping',
  ChannelMembers: 'channelMembers',
  SupportRequest: 'supportRequest',
  SupportRequestAccepted: 'supportRequestAccepted',
  SupportRequestRejected: 'supportRequestRejected',
  RequestControl: 'requestControl',
  RequestControlAccepted: 'requestControlAccepted',
  RequestControlRejected: 'requestControlRejected',
  RequestControlDismiss: 'requestControlDismiss',
  RequestControlDismissed: 'requestControlDismissed',
  RequestPeerInfo: 'requestPeerInfo',
  RequestPeerInfoResult: 'requestPeerInfoResult',
  RequestInfo: 'requestInfo',
  RequestInfoResult: 'requestInfoResult',
  RequestInfoDismiss: 'requestInfoDismiss',
  RequestInfoDismissed: 'requestInfoDismissed',
  RequestInfoRejected: 'requestInfoRejected',
  RemoteSilencing: 'remoteSilencing',
  SlideChange: 'slideChange',
  ControlInfo: 'controlInfo',
  AddLike: 'addLike',
  ShowPanel: 'showPanel',
  PlayMedia: 'playMedia',
  ZoomMedia: 'zoomMedia',
  CurrentTimeMedia: 'currentTimeMedia',
  PlayModel: 'playModel',
  Mode: 'mode',
  NavInfo: 'navInfo',
  NavToView: 'navToView',
  NavToGrid: 'navToGrid',
  NavLink: 'navLink',
  NavLinkClose: 'navLinkClose',
  VRStarted: 'vrStarted',
  VREnded: 'vrEnded',
  VRState: 'vrState',
  MenuToggle: 'menuToggle',
  ChatMessage: 'chatMessage',
  ChatTypingBegin: 'chatTypingBegin',
  ChatTypingEnd: 'chatTypingEnd',
  SelectItem: 'selectItem'
};
const UIMode = {
  VirtualTour: 'virtual-tour',
  LiveMeeting: 'live-meeting',
  SelfServiceTour: 'self-service-tour',
  Embed: 'embed',
  None: 'none'
};
class AgoraEvent {
  constructor(options) {
    Object.assign(this, options);
  }

}
class AgoraPeerEvent extends AgoraEvent {}
class AgoraRemoteEvent extends AgoraEvent {}
class AgoraMuteVideoEvent extends AgoraEvent {}
class AgoraUnmuteVideoEvent extends AgoraEvent {}
class AgoraMuteAudioEvent extends AgoraEvent {}
class AgoraUnmuteAudioEvent extends AgoraEvent {}
class AgoraVolumeLevelsEvent extends AgoraEvent {}class HttpService {
  static http$(method, url, data, format) {

    const methods = ['POST', 'PUT', 'PATCH'];
    let response_ = null; // url = this.getUrl(url, format);

    return rxjs.from(fetch(url, {
      method: method,
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: methods.indexOf(method) !== -1 ? JSON.stringify(data) : undefined
    }).then(response => {
      response_ = response; // console.log(response);

      try {
        const contentType = response.headers.get('content-type');
        let typedResponse;

        if (contentType && contentType.indexOf('application/json') !== -1) {
          typedResponse = response.json();
        } else {
          typedResponse = response.text();
        }

        if (response.ok) {
          return typedResponse;
        } else {
          return typedResponse.then(data => {
            return Promise.reject(data);
          });
        }
      } catch (error) {
        if (response.ok) {
          console.warn('HttpService.http$', 'Cannot parse response');
          return Promise.resolve();
        } else {
          return Promise.reject(error);
        }
      }
    })).pipe(operators.catchError(error => {
      return rxjs.throwError(this.getError(error, response_));
    }));
  }
  /*
  // !!! todo mapping response.data
  static http$(method, url, data, format = 'json') {
  	const methods = ['POST', 'PUT', 'PATCH'];
  	const body = (data && methods.indexOf(method) !== -1) ? JSON.stringify(data) : undefined;
  	const queryString = (data && methods.indexOf(method) !== -1) ? Object.keys(data).map(function(key) {
  		return key + '=' + encodeURI(data[key]);
  	}).join('&') : undefined;
  	if (queryString) {
  		url = `${url}?${queryString}`;
  	}
  	let response_ = null;
  	return from(fetch(url, {
  		method: method,
  		headers: {
  			'Accept': 'application/json',
  			'Content-Type': 'application/json',
  		},
  		body: body,
  	}).then((response) => {
  		response_ = new HttpResponse(response);
  		try {
  			const contentType = response.headers.get('content-type');
  			let typedResponse;
  			if (contentType && format === 'json' && contentType.indexOf('application/json') !== -1) {
  				typedResponse = response.json();
  			} else if (format === 'blob') {
  				typedResponse = response.blob();
  			} else {
  				typedResponse = response.text();
  			}
  			return typedResponse.then(data => {
  				response_.data = data;
  				if (response.ok) {
  					return Promise.resolve(response_);
  				} else {
  					return Promise.reject(response_);
  				}
  			});
  		} catch(error) {
  			if (response.ok) {
  				console.warn('HttpService.http$', 'Cannot parse response');
  				return Promise.resolve(response_);
  			} else {
  				return Promise.reject(this.getError(error, response_));
  			}
  		}
  	})).pipe(
  		catchError(error => {
  			return throwError(this.getError(error, response_));
  		}),
  	);
  }
  */


  static get$(url, data, format) {
    const query = this.query(data);
    return this.http$('GET', `${url}${query}`, undefined, format);
  }

  static delete$(url) {
    return this.http$('DELETE', url);
  }

  static post$(url, data) {
    return this.http$('POST', url, data);
  }

  static put$(url, data) {
    return this.http$('PUT', url, data);
  }

  static patch$(url, data) {
    return this.http$('PATCH', url, data);
  }

  static query(data) {
    return ''; // todo
  }

  static getError(object, response) {
    let error = typeof object === 'object' ? object : {};

    if (!error.status) {
      error.status = response ? response.status : 0;
    }

    if (!error.statusCode) {
      error.statusCode = response ? response.status : 0;
    }

    if (!error.statusMessage) {
      error.statusMessage = response ? response.statusText : object;
    } // console.log('HttpService.getError', error, object);


    return error;
  }

}class UserService {
  static setUser(user) {
    this.user$.next(user);
  }

  static me$() {
    return HttpService.get$('/api/user/me').pipe(operators.map(user => this.mapUser(user)), operators.catchError(error => {
      // console.log('UserService.me$.error', error);
      if (error.status === 404 || error.statusCode === 404) {
        return rxjs.of(null);
      } else {
        throw error;
      }
    }), operators.switchMap(user => {
      this.setUser(user);
      return this.user$;
    }));
  }

  static login$(payload) {
    return HttpService.post$('/api/user/login', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }

  static logout$() {
    return HttpService.get$('/api/user/logout').pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(null)));
  }

  static guidedTour$(payload) {
    return HttpService.post$('/api/user/guided-tour', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }

  static selfServiceTour$(payload) {
    return HttpService.post$('/api/user/self-service-tour', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }

  static selfServiceSupportRequest$(user, meetingId, link) {
    const payload = {
      user,
      meetingId,
      link
    };
    return HttpService.post$('/api/user/self-service-support-request', payload).pipe(operators.tap(_ => {
      if (!environment.flags.production) {
        fetch(environment.template.email.supportRequest).then(response => response.text()).then(html => {
          html = html.replace('{{username}}', MeetingUrl.getName(user));
          html = html.replace('{{href}}', link);
          const parser = new DOMParser();
          const newDocument = parser.parseFromString(html, 'text/html');
          setTimeout(() => {
            // const newWindow = window.open(window.location.origin + environment.template.email.supportRequest, '_blank');
            const newWindow = window.open();
            newWindow.document.head.innerHTML = newDocument.querySelector('head').innerHTML;
            newWindow.document.body.innerHTML = newDocument.querySelector('body').innerHTML;
          }, 3000);
        });
      }
    }));
  }

  static resolve$(payload, status) {
    if (status === 'login') {
      return this.login$(payload);
    }

    if (status === 'guided-tour') {
      return this.guidedTour$(payload);
    }

    if (status === 'self-service-tour') {
      return this.selfServiceTour$(payload);
    }
  }

  static log$(payload) {
    return HttpService.post$('/api/user/log', payload);
  }

  static temporaryUser$(roleType) {
    if (roleType === void 0) {
      roleType = RoleType.Embed;
    }

    return rxjs.of({
      id: this.uuid(),
      type: roleType,
      username: roleType // firstName: 'Jhon',
      // lastName: 'Appleseed',

    }).pipe(operators.map(user => this.mapUser(user)), operators.switchMap(user => {
      // console.log('UserService.temporaryUser$', user);
      this.setUser(user);
      return this.user$;
    }));
  }

  static overrideUser$(roleType) {
    if (roleType === void 0) {
      roleType = RoleType.Embed;
    }

    return this.me$().pipe(operators.switchMap(user => {
      if (user) {
        user.type = roleType;
        user.username = roleType;
        return this.user$;
      }

      return this.temporaryUser$(roleType);
    }));
  }

  static uuid() {
    return new Date().getTime(); // return parseInt(process.hrtime.bigint().toString());
  }
  /*
  static retrieve$(payload) {
  	return HttpService.post$('/api/user/retrievepassword', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  
  static register$(payload) {
  	return HttpService.post$('/api/user/register', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  
  static update(payload) {
  	return HttpService.post$('/api/user/updateprofile', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  */


  static mapUser(user) {
    return new User(user);
  }

  static getMode(role) {
    let mode;

    switch (role) {
      case RoleType.Publisher:
      case RoleType.Attendee:
      case RoleType.Streamer:
      case RoleType.Viewer:
      case RoleType.Publisher:
      case RoleType.Publisher:
        mode = UIMode.VirtualTour;
        break;

      case RoleType.SelfService:
        mode = UIMode.SelfServiceTour;
        break;

      case RoleType.SmartDevice:
        mode = UIMode.LiveMeeting;
        break;

      case RoleType.Embed:
        mode = UIMode.Embed;
        break;

      default:
        mode = UIMode.None;
    } // console.log('UserService.getMode', role, mode);


    return mode;
  }

}
UserService.user$ = new rxjs.BehaviorSubject(null);let UID$2 = 0;
class WebhookEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }

  toJson() {
    return JSON.stringify(this);
  }

  static newEvent(action, data, extra) {
    console.log('WebhookEvent.newEvent', action, data, extra);
    const event = new WebhookEvent();
    const timestamp = new Date().getTime();
    event.timestamp = timestamp;
    event.id = `${timestamp}-${++UID$2}`;
    event.action = action;
    event.data = data;

    if (extra) {
      event.extra = typeof extra === 'string' ? JSON.parse(extra) : extra;
    }

    if (StateService.state.link) {
      // ( meetingId, userSessionId, userRole, fullName, itemId, skuId, action:InfoPoint  )
      event.meetingId = StateService.state.link;
      event.userSessionId = StateService.state.uid;
      event.userRole = StateService.state.role;
      event.fullName = StateService.state.name;
    }

    return event;
  }

  static parseEvent(event) {
    if (event && 'data' in event) {
      const message = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

      if ('action' in message) {
        return new WebhookEvent(message);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }

}
class WebhookService {
  static internal$_(event) {
    return rxjs.of(event).pipe(operators.tap(event => {
      console.log('WebhookService.internal$_.postMessage', event);

      if (window.parent) {
        window.parent.postMessage(event.action, event.toJson());
      }
    }), operators.switchMap(event => {
      return this.event$_.pipe(operators.filter(event => event.id === event.id), operators.first());
    }), operators.map(response => {
      console.log('WebhookService.internal$_.handleResponse_', event, response);
      return this.handleResponse_(event, response);
    }), operators.catchError(error => {
      return this.handleError_(event, error);
    }));
  }

  static send$_(uri, event) {
    return HttpService.post$(uri, event).pipe(operators.map(response => {
      return this.handleResponse_(event, response);
    }), operators.catchError(error => {
      return this.handleError_(event, error);
    }));
  }

  static send$(action, payload, extra) {
    console.log('WebhookService.send$', action, payload, extra);

    if (this.enabled) {
      const event = WebhookEvent.newEvent(action, payload, extra);
      const uris = environment.webhook.uris;
      const observables = uris.map(x => x === 'internal' ? this.internal$_(event) : this.send$_(x, event));
      return rxjs.forkJoin(observables);
    } else {
      return rxjs.of(null);
    }
  }

  static handleResponse_(event, remoteResponse) {
    console.log('WebhookService.handleResponse_', remoteResponse);
    const response = Object.assign({}, event);
    response.remoteStatus = 1;
    response.remoteResponse = remoteResponse;
    return response;
  }

  static handleError_(event, error) {
    const response = Object.assign({}, event);
    response.remoteStatus = 0;
    response.remoteError = error;
    return rxjs.of(response);
  }

  static get enabled() {
    const webhook = environment.webhook;
    const enabled = webhook && webhook.uris && webhook.uris.length > 0;

    if (enabled) {
      webhook.methods = webhook.methods || {};
      webhook.methods.nav = webhook.methods.nav || [];
    }

    return enabled;
  }

}
WebhookService.event$_ = rxjs.fromEvent(window, 'message').pipe(operators.map(event => {
  const parsedEvent = WebhookEvent.parseEvent(event);
  return parsedEvent;
}), operators.filter(x => x !== null), operators.shareReplay(1));class AccessComponent extends rxcomp.Component {
  onInit() {
    // console.log('AccessComponent.onInit');
    this.state = {
      status: 'access'
    };

    window.onSSOPopupClose = status => {
      if (status === 'success') {
        alert('Login Successful');
        UserService.me$().pipe(operators.first()).subscribe(user => {
          // console.log('AccessComponent.onInit.onSSOPopupClose', user);
          const routeUrl = RoutePipe.transform(':lang.selfServiceTour');
          const pathId = environment.pathMapper && environment.pathMapper.ssoLogin ? environment.pathMapper.ssoLogin(user) : null;

          if (pathId) {
            RouterService.setRouterLink(routeUrl, MeetingUrl.validateParams({
              pathId
            }));
          } else {
            RouterService.setRouterLink(routeUrl);
          }
        });
      } else {
        alert('Login Failed');
      }
    };
  }

  onSelfServiceTourRequest() {
    this.initRequestForm();
    this.state.status = 'self-service-tour';
    this.pushChanges();

    if (STATIC && window.navigator.userAgent.indexOf('OculusBrowser') !== -1) {
      this.test();
      this.onSubmit();
    }
  }

  onGuidedTourRequest() {
    this.initRequestForm();
    this.state.status = 'guided-tour';
    this.pushChanges();
  }

  onSSOLogin(event) {
    const loginUrl = `${location.protocol}//${location.host}/sso/login`;
    window.open(loginUrl, 'BHere | SSO Login', 'left=20,top=20,width=600,height=600,toolbar=1,resizable=0');
    event.preventDefault();
    return false;
  }

  onSSORegister(event) {
    const loginUrl = `${location.protocol}//${location.host}/sso/register`;
    window.open(loginUrl, 'BHere | SSO Register', 'left=20,top=20,width=600,height=600,toolbar=1,resizable=0');
    event.preventDefault();
    return false;
  }

  onGuidedTourAccess() {
    UserService.logout$().pipe(operators.first()).subscribe(() => {
      RouterService.setRouterLink(RoutePipe.transform(':lang.guidedTour'));
    });
  }

  onLogin() {
    this.initLoginForm();
    this.state.status = 'login';
    this.pushChanges();
  }

  initRequestForm() {
    if (this.formSubscription) {
      this.formSubscription.unsubscribe();
    }

    const data = this.data = environment.data || {
      roles: [{
        id: 1,
        name: 'Show room'
      }, {
        id: 2,
        name: 'Architetto'
      }, {
        id: 3,
        name: 'Interior designer'
      }, {
        id: 4,
        name: 'Privato'
      }, {
        id: 5,
        name: 'Altro'
      }]
    };
    const fields = this.fields = environment.fields || [{
      type: 'text',
      name: 'firstName',
      label: 'access_first_name',
      required: true,
      test: 'Jhon'
    }, {
      type: 'text',
      name: 'lastName',
      label: 'access_last_name',
      required: true,
      test: 'Appleseed'
    }, {
      type: 'email',
      name: 'email',
      label: 'access_email',
      required: true,
      test: 'jhonappleseed@gmail.com'
    }, {
      type: 'custom-select',
      name: 'role',
      label: 'access_role',
      required: true,
      options: data.roles,
      test: data.roles[0].id
    }, {
      type: 'checkbox',
      name: 'privacy',
      label: 'access_privacy_disclaimer',
      required: true,
      test: true
    }];
    fields.push({
      type: 'hidden',
      name: 'checkField',
      value: '',
      test: ''
    });

    if (environment.antiforgery) {
      fields.push({
        type: 'none',
        name: 'checkRequest',
        value: environment.antiforgery,
        test: environment.antiforgery
      });
    }

    const form = this.form = fieldsToFormGroup(fields);
    this.controls = form.controls;
    this.formSubscription = form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }

  initLoginForm() {
    if (this.formSubscription) {
      this.formSubscription.unsubscribe();
    }

    const form = this.form = new rxcompForm.FormGroup({
      username: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      password: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
    this.controls = form.controls;
    this.formSubscription = form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }

  test() {
    if (this.state.status === 'login') {
      this.form.patch({
        username: 'publisher',
        password: 'publisher',
        checkRequest: window.antiforgery || '',
        checkField: ''
      });
    } else {
      patchFields(this.fields, this.form);
    }
  }

  reset() {
    this.form.reset();
  }

  onBack() {
    this.state.status = 'access';
    this.pushChanges();
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const payload = this.form.value;

      const webhookPayload = _objectSpread2({}, payload);

      const controls = this.controls;
      Object.keys(webhookPayload).forEach(key => {
        if (controls[key].options) {
          const options = controls[key].options;
          webhookPayload[key] = options.find(option => option.id === webhookPayload[key]).name;
        }
      });
      const status = this.state.status;
      UserService.resolve$(payload, status).pipe(operators.first()).subscribe(response => {
        // console.log('AccessComponent.onSubmit', response);
        switch (status) {
          case 'guided-tour':
            this.onHandleHook('GuidedTour', webhookPayload).pipe(operators.first()).subscribe(response => {
              this.state.status = 'guided-tour-success';
              this.pushChanges();
            });
            break;

          case 'self-service-tour':
            this.onHandleHook('SelfServiceTour', webhookPayload).pipe(operators.first()).subscribe(response => {
              const routeUrl = RoutePipe.transform(':lang.selfServiceTour');
              const pathId = environment.pathMapper && environment.pathMapper.selfService ? environment.pathMapper.selfService(user) : null;

              if (pathId) {
                RouterService.setRouterLink(routeUrl, MeetingUrl.validateParams({
                  pathId
                }));
              } else {
                RouterService.setRouterLink(routeUrl);
              }
            });
            break;

          case 'login':
            RouterService.setRouterLink(RoutePipe.transform(':lang.guidedTour'));
            break;
        }

        this.form.reset();
      }, error => {
        console.log('AccessComponent.error', error);
        this.error = error;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }

  onHandleHook(action, values) {
    const payload = values;
    const extra = null;
    return WebhookService.send$(action, payload, extra);
  }

}
AccessComponent.meta = {
  selector: '[access-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template:
  /*html*/
  `
		<div class="page page--access">
			<!-- background -->
			<div class="background" [class]="{ 'background--image': ('background.image' | env), 'background--video': ('background.video' | env) }" *if="state.status != 'connected'">
				<img [src]="'background.image' | env | asset" *if="'background.image' | env" />
				<video [src]="'background.video' | env | asset" *if="'background.video' | env" oncanplay="this.muted = true; this.classList.add('ready');" playsinline autoplay muted loop></video>
			</div>
			<!-- access -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'access'">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_title' | label"></div>
						<div *if="'selfService' | flag">
							<button type="button" class="btn--next" (click)="onSelfServiceTourRequest($event)">
								<span [innerHTML]="'access_tour' | label"></span>
							</button>
						</div>
						<div *if="'guidedTourRequest' | flag">
							<div class="info" [innerHTML]="'access_or' | label"></div>
							<button type="button" class="btn--next" (click)="onGuidedTourRequest($event)">
								<span [innerHTML]="'access_guided_tour' | label"></span>
							</button>
						</div>
						<div *if="'guidedTourAccess' | flag">
							<div class="info" [innerHTML]="'access_has_meeting_id' | label"></div>
							<button type="button" class="btn--next" (click)="onGuidedTourAccess($event)">
								<span [innerHTML]="'access_guided_tour_cta' | label"></span>
							</button>
						</div>
						<div *if="'ssoLogin' | flag">
							<div class="info" [innerHTML]="'access_sso_login_info' | label"></div>
							<button type="button" class="btn--next" (click)="onSSOLogin($event)">
								<span [innerHTML]="'access_sso_login_cta' | label"></span>
							</button>
						</div>
						<div *if="'ssoRegister' | flag">
							<div class="info" [innerHTML]="'access_sso_register_info' | label"></div>
							<button type="button" class="btn--next" (click)="onSSORegister($event)">
								<span [innerHTML]="'access_sso_register_cta' | label"></span>
							</button>
						</div>
					</div>
				</div>
			</div>
			<!-- guided-tour -->
			<div class="ui ui--info" *if="state.status == 'self-service-tour' || state.status == 'guided-tour'">
				<div class="group--info">
					<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
						<div class="group--info__content stagger--childs">
							<div class="title" *if="state.status == 'self-service-tour'" [innerHTML]="'access_fill_fields' | label"></div>
							<div class="title" *if="state.status == 'guided-tour'" [innerHTML]="'access_guided_tour_request' | label"></div>
							<!-- controls -->
							<div controls [formGroup]="form" [fields]="fields"></div>
							<div class="group--error" *if="error">
								<span class="status-code" [innerHTML]="error.statusCode"></span>
								<span class="status-message" [innerHTML]="error.statusMessage"></span>
								<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
							</div>
							<!-- <div class="info" *if="isValid()" [innerHTML]="'access_take_part' | label"></div> -->
							<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
								<span *if="!form.submitted" [innerHTML]="'access_send' | label"></span>
								<span *if="form.submitted" [innerHTML]="'access_sent' | label"></span>
							</button>
							<button type="button" class="btn--mode" (click)="onBack($event)">
								<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
								<span [innerHTML]="'access_back' | label"></span>
							</button>
							<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
						</div>
					</form>
				</div>
			</div>
			<!-- guided-tour success -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'guided-tour-success'">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_request_sent' | label"></div>
						<div class="info" [innerHTML]="'access_info_request' | label"></div>
						<button type="button" class="btn--mode" (click)="onBack($event)">
							<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
							<span [innerHTML]="'access_back' | label"></span>
						</button>
					</div>
				</div>
			</div>
			<!-- login -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'login'">
				<div class="group--info">
					<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
						<div class="group--info__content stagger--childs">
							<div class="title" [innerHTML]="'access_login' | label"></div>
							<input name="checkField" [formControl]="controls.checkField" value="" type="text" style="display:none !important;" />
							<div control-text [control]="controls.username" [label]="'access_username' | label"></div>
							<div control-password [control]="controls.password" [label]="'access_password' | label"></div>
							<div class="group--error" *if="error">
								<span class="status-code" [innerHTML]="error.statusCode"></span>
								<span class="status-message" [innerHTML]="error.statusMessage"></span>
								<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
							</div>
							<div class="info" *if="isValid()" [innerHTML]="'access_cta' | label"></div>
							<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
								<span [innerHTML]="'access_cta' | label"></span>
							</button>
							<button type="button" class="btn--mode" (click)="onBack($event)">
								<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
								<span [innerHTML]="'access_back' | label"></span>
							</button>
							<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
						</div>
					</form>
				</div>
			</div>
			<header>
				<!-- logo -->
				<div class="btn--logo" (click)="onBack($event)">
					<img [src]="'logo' | env" *if="'logo' | env" />
					<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
				</div>
				${CHUNK_LANGUAGE}
			</header>
			<footer>
				<span class="group--colophon" *if="state.status != 'connected'">
					${CHUNK_CREDITS}
					${CHUNK_COPYRIGHT}
				</span>
				<!-- login -->
				<button type="button" class="btn--absolute" (click)="onLogin($event)" *if="state.status == 'access'">
					<span [innerHTML]="'access_cta' | label"></span> <svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg>
				</button>
			</footer>
		</div>
	`
};class EmojiService {
  static emoji$() {
    if (EmojiService.items_ != null) {
      return rxjs.of(EmojiService.items_);
    }

    return HttpService.get$(`${environment.assets}api/emoji/emoji.json`).pipe(operators.map(items => {
      // items = items.slice(0, Math.min(80, items.length));
      EmojiService.items_ = items;
      return items;
    }));
  }

}class AgoraChatEmojiComponent extends rxcomp.Component {
  onInit() {
    this.items = [];
    EmojiService.emoji$().pipe(operators.first()).subscribe(items => {
      setTimeout(() => {
        this.items = items;
        this.pushChanges();
      }, 1);
    });
  }

  onSelect(item) {
    this.emoji.next(item);
  }

  onClose(_) {
    this.close.next();
  }

}
AgoraChatEmojiComponent.meta = {
  selector: '[agora-chat-emoji]',
  outputs: ['emoji', 'close']
};class MessageService {
  static message(message) {
    this.message$.next(message);
  }

  static in(message) {
    // console.log('MessageService.in', message);
    this.in$.next(message);
  }

  static sendBack(message) {
    message = Object.assign({}, message, {
      remoteId: message.clientId
    }); // console.log('MessageService.sendBack', message);

    this.in$.next(message);
  }

  static out(message) {
    this.out$.next(message);
  }

}
MessageService.message$ = new rxjs.ReplaySubject(1);
MessageService.in$ = new rxjs.ReplaySubject(1);
MessageService.send = MessageService.in;
MessageService.out$ = new rxjs.ReplaySubject(1);const DevicePlatform = {
  Unknown: 'unknown',
  IOS: 'ios',
  Android: 'android',
  WindowsPhone: 'windowsPhone',
  VRHeadset: 'vrHeadset'
};
class DeviceService {
  static get platform() {
    if (!this.platform_) {
      this.platform_ = this.getDevicePlatform();
    }

    return this.platform_;
  }

  static get isIOS() {
    return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].indexOf(navigator.platform) !== -1 // iPad on iOS 13 detection
    || navigator.userAgent.indexOf('Mac') !== -1 && 'ontouchend' in document;
  }

  static get isVRHeadset() {
    return navigator.userAgent.indexOf('VR') !== -1 || navigator.userAgent.indexOf('Quest') !== -1 || navigator.userAgent.indexOf('Oculus') !== -1;
  }

  static getDevicePlatform() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera; // Windows Phone must come first because its UA also contains 'Android'

    if (/windows phone/i.test(userAgent)) {
      return DevicePlatform.WindowsPhone;
    }

    if (/android/i.test(userAgent)) {
      return DevicePlatform.Android;
    } // iOS detection from: http://stackoverflow.com/a/9039885/177710
    // if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {


    if (this.isIOS) {
      return DevicePlatform.IOS;
    }

    if (this.isVRHeadset) {
      return DevicePlatform.VRHeadset;
    }

    return DevicePlatform.Unknown;
  }

}class Emittable$1 {
  constructor() {
    this.events = {};
  }

  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }

  off(type, callback) {
    const event = this.events[type];

    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }

  once(type, callback) {
    const once = data => {
      callback(data);
      this.off(type, once);
    };

    this.on(type, once);
  }

  emit(type, data) {
    const event = this.events[type];

    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }

    const broadcast = this.events.broadcast;

    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }

  has(type) {
    const callbacks = this.events[type];
    return callbacks && callbacks.length;
  }

}class SessionStorageService {
  static delete(name) {
    if (this.isSessionStorageSupported()) {
      window.sessionStorage.removeItem(name);
    }
  }

  static exist(name) {
    if (this.isSessionStorageSupported()) {
      return window.sessionStorage[name] !== undefined;
    }
  }

  static get(name) {
    let value = null;

    if (this.isSessionStorageSupported() && window.sessionStorage[name] !== undefined) {
      try {
        value = JSON.parse(window.sessionStorage[name]);
      } catch (e) {
        console.log('SessionStorageService.get.error parsing', name, e);
      }
    }

    return value;
  }

  static set(name, value) {
    if (this.isSessionStorageSupported()) {
      try {
        const cache = [];
        const json = JSON.stringify(value, function (key, value) {
          if (typeof value === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            }

            cache.push(value);
          }

          return value;
        });
        window.sessionStorage.setItem(name, json);
      } catch (e) {
        console.log('SessionStorageService.set.error serializing', name, value, e);
      }
    }
  }

  static isSessionStorageSupported() {
    if (this.supported) {
      return true;
    }

    let supported = false;

    try {
      supported = 'sessionStorage' in window && window.sessionStorage !== null;

      if (supported) {
        window.sessionStorage.setItem('test', '1');
        window.sessionStorage.removeItem('test');
      } else {
        supported = false;
      }
    } catch (e) {
      supported = false;
    }

    this.supported = supported;
    return supported;
  }

}const StreamServiceMode = {
  Client: 'client',
  Editor: 'editor'
};
class StreamService {
  static set editorStreams(editorStreams) {
    this.editorStreams$.next(editorStreams);
  }

  static get editorStreams() {
    return this.editorStreams$.getValue();
  }

  static set editorScreens(editorScreens) {
    this.editorScreens$.next(editorScreens);
  }

  static get editorScreens() {
    return this.editorScreens$.getValue();
  }

  static set local(local) {
    this.local$.next(local);
  }

  static get local() {
    return this.local$.getValue();
  }

  static set screen(screen) {
    this.screen$.next(screen);
  }

  static get screen() {
    return this.screen$.getValue();
  }

  static set remotes(remotes) {
    this.remotes$.next(remotes);
  }

  static get remotes() {
    return this.remotes$.getValue();
  }

  static set peers(peers) {
    this.peers$.next(peers);
  }

  static get peers() {
    return this.peers$.getValue();
  }

  static orderedRemotes$() {
    return rxjs.combineLatest([StreamService.remotes$, rxjs.interval(1000)]).pipe(operators.map(datas => {
      const orderedRemotes = [];
      const remotes = datas[0];
      remotes.forEach(remote => {
        // const audioLevel = remote.getAudioLevel();
        // console.log('audioLevel', audioLevel, remote);
        let role = null,
            uid = null,
            screenUid = null,
            audioLevel = 0,
            peekAudioLevel = 0,
            order = 0;

        if (remote.clientInfo) {
          audioLevel = remote.clientInfo.audioLevel = remote.getAudioLevel();
          peekAudioLevel = remote.clientInfo.peekAudioLevel = Math.max(remote.clientInfo.audioLevel, 0.2);
          order = remote.clientInfo.order;
          role = remote.clientInfo.role || null;
          uid = remote.clientInfo.uid || null;
          screenUid = remote.clientInfo.screenUid || null;
          /*
          if (remote.clientInfo.screenUid !== remote.getId()) {
          	orderedRemotes.push(remote);
          }
          */
        }

        orderedRemotes.push({
          role,
          uid,
          screenUid,
          audioLevel,
          peekAudioLevel,
          order,
          remote
        });
      });
      orderedRemotes.sort((a, b) => {
        const av = a.role === RoleType.Publisher ? 2 : a.role === RoleType.Attendee ? 1 : 0;
        const bv = b.role === RoleType.Publisher ? 2 : b.role === RoleType.Attendee ? 1 : 0;
        return bv - av || b.peekAudioLevel - a.peekAudioLevel || (a.order || 0) - (b.order || 0);
      });
      orderedRemotes.forEach((x, i) => {
        if (x.remote.clientInfo) {
          x.remote.clientInfo.order = i;
        }
      }); // !!! hard limit max visible stream
      // orderedRemotes.length = Math.min(orderedRemotes.length, MAX_VISIBLE_STREAMS);
      // console.log('StreamService.orderedRemotes$', orderedRemotes);

      return orderedRemotes;
    }), operators.distinctUntilChanged((a, b) => {
      const auid = a.map(x => `${x.uid}-${x.screenUid}`).join('|');
      const buid = b.map(x => `${x.uid}-${x.screenUid}`).join('|'); // console.log('StreamService.orderedRemotes$', auid, buid);

      return auid === buid;
    }), operators.map(remotes => remotes.map(x => x.remote)));
  }

  static getEditorStreams$() {
    return rxjs.of(null).pipe(operators.switchMap(() => {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia && this.mode === StreamServiceMode.Editor) {
        const body = document.querySelector('body');
        const media = document.createElement('div');
        const video = document.createElement('video');
        media.setAttribute('id', 'stream-editor');
        media.setAttribute('style', 'position:absolute; top: 5000px; line-height: 0;');
        media.appendChild(video);
        body.appendChild(media);
        navigator.mediaDevices.getUserMedia({
          video: {
            width: 800,
            height: 450
          }
        }).then(stream => {
          // console.log(stream);
          if ('srcObject' in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }

          video.oncanplay = () => {
            const fakePublisherStream = {
              getId: () => 'editor',
              clientInfo: {
                role: RoleType.Publisher,
                uid: 'editor'
              }
            };
            const fakeAttendeeStream = {
              getId: () => 'editor',
              clientInfo: {
                role: RoleType.Attendee,
                uid: 'editor'
              }
            };
            const fakeSmartDeviceStream = {
              getId: () => 'editor',
              clientInfo: {
                role: RoleType.SmartDevice,
                uid: 'editor'
              }
            };
            this.editorStreams$.next([fakePublisherStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeSmartDeviceStream]); // StreamService.editorStreams = [fakePublisherStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream];
          };

          video.play();
        }).catch(error => {
          console.log('EditorComponent.getUserMedia.error', error.name, error.message);
        });
      }

      return this.editorStreams$;
    }), operators.shareReplay(1));
  }

  static getEditorScreens$() {
    return rxjs.of(null).pipe(operators.switchMap(() => {
      if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia && this.mode === StreamServiceMode.Editor) {
        const body = document.querySelector('body');
        const media = document.createElement('div');
        const video = document.createElement('video');
        media.setAttribute('id', 'stream-editor-screen');
        media.setAttribute('style', 'position:absolute; top: 5000px; line-height: 0;');
        media.appendChild(video);
        body.appendChild(media);
        navigator.mediaDevices.getDisplayMedia({
          screen: {
            width: 800,
            height: 450
          }
        }).then(stream => {
          // console.log(stream);
          if ('srcObject' in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }

          video.oncanplay = () => {
            const fakePublisherScreen = {
              getId: () => 'editor-screen',
              clientInfo: {
                role: RoleType.Publisher,
                uid: 'editor',
                screenUid: 'editor-screen'
              }
            };
            const fakeAttendeeScreen = {
              getId: () => 'editor-screen',
              clientInfo: {
                role: RoleType.Attendee,
                uid: 'editor',
                screenUid: 'editor-screen'
              }
            };
            this.editorScreens$.next([fakePublisherScreen, fakeAttendeeScreen]);
          };

          video.play();
        }).catch(error => {
          console.log('EditorComponent.getUserMedia.error', error.name, error.message);
        });
      }

      return this.editorScreens$;
    }), operators.shareReplay(1));
  }

  static get publisherStreamId() {
    const streams = this.remotes.slice();
    const local = this.local;

    if (local) {
      streams.unshift(local);
    }

    const publisherStream = streams.find(x => x.clientInfo && x.clientInfo.role === RoleType.Publisher && x.clientInfo.uid === x.getId());

    if (publisherStream) {
      return publisherStream.getId();
    }

    return null;
  }

  static getPublisherStreamId$() {
    const publisherStreamId = this.publisherStreamId;

    if (publisherStreamId) {
      return rxjs.of(publisherStreamId);
    } else {
      return this.streams$.pipe(operators.map(() => this.publisherStreamId), operators.filter(x => x));
    }
  }

  static get attendeeStreamId() {
    const streams = this.remotes.slice();
    const local = this.local;

    if (local) {
      streams.unshift(local);
    }

    const attendeeStream = streams.find(x => x.clientInfo && x.clientInfo.role === RoleType.Attendee && x.clientInfo.uid === x.getId());

    if (attendeeStream) {
      return attendeeStream.getId();
    }

    return null;
  }

  static getAttendeeStreamId$() {
    const attendeeStreamId = this.attendeeStreamId;

    if (attendeeStreamId) {
      return rxjs.of(attendeeStreamId);
    } else {
      return this.streams$.pipe(operators.map(() => this.attendeeStreamId), operators.filter(x => x));
    }
  }

  static getRemoteById(streamId) {
    // console.log('StreamService.getRemoteById', streamId);
    const remotes = StreamService.remotes;
    const remote = remotes.find(x => x.getId() === streamId);

    if (remote) {
      return remote;
    }
  }

  static remoteAdd(stream) {
    const remotes = this.remotes.slice();
    remotes.push(stream);
    this.remotes = remotes;
  }

  static remoteRemove(streamId) {
    const remotes = this.remotes.slice();
    const remote = remotes.find(x => x.getId() === streamId); // console.log('StreamService.remoteRemove', streamId, remote);

    if (remote) {
      if (remote.isPlaying()) {
        remote.stop();
      }

      remotes.splice(remotes.indexOf(remote), 1);
      this.remotes = remotes;
    }

    return remote;
  }

  static remoteSetClientInfo(remoteId, clientInfo) {
    const remotes = this.remotes;
    const remote = remotes.find(x => x.getId() === remoteId);

    if (remote) {
      remote.clientInfo = clientInfo;
    }

    this.remotes = remotes;
  }

}
StreamService.mode = StreamServiceMode.Client;
StreamService.editorStreams$ = new rxjs.BehaviorSubject(null);
StreamService.editorScreens$ = new rxjs.BehaviorSubject(null);
StreamService.local$ = new rxjs.BehaviorSubject(null);
StreamService.screen$ = new rxjs.BehaviorSubject(null);
StreamService.remotes$ = new rxjs.BehaviorSubject([]);
StreamService.peers$ = new rxjs.BehaviorSubject([]);
StreamService.streams$ = rxjs.combineLatest([StreamService.local$, StreamService.screen$, StreamService.remotes$, StreamService.getEditorStreams$(), StreamService.getEditorScreens$()]).pipe(operators.map(data => {
  const local = data[0];
  const screen = data[1];
  const remotes = data[2];
  const editorStreams = data[3];
  const editorScreens = data[4];
  let streams = remotes;

  if (local) {
    // my stream
    streams = streams.slice();
    streams.push(local);
  }

  if (screen) {
    // my screen
    streams = streams.slice();
    streams.push(screen);
  }

  if (editorStreams) {
    // editor streams
    streams.push(...editorStreams);
  }

  if (editorScreens) {
    // editor screens
    streams.push(...editorScreens);
  }

  return streams;
}), operators.shareReplay(1));/* global AgoraRTM */
class AgoraService extends Emittable$1 {
  static getSingleton(defaultDevices) {
    if (DEBUG) {
      return;
    }

    if (!this.AGORA) {
      this.AGORA = new AgoraService(defaultDevices);
    }

    return this.AGORA;
  }

  constructor(defaultDevices) {
    if (AgoraService.AGORA) {
      throw 'AgoraService is a singleton';
    }

    super();
    this.previousMuteAudio_ = false;
    this.onStreamPublished = this.onStreamPublished.bind(this);
    this.onStreamUnpublished = this.onStreamUnpublished.bind(this);
    this.onStreamAdded = this.onStreamAdded.bind(this);
    this.onStreamRemoved = this.onStreamRemoved.bind(this);
    this.onStreamSubscribed = this.onStreamSubscribed.bind(this);
    this.onMuteVideo = this.onMuteVideo.bind(this);
    this.onUnmuteVideo = this.onUnmuteVideo.bind(this);
    this.onMuteAudio = this.onMuteAudio.bind(this);
    this.onUnmuteAudio = this.onUnmuteAudio.bind(this);
    this.onVolumeIndicator = this.onVolumeIndicator.bind(this);
    this.onPeerConnect = this.onPeerConnect.bind(this);
    this.onPeerLeaved = this.onPeerLeaved.bind(this);
    this.onConnectionStateChange = this.onConnectionStateChange.bind(this);
    this.onTokenPrivilegeWillExpire = this.onTokenPrivilegeWillExpire.bind(this);
    this.onTokenPrivilegeDidExpire = this.onTokenPrivilegeDidExpire.bind(this);
    this.onMessage = this.onMessage.bind(this);
    const state = StateService.state;
    StateService.patchState({
      devices: state.role !== RoleType.Attendee && defaultDevices ? defaultDevices : {
        videos: [],
        audios: []
      },
      quality: getStreamQuality(state),
      membersCount: 0
    });
  }

  get isAudienceRole() {
    return StateService.state.role === RoleType.Viewer || StateService.state.role === RoleType.SelfService;
  }

  addStreamDevice(src) {
    this.removeStreamDevice();
    const video = {
      deviceId: 'video-stream',
      label: 'videostream',
      kind: 'videostream',
      src: src
    };
    const audio = {
      deviceId: 'audio-stream',
      label: 'videostream',
      kind: 'videostream',
      src: src
    };
    const devices = StateService.state.devices;
    devices.videos.push(video);
    devices.audios.push(audio);
    StateService.patchState({
      devices: devices
    });
  }

  removeStreamDevice() {
    const devices = StateService.state.devices;
    devices.videos = devices.videos.filter(x => x.kind !== 'videostream');
    devices.audios = devices.audios.filter(x => x.kind !== 'videostream');
    StateService.patchState({
      devices: devices
    });
  }

  devices$() {
    const inputs = StateService.state.devices;
    const defaultVideos = this.defaultVideos = this.defaultVideos || inputs.videos.slice();
    const defaultAudios = this.defaultAudios = this.defaultAudios || inputs.videos.slice();
    inputs.videos = defaultVideos.slice();
    inputs.audios = defaultAudios.slice();
    return rxjs.from(new Promise((resolve, reject) => {
      const getDevices = () => {
        AgoraService.getDevices().then(devices => {
          // console.log('AgoraRTC.getDevices', devices);
          tempStream.close();

          for (let i = 0; i < devices.length; i++) {
            const device = devices[i]; // console.log('device', device.deviceId);

            if (device.kind === 'videoinput' && device.deviceId) {
              inputs.videos.push({
                label: device.label || 'camera-' + inputs.videos.length,
                deviceId: device.deviceId,
                kind: device.kind
              });
            }

            if (device.kind === 'audioinput' && device.deviceId) {
              inputs.audios.push({
                label: device.label || 'microphone-' + inputs.audios.length,
                deviceId: device.deviceId,
                kind: device.kind
              });
            }
          }

          if (inputs.videos.length > 0 || inputs.audios.length > 0) {
            resolve(inputs);
          } else {
            reject(inputs);
          }
        }).catch(error => {
          reject(error);
        });
        /*
        AgoraRTC.getDevices((devices) => {
        	// console.log('AgoraRTC.getDevices', devices);
        	tempStream.close();
        	for (let i = 0; i < devices.length; i++) {
        		const device = devices[i];
        		// console.log('device', device.deviceId);
        		if (device.kind === 'videoinput' && device.deviceId) {
        			inputs.videos.push({
        				label: device.label || 'camera-' + inputs.videos.length,
        				deviceId: device.deviceId,
        				kind: device.kind
        			});
        		}
        		if (device.kind === 'audioinput' && device.deviceId) {
        			inputs.audios.push({
        				label: device.label || 'microphone-' + inputs.audios.length,
        				deviceId: device.deviceId,
        				kind: device.kind
        			});
        		}
        	}
        	if (inputs.videos.length > 0 || inputs.audios.length > 0) {
        		resolve(inputs);
        	} else {
        		reject(inputs);
        	}
        });
        */
      };

      const tempStream = AgoraRTC.createStream({
        audio: true,
        video: true
      });
      tempStream.init(() => {
        getDevices();
      }, () => {
        getDevices();
      });
    }));
  }

  connect$(preferences) {
    const devices = StateService.state.devices;

    if (preferences) {
      devices.video = preferences.video;
      devices.audio = preferences.audio;
    } // console.log('AgoraService.connect$', preferences, devices);


    if (!StateService.state.connecting) {
      StateService.patchState({
        status: AgoraStatus.Connecting,
        connecting: true,
        devices
      });
      setTimeout(() => {
        this.createClient(() => {
          const channelNameLink = this.getChannelNameLink();
          AgoraService.rtcToken$(channelNameLink).subscribe(token => {
            // console.log('AgoraService.rtcToken$', token);
            this.join(token.token, channelNameLink);
          });
        });
      }, 250);
    }

    return StateService.state$;
  }

  membersCount$(channelId) {
    const messageClient = this.messageClient;
    return rxjs.interval(2000).pipe(operators.switchMap(() => rxjs.from(messageClient.getChannelMemberCount([channelId]))), operators.map(counters => counters[channelId]), operators.catchError(error => {
      console.log('AgoraRTM', 'AgoraService.membersCount$.error', error);
      return rxjs.of(0);
    }), operators.distinctUntilChanged());
  }

  observeMemberCount() {
    this.unobserveMemberCount();
    this.membersCountSubscription = this.membersCount$(StateService.state.channelNameLink).subscribe(membersCount => {
      StateService.patchState({
        membersCount: membersCount
      });
    });
  }

  unobserveMemberCount() {
    if (this.membersCountSubscription) {
      this.membersCountSubscription.unsubscribe();
      this.membersCountSubscription = null;
      StateService.patchState({
        membersCount: 0
      });
    }
  }

  createClient(next) {
    if (this.client) {
      next();
    } // console.log('agora rtc sdk version: ' + AgoraRTC.VERSION + ' compatible: ' + AgoraRTC.checkSystemRequirements());
    // AgoraRTC.Logger.setLogLevel(AgoraRTC.Logger.ERROR);


    AgoraRTC.Logger.setLogLevel(AgoraRTC.Logger.NONE);
    const client = this.client = AgoraRTC.createClient({
      mode: 'live',
      codec: 'h264'
    }); // rtc

    const clientInit = () => {
      if (environment.flags.useProxy) {
        client.startProxyServer(3);
        console.log('AgoraService.client.startProxyServer');
      }

      client.init(environment.appKey, () => {
        console.log('AgoraRTC client initialized');
        next();
      }, error => {
        console.log('AgoraRTC client init failed', error);
        this.client = null;
      });
    };

    if (this.isAudienceRole) {
      client.setClientRole('audience', function (error) {
        if (!error) {
          clientInit();
        }
      });
    } else {
      clientInit();
    }

    client.on('error', this.onError);
    client.on('stream-published', this.onStreamPublished);
    client.on('stream-unpublished', this.onStreamUnpublished); //subscribe remote stream

    client.on('stream-added', this.onStreamAdded);
    client.on('stream-removed', this.onStreamRemoved);
    client.on('stream-subscribed', this.onStreamSubscribed);
    client.on('mute-video', this.onMuteVideo);
    client.on('unmute-video', this.onUnmuteVideo);
    client.on('mute-audio', this.onMuteAudio);
    client.on('unmute-audio', this.onUnmuteAudio);

    client.on('peer-online', this.onPeerConnect); // Occurs when the peer user leaves the channel; for example, the peer user calls Client.leave.

    client.on('peer-leave', this.onPeerLeaved); // client.on('connection-state-change', this.onConnectionStateChange);

    client.on('onTokenPrivilegeWillExpire', this.onTokenPrivilegeWillExpire);
    client.on('onTokenPrivilegeDidExpire', this.onTokenPrivilegeDidExpire); // console.log('agora rtm sdk version: ' + AgoraRTM.VERSION + ' compatible');

    {
      /*
      AgoraRTM.LOG_FILTER_OFF
      AgoraRTM.LOG_FILTER_ERROR
      AgoraRTM.LOG_FILTER_INFO (Default)
      AgoraRTM.LOG_FILTER_WARNING
      */
      const messageClient = this.messageClient = AgoraRTM.createInstance(environment.appKey, {
        logFilter: AgoraRTM.LOG_FILTER_OFF
      }); // LOG_FILTER_DEBUG

      messageClient.setParameters({
        logFilter: AgoraRTM.LOG_FILTER_OFF
      });
      console.log('AgoraRTM', 'client initialized'); // messageClient.on('ConnectionStateChanged', console.warn);
      // messageClient.on('MessageFromPeer', console.log);
    }
  }

  getChannelNameLink() {
    let link = StateService.state.link || '';
    const match = link.match(/(\d{9})-(\d{4})-(\d{13})/);

    if (match) {
      link = `${match[1]}-${match[3]}`;
    }

    const channelName = StateService.state.channelName;
    const channelNameLink = `${channelName}-${link}`; // console.log('AgoraService.getChannelNameLink', channelNameLink);

    return channelNameLink;
  }

  static getUniqueUserId() {
    const mult = 10000000000000;
    const a = (1 + Math.floor(Math.random() * 8)) * 100;
    const b = (1 + Math.floor(Math.random() * 8)) * 10;
    const c = (1 + Math.floor(Math.random() * 8)) * 1;
    const combo = a + b + c;
    const date = Date.now();
    const uid = combo * mult + date; // console.log(combo);
    // console.log(date);
    // console.log(m);
    // console.log('AgoraService.getUniqueUserId', uid);

    return uid.toString();
  }

  join(token, channelNameLink) {
    this.channel = null;
    const client = this.client;
    const clientId = SessionStorageService.get('bHereClientId') || AgoraService.getUniqueUserId();
    console.log('AgoraService.join', {
      token,
      channelNameLink,
      clientId
    });
    client.join(token, channelNameLink, clientId, uid => {
      // console.log('AgoraService.join', uid);
      StateService.patchState({
        status: AgoraStatus.Connected,
        channelNameLink,
        connected: true,
        uid: uid
      });
      SessionStorageService.set('bHereClientId', uid);

      {
        AgoraService.rtmToken$(uid).subscribe(token => {
          // console.log('AgoraService.rtmToken$', token);
          this.joinMessageChannel(token.token, uid).then(success => {
            // console.log('joinMessageChannel.success', success);
            if (!this.isAudienceRole) {
              this.autoDetectDevice().then(devices => {
                this.createMediaStream(uid, devices.video, devices.audio);
              });
            }

            this.observeMemberCount();
          }, error => {
            console.log('joinMessageChannel.error', error);
          });
        });
      }
    }, error => {
      console.log('AgoraService.join.error', error);

      if (error === 'DYNAMIC_KEY_EXPIRED') {
        AgoraService.rtcToken$(channelNameLink).subscribe(token => {
          this.join(token.token, channelNameLink);
        });
      }
    }); // https://console.agora.io/invite?sign=YXBwSWQlM0RhYjQyODlhNDZjZDM0ZGE2YTYxZmQ4ZDY2Nzc0YjY1ZiUyNm5hbWUlM0RaYW1wZXR0aSUyNnRpbWVzdGFtcCUzRDE1ODY5NjM0NDU=// join link expire in 30 minutes
  }

  joinMessageChannel(token, uid) {
    let channel;
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      console.log('AgoraRTM', 'AgoraService.joinMessageChannel', messageClient);
      messageClient.login({
        token: token,
        uid: uid.toString()
      }).then(() => {
        console.log('AgoraRTM', 'AgoraService.joinMessageChannel.login.success');
        channel = messageClient.createChannel(StateService.state.channelNameLink);
        return channel.join();
      }).then(() => {
        this.channel = channel;
        channel.on('ChannelMessage', this.onMessage);
        this.emit('channel', channel); // console.log('AgoraService.joinMessageChannel.success');

        resolve(uid);
        console.log('AgoraRTM', 'AgoraService.joinMessageChannel.join.success');
        channel.getMembers().then(members => {
          members = members.filter(x => x !== uid.toString());
          const message = {
            type: MessageType.ChannelMembers,
            members
          };
          this.broadcastMessage(message);
          console.log('AgoraRTM', 'AgoraService.joinMessageChannel.members', message);
        });
        console.log('AgoraRTM', 'AgoraService.joinMessageChannel', StateService.state.channelNameLink);
      }).catch(error => {
        console.log('AgoraRTM', 'AgoraService.joinMessageChannel.error', error);
        reject(error);
      });
    });
  }

  detectDevices(next) {
    AgoraService.getDevices().then(devices => {
      const videos = [];
      const audios = [];

      for (let i = 0; i < devices.length; i++) {
        const device = devices[i];

        if ('videoinput' == device.kind) {
          videos.push({
            label: device.label || 'camera-' + videos.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }

        if ('audioinput' == device.kind) {
          audios.push({
            label: device.label || 'microphone-' + videos.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
      }

      next({
        videos: videos,
        audios: audios
      });
    }).catch(error => {
      console.log('AgoraService.detectDevices', error);
    });
  }

  getVideoOptions(options, video) {
    return new Promise((resolve, reject) => {
      if (video) {
        if (video.kind === 'videostream') {
          const element = document.querySelector('#' + video.deviceId);
          element.crossOrigin = 'anonymous';
          var hls = new Hls();
          hls.attachMedia(element);
          hls.on(Hls.Events.MEDIA_ATTACHED, () => {
            hls.loadSource(video.src);
            hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
              // console.log('HlsDirective', data.levels);
              element.play().then(success => {
                const stream = element.captureStream();
                options.videoSource = stream.getVideoTracks()[0]; // console.log('AgoraService.getVideoOptions', element, stream, stream.getVideoTracks());

                resolve(options);
              }, error => {
                console.log('AgoraService.getVideoOptions.error', error);
              });
            });
          });
        } else if (video.kind === 'videoplayer' || video.kind === 'videostream') {
          const element = document.querySelector('#' + video.deviceId);
          element.crossOrigin = 'anonymous'; // element.oncanplay = () => {

          const stream = element.captureStream();
          options.videoSource = stream.getVideoTracks()[0]; // console.log('getVideoOptions', element, stream, stream.getVideoTracks());

          resolve(options); // };

          /*
          element.play().then(success => {
          	const stream = element.captureStream();
          	options.videoSource = stream.getVideoTracks()[0];
          	// console.log('getVideoOptions', element, stream, stream.getVideoTracks());
          	resolve(options);
          }, error => {
          	// console.log('AgoraService.getVideoOptions.error', error);
          });
          */
        } else {
          options.cameraId = video.deviceId;
          resolve(options);
        }
      } else {
        resolve(options);
      }
    });
  }

  getAudioOptions(options, audio) {
    return new Promise((resolve, reject) => {
      if (audio) {
        if (audio.kind === 'videostream') {
          const element = document.querySelector('#' + audio.deviceId);
          element.crossOrigin = 'anonymous'; // !!! try hls.service;

          var hls = new Hls();
          hls.attachMedia(element);
          hls.on(Hls.Events.MEDIA_ATTACHED, () => {
            hls.loadSource(audio.src);
            hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
              // console.log('HlsDirective', data.levels);
              hls.loadLevel = data.levels.length - 1;
              element.play().then(success => {
                const stream = element.captureStream();
                options.audioSource = stream.getAudioTracks()[0]; // console.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());

                resolve(options);
              }, error => {
                console.log('AgoraService.getAudioOptions.error', error);
              });
            });
          });
        } else if (audio.kind === 'videoplayer' || audio.kind === 'videostream') {
          const element = document.querySelector('#' + audio.deviceId);
          element.crossOrigin = 'anonymous'; // element.oncanplay = () => {

          const stream = element.captureStream();
          options.audioSource = stream.getAudioTracks()[0]; // console.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());

          resolve(options); // };

          /*
          element.play().then(success => {
          	const stream = element.captureStream();
          	options.audioSource = stream.getAudioTracks()[0];
          	// console.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());
          	resolve(options);
          }, error => {
          	// console.log('AgoraService.getAudioOptions.error', error);
          });
          */
        } else {
          options.microphoneId = audio.deviceId;
          resolve(options);
        }
      } else {
        resolve(options);
      }
    });
  }

  autoDetectDevice() {
    return new Promise((resolve, reject) => {
      const state = StateService.state;

      if (state.role === RoleType.SmartDevice || USE_AUTODETECT) {
        AgoraService.getDevices().then(inputDevices => {
          const devices = {
            videos: [],
            audios: [],
            video: null,
            audio: null
          };
          inputDevices.forEach(x => {
            if (x.kind === 'videoinput') {
              devices.videos.push(x);
            } else if (x.kind === 'audioinput') {
              devices.audios.push(x);
            }
          }); // console.log(inputDevices);
          // console.log(devices);

          devices.video = devices.videos[0] || null;
          devices.audio = devices.audios[0] || null;
          StateService.patchState({
            devices
          });
          resolve(devices);
        }).catch(error => {
          reject(error);
        });
      } else {
        resolve(state.devices);
      }
    });
  }

  createMediaStream(uid, video, audio) {
    // this.releaseStream('_mediaVideoStream')
    const options = {
      streamID: uid,
      video: Boolean(video),
      audio: Boolean(audio),
      screen: false
    };
    Promise.all([this.getVideoOptions(options, video), this.getAudioOptions(options, audio)]).then(success => {
      const quality = Object.assign({}, StateService.state.quality);
      this.createLocalStreamWithOptions(options, quality);
    });
  } // If you prefer video smoothness to sharpness, use setVideoProfile
  // to set the video resolution and Agora self-adapts the video bitrate according to the network condition.
  // If you prefer video sharpness to smoothness, use setVideoEncoderConfiguration,
  // and set min in bitrate as 0.4 - 0.5 times the bitrate value in the video profile table.


  createLocalStreamWithOptions(options, quality) {
    const local = AgoraRTC.createStream(options);

    if (quality) {
      local.setVideoProfile(quality.profile); // local.setVideoEncoderConfiguration(quality);
    } // console.log('AgoraService.createLocalStreamWithOptions', options, quality, local.attributes);


    local.init(() => {
      StreamService.local = local;
      setTimeout(() => {
        this.publishLocalStream();
      }, 1);
    }, error => {
      console.log('AgoraService.initLocalStream.init.error', error);
    });
  }

  initLocalStream() {
    const local = StreamService.local;
    local.init(() => {
      this.publishLocalStream();
    }, error => {
      console.log('AgoraService.initLocalStream.init.error', error);
    });
  }
  /*
  createMediaVideoStream(video, callback) {
  	const videoStream = video.captureStream(60);
  	const stream = AgoraRTC.createStream({
  		audio: true,
  		video: true,
  		videoSource: videoStream.getVideoTracks()[0],
  		audioSource: videoStream.getAudioTracks()[0],
  	});
  	stream.init(() => {
  		callback(stream.getVideoTrack(), stream.getAudioTrack());
  	});
  }
  */


  publishLocalStream() {
    const client = this.client;
    console.log('AgoraService.publishLocalStream');
    const local = StreamService.local; // publish local stream

    client.publish(local, error => {
      console.log('AgoraService.publishLocalStream.error', local.getId(), error);
    });
    local.clientInfo = {
      role: StateService.state.role,
      name: StateService.state.name,
      uid: StateService.state.uid,
      screenUid: StateService.state.screenUid
    };
    StreamService.local = local;
  }

  unpublishLocalStream() {
    const client = this.client;
    const local = StreamService.local;

    if (local) {
      client.unpublish(local, error => {
        console.log('AgoraService.unpublishLocalStream.error', local.getId(), error);
      });
    }

    StreamService.local = null;
  }

  leaveChannel() {
    StateService.patchState({
      connecting: false
    });
    this.unpublishLocalStream();
    this.unpublishScreenStream();
    StreamService.remotes = [];
    StreamService.peers = [];
    return new Promise((resolve, reject) => {
      this.leaveMessageChannel().then(() => {
        Promise.all([this.leaveClient(), this.leaveScreenClient()]).then(() => {
          resolve();
        }).catch(error => {
          reject(error);
        });
      }).catch(error => {
        reject(error);
      });
    });
  }

  leaveClient() {
    return new Promise((resolve, reject) => {
      const client = this.client;

      if (client) {
        client.leave(() => {
          this.client = null; // console.log('Leave channel successfully');

          if (environment.flags.useProxy) {
            client.stopProxyServer();
            console.log('AgoraService.client.stopProxyServer');
          }

          resolve();
        }, error => {
          console.log('AgoraService.leaveClient.error', error);
          reject(error);
        });
      } else {
        resolve();
      }
    });
  }

  leaveMessageChannel() {
    return new Promise((resolve, reject) => {
      {
        this.unobserveMemberCount();
        const channel = this.channel;

        if (!channel) {
          return resolve();
        }

        const messageClient = this.messageClient;
        channel.leave().then(() => {
          this.channel = null;
          messageClient.logout().then(() => {
            this.messageClient = null;
            resolve();
          }, reject);
        }, reject);
      }
    });
  }

  toggleCamera() {
    const local = StreamService.local; // console.log('toggleCamera', local);

    if (local && local.video) {
      if (local.userMuteVideo) {
        local.unmuteVideo();
        StateService.patchState({
          cameraMuted: false
        });
        this.broadcastEvent(new AgoraUnmuteVideoEvent({
          streamId: local.getId()
        }));
      } else {
        local.muteVideo();
        StateService.patchState({
          cameraMuted: true
        });
        this.broadcastEvent(new AgoraMuteVideoEvent({
          streamId: local.getId()
        }));
      }
    }
  }

  toggleAudio() {
    const local = StreamService.local; // console.log(local);

    if (local && local.audio) {
      if (local.userMuteAudio) {
        local.unmuteAudio();
        StateService.patchState({
          audioMuted: false
        });
        this.broadcastEvent(new AgoraUnmuteAudioEvent({
          streamId: local.getId()
        }));
      } else {
        local.muteAudio();
        StateService.patchState({
          audioMuted: true
        });
        this.broadcastEvent(new AgoraMuteAudioEvent({
          streamId: local.getId()
        }));
      }
    }
  }

  setAudio(audioMuted) {
    const local = StreamService.local;

    if (local && local.audio) {
      if (audioMuted) {
        this.previousMuteAudio_ = local.userMuteAudio;

        if (!local.userMuteAudio) {
          local.muteAudio();
          StateService.patchState({
            audioMuted: true
          });
          this.broadcastEvent(new AgoraMuteAudioEvent({
            streamId: local.getId()
          }));
        }
      } else {
        if (local.userMuteAudio && !this.previousMuteAudio_) {
          local.unmuteAudio();
          StateService.patchState({
            audioMuted: false
          });
          this.broadcastEvent(new AgoraUnmuteAudioEvent({
            streamId: local.getId()
          }));
        }
      }
    }
  }

  toggleMode() {
    const mode = StateService.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
    StateService.patchState({
      mode
    });
    MessageService.send({
      type: MessageType.Mode,
      mode: mode
    });
  }

  toggleNavInfo() {
    const showNavInfo = !StateService.state.showNavInfo;
    StateService.patchState({
      showNavInfo
    });
    MessageService.send({
      type: MessageType.NavInfo,
      showNavInfo: showNavInfo
    });
  }

  dismissControl() {
    return new Promise((resolve, _) => {
      const controllingId = StateService.state.controlling;

      if (controllingId) {
        this.sendRemoteControlDismiss(controllingId).then(() => {
          StateService.patchState({
            controlling: false
          });
          resolve(controllingId);
        });
      } else {
        resolve(false);
      }
    });
  }

  requestControl(controllingId) {
    return new Promise((resolve, _) => {
      this.sendRemoteControlRequest(controllingId).then(controllingId => {
        StateService.patchState({
          controlling: controllingId
        });
        resolve(controllingId);
      });
    });
  }

  toggleControl(controllingId) {
    this.dismissSpy().then(() => {
      this.dismissControl().then(dismissedControllingId => {
        if (dismissedControllingId !== controllingId) {
          this.requestControl(controllingId).then(controllingId => {// console.log('AgoraService.toggleControl', controllingId);
          });
        }
      });
    });
  }

  toggleSilence() {
    const silencing = !StateService.state.silencing;
    this.sendMessage({
      type: MessageType.RemoteSilencing,
      silencing: silencing
    });
    StateService.patchState({
      silencing
    });
  }

  dismissSpy() {
    return new Promise((resolve, _) => {
      const spyingId = StateService.state.spying;

      if (spyingId) {
        this.sendRemoteSpyDismiss(spyingId).then(() => {
          StateService.patchState({
            spying: false
          });
          resolve(spyingId);
        });
      } else {
        resolve(false);
      }
    });
  }

  requestSpy(spyingId) {
    return new Promise((resolve, _) => {
      this.sendSpyRemoteRequestInfo(spyingId).then(() => {
        StateService.patchState({
          spying: spyingId
        });
        resolve(spyingId);
      });
    });
  }

  toggleSpy(spyingId) {
    this.dismissControl().then(() => {
      this.dismissSpy().then(dismissedSpyingId => {
        if (dismissedSpyingId !== spyingId) {
          this.requestSpy(spyingId).then(spyingId => {
            console.log('AgoraService.toggleSpy', spyingId);
          });
        }
      });
    });
  }

  sendRemoteRequestPeerInfo(remoteId) {
    console.log('AgoraService.sendRemoteRequestPeerInfo', remoteId);
    return new Promise((resolve, reject) => {
      this.sendMessage({
        type: MessageType.RequestPeerInfo,
        messageId: this.newMessageId(),
        remoteId: remoteId
      }).then(message => {
        console.log('AgoraService.sendRemoteRequestPeerInfo.response', message);

        if (message.type === MessageType.RequestPeerInfoResult) {
          // !!! RequestPeerInfoResult Publisher
          if (message.clientInfo.role === RoleType.Publisher) {
            const state = {
              hosted: true
            };

            if (message.clientInfo.controllingId) {
              state.controlling = message.clientInfo.controllingId;
              state.mode = message.clientInfo.mode;
              this.sendControlRemoteRequestInfo(message.clientInfo.controllingId);
            }

            StateService.patchState(state);
          }

          resolve(message);
        }
      });
    });
  }

  sendRemoteControlRequest(controllingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestControl,
        messageId: this.newMessageId(),
        controllingId: controllingId
      }).then(message => {
        // console.log('AgoraService.sendRemoteControlRequest.response', message);
        // !!! always accepted
        if (message.type === MessageType.RequestControlAccepted) {
          resolve(controllingId);
        } else if (message.type === MessageType.RequestControlRejected) {
          // this.remoteDeviceInfo = undefined
          resolve(false);
        }
      });
    });
  }

  sendRemoteControlDismiss(controllingId) {
    // !!! can't dismiss if room is empty
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestControlDismiss,
        messageId: this.newMessageId(),
        controllingId: controllingId
      }).then(message => {
        // console.log('AgoraService.sendRemoteControlDismiss return', message);
        if (message.type === MessageType.RequestControlDismissed) {
          resolve(controllingId);
        } else if (message.type === MessageType.RequestControlRejected) {
          resolve(false);
        }
      });
    });
  }

  sendControlRemoteRequestInfo(controllingId) {
    return new Promise((resolve, reject) => {
      this.sendMessage({
        type: MessageType.RequestInfo,
        messageId: this.newMessageId(),
        remoteId: controllingId
      }).then(message => {
        // console.log('AgoraService.sendControlRemoteRequestInfo.response', message);
        if (message.type === MessageType.RequestInfoResult) {
          StateService.patchState({
            controlling: controllingId
          });
          resolve(message);
        }
      });
    });
  }

  sendSpyRemoteRequestInfo(spyingId) {
    return new Promise((resolve, reject) => {
      this.sendMessage({
        type: MessageType.RequestInfo,
        messageId: this.newMessageId(),
        remoteId: spyingId
      }).then(message => {
        // console.log('AgoraService.sendSpyRemoteRequestInfo.response', message);
        if (message.type === MessageType.RequestInfoResult) {
          StateService.patchState({
            spying: spyingId
          });
          resolve(message);
        }
      });
    });
  }

  sendRemoteSpyDismiss(spyingId) {
    return new Promise((resolve, reject) => {
      this.sendMessage({
        type: MessageType.RequestInfoDismiss,
        messageId: this.newMessageId(),
        remoteId: spyingId
      }).then(message => {
        // console.log('AgoraService.sendRemoteSpyDismiss.response', message);
        if (message.type === MessageType.RequestInfoDismissed) {
          resolve(spyingId);
        } else if (message.type === MessageType.RequestInfoRejected) {
          resolve(false);
        }
      });
    });
  }

  newMessageId() {
    return `${StateService.state.uid}-${Date.now().toString()}`;
  }

  navToView(viewId, keepOrientation, useLastOrientation) {
    if (keepOrientation === void 0) {
      keepOrientation = false;
    }

    if (useLastOrientation === void 0) {
      useLastOrientation = false;
    }

    if (StateService.state.controlling === StateService.state.uid || StateService.state.spying === StateService.state.uid) {
      this.sendMessage({
        type: MessageType.NavToView,
        viewId: viewId,
        keepOrientation: keepOrientation,
        useLastOrientation: useLastOrientation
      });
    }
  }

  getSessionStats() {
    const client = this.client;
    client.getSessionStats(stats => {
      console.log(`Current Session Duration: ${stats.Duration}`);
      console.log(`Current Session UserCount: ${stats.UserCount}`);
      console.log(`Current Session SendBytes: ${stats.SendBytes}`);
      console.log(`Current Session RecvBytes: ${stats.RecvBytes}`);
      console.log(`Current Session SendBitrate: ${stats.SendBitrate}`);
      console.log(`Current Session RecvBitrate: ${stats.RecvBitrate}`);
    });
  }

  getSystemStats() {
    const client = this.client;
    client.getSystemStats(stats => {
      console.log(`Current battery level: ${stats.BatteryLevel}`);
    });
  }

  sendMessage(message) {
    return new Promise((resolve, reject) => {
      if (StateService.state.connected) {
        message.clientId = StateService.state.uid;
        console.log('AgoraService.sendMessage');

        switch (message.type) {
          case MessageType.ControlInfo:
          case MessageType.NavToGrid:
          case MessageType.ShowPanel:
          case MessageType.PlayMedia:
          case MessageType.ZoomMedia:
          case MessageType.CurrentTimeMedia:
          case MessageType.PlayModel:
          case MessageType.Mode:
          case MessageType.NavInfo:
          case MessageType.NavLink:
          case MessageType.NavLinkClose:
            // console.log('AgoraService.sendMessage', StateService.state.uid, StateService.state.controlling, StateService.state.spying, StateService.state.controlling !== StateService.state.uid && StateService.state.spying !== StateService.state.uid);
            if (StateService.state.controlling !== StateService.state.uid && StateService.state.spying !== StateService.state.uid) {
              return;
            }

            break;
        } // message.wrc_version = 'beta';
        // message.uid = StateService.state.uid;


        const send = (message, channel) => {
          console.log('AgoraService.sendMessage', message);

          try {
            const text = JSON.stringify(message);

            if (message.messageId) {
              this.once(`message-${message.messageId}`, message => {
                resolve(message);
              });
            } // console.log('AgoraService.sendMessage.sending', message.type);


            channel.sendMessage({
              text: text
            }).then(() => {
              // console.log('AgoraService.sendMessage', text);
              if (!message.messageId) {
                resolve(message);
              }
            }).catch(error => {
              console.log('AgoraService.sendMessage.error', error);
            });
          } catch (error) {
            console.log('AgoraService.sendMessage.error', error); // reject(error);
          }
        };

        const channel = this.channel;

        if (channel) {
          send(message, channel);
        } else {
          try {
            this.once(`channel`, channel => {
              send(message, channel);
            });
          } catch (error) {
            console.log('AgoraService.sendMessage.error', error);
            reject(error);
          }
        }
      } else {
        console.log('AgoraService.sendMessage.error', 'not connected'); // console.log('StateService.state.connected', StateService.state.connected)
        // reject();
      }
    });
  }

  addOrUpdateChannelAttributes(messages) {
    const messageClient = this.messageClient;
    console.log('AgoraRTM', 'AgoraService.addOrUpdateChannelAttributes', messageClient);

    if (messageClient) {
      const attributes = {};
      messages.forEach(message => {
        const key = message.date.toString();
        attributes[key] = JSON.stringify(message);
      });

      if (Object.keys(attributes).length) {
        // console.log('AgoraService.setChannelAttributes', attributes);
        const promise = messageClient.addOrUpdateChannelAttributes(StateService.state.channelNameLink, attributes, {
          enableNotificationToChannelMembers: false
        });
        return rxjs.from(promise).pipe(tap(_ => {
          console.log('AgoraRTM', 'AgoraService.addOrUpdateChannelAttributes', _);
        }), operators.catchError(error => {
          console.log('AgoraRTM', 'AgoraService.addOrUpdateChannelAttributes.error', error);
          return rxjs.of(null);
        }));
      } else {
        return rxjs.of(null);
      }
    } else {
      return rxjs.of(null);
    }
  }

  getChannelAttributes() {
    const messageClient = this.messageClient;
    console.log('AgoraRTM', 'AgoraService.getChannelAttributes', messageClient);

    if (messageClient) {
      const promise = messageClient.getChannelAttributes(StateService.state.channelNameLink);
      return rxjs.from(promise).pipe(operators.map(attributes => Object.keys(attributes).map(key => attributes[key])), operators.map(attributes => {
        attributes.sort((a, b) => {
          return a.lastUpdateTs - b.lastUpdateTs;
        });
        const messages = attributes.map(attribute => {
          const message = JSON.parse(attribute.value); // console.log('AgoraService.getChannelAttributes.attribute', attribute, message);

          return message;
        });
        console.log('AgoraRTM', 'AgoraService.getChannelAttributes', messages);
        return messages;
      }), operators.catchError(error => {
        console.log('AgoraRTM', 'AgoraService.getChannelAttributes.error', error);
        return rxjs.of([]);
      }));
    } else {
      return rxjs.of(null);
    }
  }

  checkBroadcastMessage(message) {
    // filter for broadcast
    // !!! filter events here
    switch (message.type) {
      case MessageType.RequestControlDismiss:
        StateService.patchState({
          controlling: false
        });

        if (message.controllingId === StateService.state.uid) {
          this.unpublishScreenStream();
        }

        this.sendMessage({
          type: MessageType.RequestControlDismissed,
          messageId: message.messageId
        });
        break;

      case MessageType.RequestInfoDismiss:
        // console.log('checkBroadcastMessage.RequestInfoDismiss', message);
        StateService.patchState({
          spying: false
        });
        this.sendMessage({
          type: MessageType.RequestInfoDismissed,
          messageId: message.messageId,
          remoteId: message.remoteId
        });
        break;

      case MessageType.RequestInfoResult:
        // console.log('checkBroadcastMessage.RequestInfoResult', message);
        if (StateService.state.role === RoleType.Publisher) {
          this.broadcastMessage(message);
        } else if (StateService.state.controlling && StateService.state.controlling !== StateService.state.uid) {
          this.broadcastMessage(message);
        }

        break;

      case MessageType.RemoteSilencing:
        // only streamers can be silenced
        if (StateService.state.role === RoleType.Streamer) {
          this.broadcastMessage(message);
        }

        break;

      case MessageType.ControlInfo:
      case MessageType.ShowPanel:
      case MessageType.PlayMedia:
      case MessageType.ZoomMedia:
      case MessageType.CurrentTimeMedia:
      case MessageType.PlayModel:
      case MessageType.Mode:
      case MessageType.NavInfo:
      case MessageType.NavToView:
      case MessageType.NavToGrid:
      case MessageType.NavLink:
      case MessageType.NavLinkClose:
        if (StateService.state.controlling && StateService.state.controlling !== StateService.state.uid || StateService.state.spying && StateService.state.spying !== StateService.state.uid) {
          this.broadcastMessage(message);
        }

        break;

      default:
        this.broadcastMessage(message);
    }
  }

  broadcastMessage(message) {
    MessageService.out(message);
  }

  broadcastEvent(event) {
    MessageService.out({
      type: MessageType.AgoraEvent,
      event
    });
  }

  onMessage(data, uid) {
    // console.log('AgoraService.onMessage', data.text, uid, StateService.state.uid);
    // discard message delivered by current state uid;
    if (uid !== StateService.state.uid) {
      console.log('AgoraService.onMessage', data.text, uid);
      const message = JSON.parse(data.text);

      if (message.messageId && this.has(`message-${message.messageId}`)) {
        // !!! removed return
        this.emit(`message-${message.messageId}`, message);
      } // discard message delivered to specific remoteId when differs from current state uid;


      if (message.remoteId && message.remoteId !== StateService.state.uid && message.remoteId !== StateService.state.screenUid) {
        return;
      } // !!! check position !!!


      if (message.type === MessageType.VRStarted) {
        const container = document.createElement('div');
        container.classList.add('player__vr');
        message.container = container;
      }
      /*
      if (message.type === MessageType.VRStarted || message.type === MessageType.VREnded) {
      	// console.log('AgoraService.onMessage', message.type, message);
      }
      */


      this.checkBroadcastMessage(message);
    }
  }

  onError(error) {
    console.log('AgoraService.onError', error);
  }

  onStreamPublished(event) {
    console.log('AgoraService.onStreamPublished', event);
    const local = StreamService.local;
    local.clientInfo = {
      role: StateService.state.role,
      name: StateService.state.name,
      uid: StateService.state.uid,
      screenUid: StateService.state.screenUid
    };
    StreamService.local = local;
  }

  onStreamUnpublished(event) {
    // console.log('AgoraService.onStreamUnpublished');
    StreamService.local = null;
  }

  onStreamAdded(event) {
    console.log('AgoraService.onStreamAdded', event);
    const client = this.client;
    const stream = event.stream;

    if (!stream) {
      console.log('AgoraService.onStreamAdded.error', 'stream is undefined');
      return;
    }

    console.log('AgoraService.onStreamAdded', event.stream.getId());
    const streamId = stream.getId(); // console.log('AgoraService.onStreamAdded', streamId, StateService.state.uid, StateService.state.screenUid);

    if (streamId !== StateService.state.uid && streamId !== StateService.state.screenUid) {
      client.subscribe(stream, error => {
        console.log('AgoraService.onStreamAdded.subscribe.error', error);
      });
    }
  }

  onStreamRemoved(event) {
    const stream = event.stream;
    const streamId = stream.getId();

    if (streamId !== StateService.state.uid && streamId !== StateService.state.screenUid) {
      // !!! this happen on oculus removed timeout
      // console.log('AgoraService.onStreamRemoved', streamId);
      this.remoteRemove(streamId);
    }
  }

  onStreamSubscribed(event) {
    console.log('AgoraService.onStreamSubscribed', event.stream.getId());
    this.remoteAdd(event.stream);
  }

  onPeerConnect(event) {
    console.log('AgoraService.onPeerConnect', event);
    this.peerAdd(event);
  }

  onPeerLeaved(event) {
    const remoteId = event.uid;

    if (remoteId !== StateService.state.uid) {
      // console.log('AgoraService.onPeerLeaved', event.uid);
      const remote = this.remoteRemove(remoteId);

      if (remote.clientInfo) {
        // !!! remove screenRemote?
        if (remote.clientInfo.role === RoleType.Publisher) {
          if (StateService.state.role === RoleType.SelfService) {
            StateService.patchState({
              hosted: true,
              controlling: false,
              spying: false,
              silencing: false
            });
          } else {
            StateService.patchState({
              hosted: false,
              controlling: false,
              spying: false,
              silencing: false
            });
          }
        } else {
          if (StateService.state.controlling === remoteId) {
            StateService.patchState({
              controlling: false
            });
          }

          if (StateService.state.spying === remoteId) {
            StateService.patchState({
              spying: false
            });
          }
        }
      }
    }

    this.peerRemove(remoteId);
  }

  peerAdd(event) {
    const peer = {
      uid: event.uid
    };
    console.log('AgoraService.peerAdd', peer);
    const peers = StreamService.peers;
    peers.push(peer);
    StreamService.peers = peers;
    this.broadcastEvent(new AgoraPeerEvent({
      peer
    }));
  }

  peerRemove(peerId) {
    // console.log('AgoraService.peerRemove', peerId);
    const peers = StreamService.peers;
    const peer = peers.find(x => x.uid === peerId);

    if (peer) {
      peers.splice(peers.indexOf(peer), 1);
      StreamService.peers = peers;
    }
  }

  remoteAdd(stream) {
    console.log('AgoraService.remoteAdd', stream);
    StreamService.remoteAdd(stream);
    this.broadcastEvent(new AgoraRemoteEvent({
      stream
    }));
    const remoteId = stream.getId();
    this.sendRemoteRequestPeerInfo(remoteId).then(message => {
      StreamService.remoteSetClientInfo(remoteId, message.clientInfo);
    });
  }

  remoteRemove(streamId) {
    // console.log('AgoraService.remoteRemove', streamId);
    const remote = StreamService.remoteRemove(streamId);

    if (remote && remote.clientInfo && remote.clientInfo.role === RoleType.Publisher && remote.clientInfo.screenUid !== streamId) {
      StateService.patchState({
        hosted: false
      });
    }

    return remote;
  }

  onMuteVideo(event) {
    // console.log('AgoraService.onMuteVideo', event);
    this.broadcastEvent(new AgoraMuteVideoEvent({
      streamId: event.uid
    }));
  }

  onUnmuteVideo(event) {
    // console.log('AgoraService.onUnmuteVideo', event);
    this.broadcastEvent(new AgoraUnmuteVideoEvent({
      streamId: event.uid
    }));
  }

  onMuteAudio(event) {
    // console.log('AgoraService.onMuteAudio', event);
    this.broadcastEvent(new AgoraMuteAudioEvent({
      streamId: event.uid
    }));
  }

  onUnmuteAudio(event) {
    // console.log('AgoraService.onUnmuteAudio', event);
    this.broadcastEvent(new AgoraUnmuteAudioEvent({
      streamId: event.uid
    }));
  }

  onVolumeIndicator(event) {
    // console.log('AgoraService.onVolumeIndicator', event);
    const streams = event.attr.map(x => {
      return {
        streamId: x.uid,
        level: x.level
      };
    });
    this.broadcastEvent(new AgoraVolumeLevelsEvent({
      streams: streams
    }));
  }

  onConnectionStateChange(event) {
    console.log('AgoraService.onConnectionStateChange', event);
  }

  onTokenPrivilegeWillExpire(event) {
    console.log('AgoraService.onTokenPrivilegeWillExpire');
    const client = this.client;
    const channelNameLink = this.getChannelNameLink();
    AgoraService.rtcToken$(channelNameLink).subscribe(token => {
      if (token.token) {
        client.renewToken(token.token);
        console.log('AgoraService.onTokenPrivilegeWillExpire.renewed');
      }
    });
  }

  onTokenPrivilegeDidExpire(event) {
    console.log('AgoraService.onTokenPrivilegeDidExpire');
    const client = this.client;
    const channelNameLink = this.getChannelNameLink();
    AgoraService.rtcToken$(channelNameLink).subscribe(token => {
      if (token.token) {
        client.renewToken(token.token);
        console.log('AgoraService.onTokenPrivilegeDidExpire.renewed');
      }
    });
  } // screen


  toggleScreen() {
    const screen = StreamService.screen;

    if (screen) {
      this.unpublishScreenStream();
    } else {
      if (this.screenClient) {
        this.createScreenStream(StateService.state.screenUid);
      } else {
        this.createScreenClient(() => {
          const channelNameLink = this.getChannelNameLink();
          AgoraService.rtcToken$(channelNameLink).subscribe(token => {
            // console.log('AgoraService.rtcToken$', token);
            this.screenJoin(token.token, channelNameLink);
          });
        });
      }
    } // console.log(screen);

  }

  createScreenClient(next) {
    if (this.screenClient) {
      next();
    }

    const screenClient = this.screenClient = AgoraRTC.createClient({
      mode: 'live',
      codec: 'h264'
    }); // rtc, vp8

    const clientInit = () => {
      if (environment.flags.useProxy) {
        screenClient.startProxyServer(3);
        console.log('AgoraService.screenClient.startProxyServer');
      }

      screenClient.init(environment.appKey, () => {
        // console.log('AgoraRTC screenClient initialized');
        next();
      }, error => {
        // console.log('AgoraRTC client init failed', error);
        this.screenClient = null;
      });
    };

    clientInit();
    screenClient.on('error', this.onScreenError);
    screenClient.on('stream-published', this.onScreenStreamPublished);
    screenClient.on('stream-unpublished', this.onScreenStreamUnpublished); // only for remotes
    // screenClient.on('stream-added', this.onScreenStreamAdded);
    // screenClient.on('stream-removed', this.onScreenStreamRemoved);
    // screenClient.on('stream-subscribed', this.onScreenStreamSubscribed);
    // screenClient.on('peer-online', this.onScreenPeerConnect);
    // screenClient.on('peer-leave', this.onScreenPeerLeaved);
    // screenClient.on('onTokenPrivilegeWillExpire', this.onScreenTokenPrivilegeWillExpire);
    // screenClient.on('onTokenPrivilegeDidExpire', this.onScreenTokenPrivilegeDidExpire);
  }

  screenJoin(token, channelNameLink) {
    const screenClient = this.screenClient;
    const screenClientId = AgoraService.getUniqueUserId(); // const screenClientId = SessionStorageService.get('bHereClientId') || AgoraService.getUniqueUserId();
    // console.log('AgoraService.screenJoin', { token, channelNameLink, screenClientId });

    screenClient.join(token, channelNameLink, screenClientId, screenUid => {
      // console.log('AgoraService.join', screenUid);
      StateService.patchState({
        screenUid
      });
      this.createScreenStream(screenUid);
    }, error => {
      console.log('AgoraService.screenJoin.error', error);

      if (error === 'DYNAMIC_KEY_EXPIRED') {
        AgoraService.rtcToken$(channelNameLink).subscribe(token => {
          this.screenJoin(token.token, channelNameLink);
        });
      }
    });
  }

  createScreenStream(screenUid) {
    const options = {
      streamID: screenUid,
      audio: false,
      video: false,
      screen: true // extensionId: 'minllpmhdgpndnkomcoccfekfegnlikg', // Google Chrome:
      // mediaSource:  'screen', // Firefox: 'screen', 'application', 'window' (select one)

    };
    /*
    // Set relevant properties according to the browser.
    // Note that you need to implement isFirefox and isCompatibleChrome.
    if (isFirefox()) {
    	options.mediaSource = 'window';
    } else if (!isCompatibleChrome()) {
    	options.extensionId = 'minllpmhdgpndnkomcoccfekfegnlikg';
    }
    */

    const stream = AgoraRTC.createStream(options);
    /*
    const quality = Object.assign({}, StateService.state.quality);
    console.log('AgoraService.createScreenStream', quality);
    if (quality) {
    	// stream.setVideoProfile(quality.profile);
    	// stream.setVideoEncoderConfiguration(quality);
    }
    */

    stream.setScreenProfile(environment.profiles.screen);
    console.log('AgoraService.createScreenStream', options);

    const onStopScreenSharing = () => {
      this.unpublishScreenStream();
    }; // Initialize the stream.


    stream.init(() => {
      StreamService.screen = stream;
      stream.on('stopScreenSharing', onStopScreenSharing);
      stream.muteAudio();
      setTimeout(() => {
        this.publishScreenStream();
      }, 1);
    }, function (error) {
      console.log('AgoraService.createScreenStream.screen.init.error', error);
    });
  }

  publishScreenStream() {
    const screenClient = this.screenClient;
    const screen = StreamService.screen; // publish screen stream

    screenClient.publish(screen, error => {
      console.log('AgoraService.publishScreenStream.error', screen.getId(), error);
    });
    screen.clientInfo = {
      role: StateService.state.role,
      name: StateService.state.name,
      uid: StateService.state.uid,
      screenUid: StateService.state.screenUid
    };
    StreamService.screen = screen;
  }

  unpublishScreenStream() {
    const screenClient = this.screenClient;
    const screen = StreamService.screen; // console.log('AgoraService.unpublishScreenStream', screen, screenClient);

    if (screenClient && screen) {
      screenClient.unpublish(screen, error => {
        console.log('AgoraService.unpublishScreenStream.error', screen.getId(), error);
      });
    }

    StreamService.screen = null;
  }

  leaveScreenClient() {
    return new Promise((resolve, reject) => {
      const screenClient = this.screenClient;

      if (screenClient) {
        screenClient.leave(() => {
          this.screenClient = null; // console.log('Leave channel successfully');

          if (environment.flags.useProxy) {
            screenClient.stopProxyServer();
            console.log('AgoraService.screenClient.stopProxyServer');
          }

          resolve();
        }, error => {
          console.log('AgoraService.leaveScreenClient.error', error);
          reject(error);
        });
      } else {
        resolve();
      }
    });
  }

  onScreenError(error) {
    console.log('AgoraService.onScreenError', error);
  }

  onScreenStreamPublished(event) {
    // console.log('AgoraService.onScreenStreamPublished');
    const screen = StreamService.screen;
    screen.clientInfo = {
      role: StateService.state.role,
      name: StateService.state.name,
      uid: StateService.state.uid,
      screenUid: StateService.state.screenUid
    };
    StreamService.screen = screen;
  }

  onScreenStreamUnpublished(event) {
    // console.log('AgoraService.onScreenStreamUnpublished');
    StreamService.screen = null;
  } // tokens


  static rtcToken$(channelNameLink) {
    if (environment.flags.useToken) {
      return HttpService.post$('/api/token/rtc', {
        channelName: channelNameLink,
        uid: null
      });
    } else {
      return rxjs.of({
        token: null
      });
    }
  }

  static rtmToken$(uid) {
    if (environment.flags.useToken) {
      return HttpService.post$('/api/token/rtm', {
        uid: uid
      });
    } else {
      return rxjs.of({
        token: null
      });
    }
  } // checks


  static checkRtcConnection() {
    return new Promise((resolve, reject) => {
      try {
        const client = AgoraRTC.createClient({
          mode: 'live',
          codec: 'h264'
        });

        if (environment.flags.useProxy) {
          client.startProxyServer(3);
        }

        client.init(environment.appKey, () => {
          AgoraService.checkRtcTryJoin(client).then(uid => {
            resolve(uid);
          }).catch(error => {
            reject(error);
          }).finally(() => {
            // clear
            client.leave(() => {
              if (environment.flags.useProxy) {
                client.stopProxyServer();
              }
            }, () => {});
          });
        }, error => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  static checkRtcTryJoin(client) {
    return new Promise((resolve, reject) => {
      const channelName = 'checkRtcConnection';
      AgoraService.rtcToken$(channelName).subscribe(token => {
        client.join(token.token, channelName, null, uid => {
          // this.createMediaStream(uid, StateService.state.devices.video, StateService.state.devices.audio);
          resolve(uid);
        }, error => {
          if (error === 'DYNAMIC_KEY_EXPIRED') {
            return AgoraService.checkRtcTryJoin(client);
          } else {
            console.log('AgoraService.checkRtcConnection.error', error);
            reject(error);
          }
        });
      }, error => reject(error));
    });
  }

  static checkRtmConnection(uid) {
    return new Promise((resolve, reject) => {

      try {
        let client = AgoraRTM.createInstance(environment.appKey, {
          logFilter: AgoraRTM.LOG_FILTER_OFF
        });
        client.setParameters({
          logFilter: AgoraRTM.LOG_FILTER_OFF
        });
        let channel;
        AgoraService.rtmToken$(uid).subscribe(token => {
          // console.log('AgoraService.rtmToken$', token);
          const channelName = 'checkRtcConnection';
          client.login({
            token: token.token,
            uid: uid.toString()
          }).then(() => {
            channel = client.createChannel(channelName);
            channel.join().then(() => {
              resolve(uid);
              channel.leave();
            }).catch(error => {
              reject(error);
            }).finally(() => {
              // clear
              channel.leave().then(() => {
                channel = null;
                client.logout().then(() => {
                  client = null;
                }).catch(() => {});
              }).catch(() => {});
            });
          }).catch(error => {
            console.log('checkRtmConnection.error', error);
            reject(error);
          }).finally(() => {
            // clear
            if (client) {
              client.logout().then(() => {
                client = null;
              }).catch(() => {});
            }
          });
        }, error => reject(error));
      } catch (error) {
        reject(error);
      }
    });
  }

  static getDevices() {
    return new Promise((resolve, reject) => {
      let devices_ = AgoraService.devices_;

      if (devices_) {
        resolve(devices_);
      } else {
        devices_ = AgoraService.devices_ = [];
        const constraints = {
          audio: true,
          video: true
        };

        if (DeviceService.platform === DevicePlatform.IOS) {
          constraints.video = {
            facingMode: 'user'
          };
        }

        if (DeviceService.platform === DevicePlatform.VRHeadset) {
          constraints.video = false;
        }

        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          navigator.mediaDevices.getUserMedia(constraints).then(stream => {
            navigator.mediaDevices.enumerateDevices().then(devices => {
              stream.getTracks().forEach(track => {
                track.stop();
              });
              devices.forEach(device => {
                devices_.push(device);
              });
              resolve(devices_);
            }).catch(error => {
              reject(error);
            });
          }).catch(error => {
            reject(error);
          });
        } else {
          reject('Media device not available');
        }
      }
    });
  }

  static fixLegacy() {
    const prefixes = ['moz', 'webkit'];
    prefixes.forEach(prefix => {
      console.log('AgoraService', `fixing legacy ${prefix}RTC`);
      Object.getOwnPropertyNames(window).filter(key => key.indexOf('RTC') === 0).map(key => {
        const legacyKey = `${prefix}${key}`;

        if (typeof window[key] !== 'undefined' && typeof window[legacyKey] === 'undefined') {
          window[legacyKey] = window[key]; // console.log(key, '->', legacyKey);
        }
      });
    });
  }

}const USE_RANDOM_MESSAGE = false;
class ChatMessage {
  constructor(message, clientId, name) {
    this.type = MessageType.ChatMessage;
    this.clientId_ = clientId;

    if (typeof message === 'string') {
      this.date = Date.now();
      this.clientId = clientId;
      this.name = name;
      this.message = message;
    } else if (typeof message === 'object') {
      this.date = message.date;
      this.clientId = message.clientId;
      this.name = message.name;
      this.message = message.message;
    }

    const names = this.name.split(' ');
    this.shortName = names[0].substr(0, 1).toUpperCase() + (names.length > 1 ? names[1] : names[0]).substr(0, 1).toUpperCase();
  }

  get me() {
    return this.clientId === this.clientId_;
  }

  getPayload() {
    return {
      date: this.date,
      clientId: this.clientId,
      name: this.name,
      message: this.message
    };
  }

  getCopy() {
    return new ChatMessage({
      date: this.date,
      clientId: this.clientId,
      name: this.name,
      message: this.message
    }, this.clientId_);
  }

}
class AgoraChatComponent extends rxcomp.Component {
  onInit() {
    this.rows = 1;
    this.showEmoji = false;
    this.demo = window.location.pathname.indexOf('layout') !== -1;
    const form = this.form = new rxcompForm.FormGroup({
      message: null
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraChatComponent.changes$', form.value);
      this.checkTypings(changes);
      this.pushChanges();
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {// console.log('AgoraChatComponent.state', state);
    });
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // console.log('AgoraChatComponent.MessageService', message);
      switch (message.type) {
        case MessageType.ChatMessage:
          this.pushMessage(new ChatMessage(message, StateService.state.uid, StateService.state.name));
          break;

        case MessageType.ChatTypingBegin:
          this.typingBegin(message);
          break;

        case MessageType.ChatTypingEnd:
          this.typingEnd(message);
          break;
      }
    });
    this.messages = [];
    this.groupedMessages = [];

    if (this.demo) {
      // !!! only for demo
      const messages = AgoraChatComponent.getFakeList().map(x => new ChatMessage(x, StateService.state.uid, StateService.state.name));
      this.updateMessages(messages.slice(0, 5));
      MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
        message.clientId = message.clientId || StateService.state.uid; // console.log('AgoraChatComponent.MessageService.in$', message);

        switch (message.type) {
          case MessageType.ChatMessage:
            break;

          case MessageType.ChatTypingBegin:
            MessageService.out(message);
            break;

          case MessageType.ChatTypingEnd:
            MessageService.out(message);
            break;
        }
      });

    } else {
      const agora = this.agora = AgoraService.getSingleton();

      if (agora) {
        agora.getChannelAttributes().pipe(operators.first()).subscribe(messages => {
          messages = messages.map(x => new ChatMessage(x, StateService.state.uid, StateService.state.name)); // console.log('AgoraChatComponent.getChannelAttributes.messages', messages);

          this.updateMessages(messages);
        });
      }
    }
  }

  onView() {// this.scrollToBottom();
  }

  onChanges() {// this.scrollToBottom();
  }

  onDestroy() {
    if (AgoraChatComponent.to) {
      clearTimeout(AgoraChatComponent.to);
      AgoraChatComponent.to = null;
    }
  }

  onSubmit() {
    const secureMessage = this.secureText(this.form.value.message); // console.log('secureMessage', secureMessage);

    const message = this.createMessage(secureMessage);
    this.sendMessage(message);
    this.form.get('message').value = null;

    if (this.demo && USE_RANDOM_MESSAGE) {
      this.randomMessage();
    }
  }

  onKeyDown(event) {
    // console.log('onKeyDown', event);
    if (event.key === 'Enter') {
      if (event.shiftKey) {
        this.rows = Math.min(4, this.rows + 1);
        this.pushChanges();
      } else {
        event.preventDefault();
        this.onSubmit();
        this.rows = 1;
      }

      const {
        node
      } = rxcomp.getContext(this);
      const textareaNode = node.querySelector('textarea');
      textareaNode.setAttribute('rows', this.rows);
    }
  }

  onToggleEmoji() {
    this.showEmoji = !this.showEmoji;
    this.pushChanges();
  }

  onSelectEmoji(emoji) {
    this.showEmoji = false;
    this.form.get('message').value = (this.form.get('message').value || '') + emoji.char; // this.pushChanges();
  }

  secureText(unsecureText) {
    let newDocument = new DOMParser().parseFromString(unsecureText, 'text/html');
    return newDocument.body.textContent || '';
  }

  createMessage(text) {
    const message = new ChatMessage(text, StateService.state.uid, StateService.state.name);
    return message;
  }

  sendMessage(message) {
    this.pushMessage(message);
    const agora = this.agora;

    if (agora) {
      agora.addOrUpdateChannelAttributes([message.getPayload()]).pipe(operators.first()).subscribe();
    }

    MessageService.send(message);
  }

  onClose(event) {
    this.close.next();
  }

  scrollToBottom() {
    const {
      node
    } = rxcomp.getContext(this);
    const scrollView = node.querySelector('.group--scrollview');
    scrollView.scrollTop = scrollView.scrollHeight;
  }

  pushMessage(message) {
    const messages = this.messages ? this.messages.slice() : [];
    this.removeTyping({
      type: MessageType.ChatTypingBegin,
      clientId: message.clientId
    }, this.messages);
    messages.push(message);
    this.updateMessages(messages);
  }

  typingBegin(message) {
    // console.log('AgoraChatComponent.typingBegin', message);
    const messages = this.messages ? this.messages.slice() : [];
    messages.push(message);
    this.updateMessages(messages);
  }

  typingEnd(message) {
    // console.log('AgoraChatComponent.typingEnd', message);
    const messages = this.messages ? this.messages.slice() : [];
    this.removeTyping({
      type: MessageType.ChatTypingBegin,
      clientId: message.clientId
    }, messages);
    this.updateMessages(messages);
  }

  removeTyping(message, messages, recursive) {
    if (recursive === void 0) {
      recursive = true;
    }

    const index = messages.reduce((p, c, i) => {
      return c.type === message.type && c.clientId === message.clientId ? i : p;
    }, -1);

    if (index !== -1) {
      messages.splice(index, 1);

      if (recursive === true) {
        this.removeTyping(message, messages, true);
      }
    }

    return index;
  }

  checkTypings(changes) {
    const typings = changes.message && changes.message.length > 0; // console.log('AgoraChatComponent.checkTypings', typings);

    if (this.typings_ !== typings) {
      this.typings_ = typings;

      if (typings) {
        MessageService.send({
          type: MessageType.ChatTypingBegin
        });
      } else {
        MessageService.send({
          type: MessageType.ChatTypingEnd
        });
      }
    }
  }

  updateMessages(messages) {
    this.messages = messages;

    {
      this.groupedMessages = [];
      this.pushChanges();
    }

    const groupedMessages = [];
    messages.forEach(message => {
      if (message.type === MessageType.ChatMessage) {
        // ChatMessage
        const lastMessage = groupedMessages.length ? groupedMessages[groupedMessages.length - 1] : null;

        if (lastMessage && lastMessage.clientId === message.clientId) {
          lastMessage.message += `<p>${message.message}</p>`;
        } else {
          groupedMessages.push(message.getCopy());
        }
      } else if (message.type === MessageType.ChatTypingBegin) {
        // ChatTypingBegin
        const lastMessage = groupedMessages.reduce((p, c, i) => {
          return c.clientId === message.clientId ? c : p;
        }, null);

        if (lastMessage) {
          lastMessage.typing = true;
        } // console.log('MessageType.ChatTypingBegin', lastMessage, message);

      }
    }); // setTimeout(() => {

    this.groupedMessages = groupedMessages;
    this.pushChanges(); // console.log('AgoraChatComponent.updateMessages', messages, groupedMessages);

    setTimeout(() => {
      this.scrollToBottom();
    }, 1); // }, 1);
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid && this.form.value.message && this.form.value.message.length > 0;
  } // demo


  randomMessage() {
    if (AgoraChatComponent.to) {
      clearTimeout(AgoraChatComponent.to);
      AgoraChatComponent.to = null;
    }

    AgoraChatComponent.to = setTimeout(() => {
      const message = AgoraChatComponent.createRandomMessage();
      this.sendMessage(message);
    }, (2 + Math.random() * 6) * 1000);
  }

}
AgoraChatComponent.meta = {
  selector: '[agora-chat]',
  outputs: ['close'],
  template:
  /* html */
  `
		<div class="group--scrollview" [class]="'rows--' + rows">
			<div class="group--virtual" *virtual="let item of groupedMessages" [mode]="4" [width]="350" [gutter]="0" [reverse]="true">
				<!-- serve un nodo figlio -->
				<div class="listing__item message" [class]="{ me: item.me, typing: item.typing }">
					<div class="message__avatar" [title]="item.name"><span [innerHTML]="item.shortName"></span></div>
					<div class="message__content">
						<div [innerHTML]="item.message | message"></div>
						<div class="typing-indicator">
							<span></span>
							<span></span>
							<span></span>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="group--message" [class]="'rows--' + rows">
			<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit($event)" name="form" role="form" novalidate autocomplete="off">
				<div class="group--form group--form--addon" [class]="{ required: controls.message.validators.length, 'addon': controls.message.valid }">
					<!-- <input type="text" class="control--text" [formControl]="controls.message" [placeholder]="'bhere_write_a_message' | label" /> -->
					<button type="button" class="control--pre" (click)="onToggleEmoji()">
						<svg class="emoji" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#emoji"></use></svg>
					</button>
					<textarea class="control--text" [formControl]="controls.message" [placeholder]="'bhere_write_a_message' | label" rows="1" (keydown)="onKeyDown($event)"></textarea>
					<button type="submit" class="control--addon">
						<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#send"></use></svg>
					</button>
				</div>
			</form>
		</div>
		<div class="group--close">
			<button type="button" class="btn--close" [title]="'title_close' | label" (click)="onClose($event)">
				<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="group--emoji" [class]="'rows--' + rows" agora-chat-emoji (emoji)="onSelectEmoji($event)" (close)="onToggleEmoji()" *if="showEmoji">
			<div class="group--virtual" *virtual="let item of items" [mode]="1" [width]="40" [gutter]="10" [reverse]="true">
				<!-- serve un nodo figlio -->
				<div class="listing__item emoji">
					<button type="button" class="btn--emoji" (click)="onSelect(item)"><span [innerHTML]="item.char"></span></button>
				</div>
			</div>
			<div class="group--close">
				<button type="button" class="btn--close" [title]="'title_close' | label" (click)="onClose($event)">
					<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
				</button>
			</div>
		</div>
	`
};

AgoraChatComponent.getFakeList = () => {
  let messages = [{
    "date": 1614592230000,
    "name": "Jhon Appleseed",
    "message": "Function-based web-enabled benchmark",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592240000,
    "name": "Jhon Appleseed",
    "message": "Customizable exuding superstructure",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592250000,
    "name": "Gilles Pitkins",
    "message": "Synergistic interactive archive",
    "clientId": "cfe9ff5b-f7da-449d-bf5a-3184b5eba6ea"
  }, {
    "date": 1614592260000,
    "name": "Jhon Appleseed",
    "message": "Digitized client-server initiative",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592270000,
    "name": "Jhon Appleseed",
    "message": "Quality-focused tertiary open system",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592280000,
    "name": "Jhon Appleseed",
    "message": "Exclusive uniform middleware",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592290000,
    "name": "John Pruckner",
    "message": "Decentralized disintermediate extranet",
    "clientId": "ae51e846-d043-41e9-bb5c-3189181e5b43"
  }, {
    "date": 1614592300000,
    "name": "Lamont Georgievski",
    "message": "Enhanced static approach",
    "clientId": "1961cd9e-93aa-4bd0-b96a-89fcbd36b257"
  }, {
    "date": 1614592310000,
    "name": "Jhon Appleseed",
    "message": "Ergonomic clear-thinking info-mediaries",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592320000,
    "name": "Jeri Pedroni",
    "message": "Grass-roots dynamic encryption",
    "clientId": "13d69bba-3656-449b-8fe3-d7a87062b044"
  }, {
    "date": 1614592330000,
    "name": "Frederik Dechelle",
    "message": "Compatible disintermediate policy",
    "clientId": "9151ebe0-efa8-40b4-a341-b8fd489e9c88"
  }, {
    "date": 1614592340000,
    "name": "Jhon Appleseed",
    "message": "Inverse user-facing adapter",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592350000,
    "name": "Jhon Appleseed",
    "message": "Future-proofed even-keeled application",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592360000,
    "name": "Cassie Jonathon",
    "message": "Profit-focused content-based budgetary management",
    "clientId": "5b3dc6f3-2a3d-493d-aac5-66ddfce2d709"
  }, {
    "date": 1614592370000,
    "name": "Jhon Appleseed",
    "message": "Managed intermediate monitoring",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592380000,
    "name": "Jhon Appleseed",
    "message": "Exclusive client-server encoding",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592390000,
    "name": "Jhon Appleseed",
    "message": "Cross-group system-worthy matrices",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592400000,
    "name": "Jhon Appleseed",
    "message": "Upgradable encompassing benchmark",
    "clientId": "7341614597544882"
  }, {
    "date": 1614592410000,
    "name": "Emelen Beevors",
    "message": "Function-based full-range knowledge base",
    "clientId": "c93aea47-ebd8-4e5e-88fd-52053dd35cd1"
  }, {
    "date": 1614592420000,
    "name": "Jhon Appleseed",
    "message": "Synergistic system-worthy capability",
    "clientId": "7341614597544882"
  }];

  while (messages.length < 100) {
    messages = messages.concat(messages);
  }

  return messages; // return messages.slice(0, 5);
};

AgoraChatComponent.createRandomMessage = text => {
  const message = new ChatMessage({
    date: Date.now(),
    clientId: '9fe0e1b9-6a6b-418b-b916-4bbff3eeb123',
    name: 'Herman frederick',
    message: 'Lorem ipsum dolor'
  }, StateService.state.uid, StateService.state.name);
  return message;
};

AgoraChatComponent.randomMessage = (instance, messages) => {
  const getRandomMessage = function () {
    const others = messages.filter(x => x.id !== '7341614597544882');
    let message = others[Math.floor(others.length * Math.random())];
    message = new ChatMessage({
      date: Date.now(),
      clientId: '9fe0e1b9-6a6b-418b-b916-4bbff3eeb123',
      name: message.name,
      message: message.message
    }, StateService.state.uid, StateService.state.name);
    return message;
  };

  if (AgoraChatComponent.to) {
    clearTimeout(AgoraChatComponent.to);
    AgoraChatComponent.to = null;
  }

  AgoraChatComponent.to = setTimeout(() => {
    const message = getRandomMessage();
    instance.sendMessage(message);
    AgoraChatComponent.randomMessage(instance, messages);
  }, (2 + Math.random() * 6) * 1000);
};class AgoraCheckComponent extends rxcomp.Component {}
AgoraCheckComponent.meta = {
  selector: '[agora-check]',
  inputs: ['value'],
  template:
  /* html */
  `
		<svg *if="value == null" class="checkmark idle" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
		</svg>
		<svg *if="value === true" class="checkmark success" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
			<path class="checkmark__icon" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8" stroke-linecap="round"/>
		</svg>
		<svg *if="value === false" class="checkmark error" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
			<path class="checkmark__icon" stroke-linecap="round" fill="none" d="M16 16 36 36 M36 16 16 36"/>
		</svg>
	`
};class ModalEvent {
  constructor(data) {
    this.data = data;
  }

}
class ModalResolveEvent extends ModalEvent {}
class ModalRejectEvent extends ModalEvent {}
class ModalService {
  static get hasModal() {
    return this.hasModal_;
  }

  static set hasModal(hasModal) {
    if (this.hasModal_ !== hasModal) {
      this.hasModal_ = hasModal;
      const body = document.querySelector('body');
      hasModal ? body.classList.add('modal-open') : body.classList.remove('modal-open');
    }
  }

  static open$(modal) {
    this.busy$.next(true);
    return (modal.iframe ? rxjs.of(
    /* html */
    `<div class="iframe-modal" iframe-modal src="${modal.iframe}"></div>`) : this.getTemplate$(modal)).pipe( // startWith(new ModalLoadEvent(Object.assign({}, modal.data, { $src: modal.src }))),
    operators.map(template => {
      return {
        node: this.getNode(template),
        data: modal.data,
        modal: modal
      };
    }), operators.tap(node => {
      this.modal$.next(node);
      this.hasModal = true;
      this.busy$.next(false); // this.events$.next(new ModalLoadedEvent(Object.assign({}, modal.data, { $src: modal.src })));
    }), operators.switchMap(node => this.events$), operators.tap(_ => this.hasModal = false));
  }

  static getTemplate$(modal) {
    if (modal.src) {
      return rxjs.from(fetch(modal.src).then(response => {
        return response.text();
      }));
    } else if (modal.template) {
      return rxjs.of(modal.template);
    } else {
      return EMPTY;
    }
  }

  static getNode(template) {
    const div = document.createElement('div');
    div.innerHTML = template;
    const node = div.firstElementChild;
    return node;
  }

  static reject(data) {
    this.modal$.next(null);
    this.events$.next(new ModalRejectEvent(data));
  }

  static resolve(data) {
    this.modal$.next(null);
    this.events$.next(new ModalResolveEvent(data));
  }

}
ModalService.modal$ = new rxjs.Subject();
ModalService.events$ = new rxjs.Subject();
ModalService.busy$ = new rxjs.Subject();class LocalStorageService {
  static delete(name) {
    if (this.isLocalStorageSupported()) {
      window.localStorage.removeItem(name);
    }
  }

  static exist(name) {
    if (this.isLocalStorageSupported()) {
      return window.localStorage[name] !== undefined;
    }
  }

  static get(name) {
    let value = null;

    if (this.isLocalStorageSupported() && window.localStorage[name] !== undefined) {
      try {
        value = JSON.parse(window.localStorage[name]);
      } catch (e) {
        console.log('LocalStorageService.get.error parsing', name, e);
      }
    }

    return value;
  }

  static set(name, value) {
    if (this.isLocalStorageSupported()) {
      try {
        const cache = [];
        const json = JSON.stringify(value, function (key, value) {
          if (typeof value === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            }

            cache.push(value);
          }

          return value;
        });
        window.localStorage.setItem(name, json);
      } catch (e) {
        console.log('LocalStorageService.set.error serializing', name, value, e);
      }
    }
  }

  static isLocalStorageSupported() {
    if (this.supported) {
      return true;
    }

    let supported = false;

    try {
      supported = 'localStorage' in window && window.localStorage !== null;

      if (supported) {
        window.localStorage.setItem('test', '1');
        window.localStorage.removeItem('test');
      } else {
        supported = false;
      }
    } catch (e) {
      supported = false;
    }

    this.supported = supported;
    return supported;
  }

}const TIMEOUT = 100;
class AgoraChecklistService {
  static checklist$() {
    return StateService.state$.pipe(operators.first(), operators.map(state => {
      const event = {
        shouldCheckAudio: true,
        shouldCheckVideo: true,
        key: 'checklist_audio_video',
        uid: null,
        checklist: {
          browser: null,
          https: null,
          video: null,
          audio: null,
          rtc: null,
          rtm: null
        },
        errors: {}
      };

      if (state.role === RoleType.Viewer) {
        event.shouldCheckAudio = false;
        event.shouldCheckVideo = false;
      }

      if (DeviceService.platform === DevicePlatform.VRHeadset) {
        event.shouldCheckAudio = true;
        event.shouldCheckVideo = false;
      }

      event.key = `checklist${event.shouldCheckAudio ? '_audio' : ''}${event.shouldCheckVideo ? '_video' : ''}`;
      return event;
    }), operators.switchMap(event => {
      const checklist = LocalStorageService.get(event.key);

      if (checklist === true) {
        Object.keys(event.checklist).forEach(key => {
          event.checklist[key] = true;
        });
      }

      return rxjs.of(event);
    }));
  }

  static isChecked(event) {
    const isChecked = Object.keys(event.checklist).reduce((p, c, i) => {
      const checked = p && event.checklist[c];

      switch (c) {
        case 'audio':
          return checked || !event.shouldCheckAudio;

        case 'video':
          return checked || !event.shouldCheckVideo;

        default:
          return checked;
      }
    }, true);
    return isChecked;
  }

  static isChecked$() {
    return this.checklist$().pipe(operators.map(event => this.isChecked(event)));
  }

  static checkEvent$() {
    return this.checklist$().pipe(operators.switchMap(event => {
      const checklist = Object.keys(event.checklist).reduce((p, c, i) => {
        return p && event.checklist[c];
      }, true);

      if (checklist === true) {
        return rxjs.of(event);
      } else {
        LocalStorageService.set(event.key, false);
        const event$ = new rxjs.Subject();
        const check$ = rxjs.of(event).pipe(operators.delay(1000), operators.switchMap(event => {
          event$.next(event);
          return this.checkBrowserEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkHttpsEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkAudioEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkVideoEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkRtcEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkRtmEvent$(event);
        }), operators.tap(event => {
          // console.log('AgoraChecklistService', event);
          LocalStorageService.set(event.key, true);
        }));
        return rxjs.merge(event$, check$);
      }
    }));
  }

  static check$() {
    return this.checklist$().pipe(operators.switchMap(event => {
      const checklist = Object.keys(event.checklist).reduce((p, c, i) => {
        return p && event.checklist[c];
      }, true);

      if (checklist === true) {
        return rxjs.of(event);
      } else {
        LocalStorageService.set(event.key, false);
        return rxjs.of(event).pipe(operators.delay(1000), operators.switchMap(event => this.checkBrowserEvent$(event)), operators.switchMap(event => this.checkHttpsEvent$(event)), operators.switchMap(event => this.checkAudioEvent$(event)), operators.switchMap(event => this.checkVideoEvent$(event)), operators.switchMap(event => this.checkRtcEvent$(event)), operators.switchMap(event => this.checkRtmEvent$(event)), operators.tap(event => {
          // console.log('AgoraChecklistService', event);
          LocalStorageService.set(event.key, true);
        }));
      }
    }));
  }

  static checkBrowser$() {

    const browser = AgoraRTC.checkSystemRequirements();
    return rxjs.of(browser);
  }

  static checkBrowserEvent$(event) {
    return this.checkBrowser$().pipe(operators.switchMap(browser => {
      event.checklist.browser = browser;

      if (browser) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.browser = LabelPipe.transform('bhere_browser_error');
        return this.checkHttpsEvent$(event).pipe(operators.switchMap(event => {
          {
            return rxjs.throwError(event);
          }
        }));
      }
    }), operators.catchError(error => {
      console.log('checkBrowserEvent$.error', error);
      event.checklist.browser = false;
      event.errors.browser = LabelPipe.transform('bhere_browser_error');
      return rxjs.throwError(event);
    }));
  }

  static checkHttps$() {

    const https = window.location.protocol === 'https:';
    return rxjs.of(https);
  }

  static checkHttpsEvent$(event) {
    return this.checkHttps$().pipe(operators.switchMap(https => {
      event.checklist.https = https;

      if (https) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.https = LabelPipe.transform('bhere_https_error');

        {
          return rxjs.throwError(event);
        }
      }
    }), operators.catchError(error => {
      console.log('checkHttpsEvent$.error', error);
      event.checklist.https = false;
      event.errors.https = LabelPipe.transform('bhere_https_error');
      return rxjs.throwError(event);
    }));
  }

  static checkAudio$() {

    return rxjs.from(AgoraService.getDevices()).pipe(operators.map(devices => {
      const audioinput = devices.find(x => x.kind === 'audioinput' && x.deviceId);
      return audioinput != null;
    }));
  }

  static checkAudioEvent$(event) {
    // console.log('checkAudioEvent$', event);
    if (event.shouldCheckAudio) {
      return this.checkAudio$().pipe(operators.switchMap(audio => {
        event.checklist.audio = audio;

        if (audio) {
          return rxjs.of(event).pipe(operators.delay(TIMEOUT));
        } else {
          event.errors.audio = LabelPipe.transform('bhere_audio_error'); // console.log('checkAudioEvent$.error', event);

          {
            return rxjs.throwError(event);
          }
        }
      }), operators.catchError(error => {
        console.log('checkAudioEvent$.error', error);
        event.checklist.audio = false;
        event.errors.audio = LabelPipe.transform('bhere_audio_error');
        return rxjs.throwError(event);
      }));
    } else {
      return rxjs.of(event);
    }
  }

  static checkVideo$() {

    return rxjs.from(AgoraService.getDevices()).pipe(operators.map(devices => {
      const videoinput = devices.find(x => x.kind === 'videoinput' && x.deviceId);
      return videoinput != null;
    }));
  }

  static checkVideoEvent$(event) {
    if (event.shouldCheckVideo) {
      return this.checkVideo$().pipe(operators.switchMap(video => {
        event.checklist.video = video;

        if (video) {
          return rxjs.of(event).pipe(operators.delay(TIMEOUT));
        } else {
          event.errors.video = LabelPipe.transform('bhere_video_error');

          {
            return rxjs.throwError(event);
          }
        }
      }), operators.catchError(error => {
        console.log('checkVideoEvent$.error', error);
        event.checklist.video = false;
        event.errors.video = LabelPipe.transform('bhere_video_error');
        return rxjs.throwError(event);
      }));
    } else {
      return rxjs.of(event);
    }
  }

  static checkRtc$() {

    return rxjs.from(AgoraService.checkRtcConnection());
  }

  static checkRtcEvent$(event) {
    return this.checkRtc$().pipe(operators.switchMap(uid => {
      event.uid = uid;
      event.checklist.rtc = uid !== false;

      if (uid) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.rtc = LabelPipe.transform('bhere_rtc_error');

        {
          return rxjs.throwError(event);
        }
      }
    }), operators.catchError(error => {
      console.log('checkRtcEvent$.error', error);
      event.checklist.rtc = false;
      event.errors.rtc = LabelPipe.transform('bhere_rtc_error');
      return rxjs.throwError(event);
    }));
  }

  static checkRtm$(uid) {

    return rxjs.from(AgoraService.checkRtmConnection(uid));
  }

  static checkRtmEvent$(event) {
    return this.checkRtm$(event.uid).pipe(operators.switchMap(uid => {
      event.checklist.rtm = uid !== false;

      if (uid) {
        return rxjs.of(event);
      } else {
        event.errors.rtm = LabelPipe.transform('bhere_rtm_error');
        return rxjs.throwError(event);
      }
    }), operators.catchError(error => {
      console.log('checkRtmEvent$.error', error);
      event.checklist.rtm = false;
      event.errors.rtm = LabelPipe.transform('bhere_rtm_error');
      return rxjs.throwError(event);
    }));
  }

}class AgoraConfigureFirewallModalComponent extends rxcomp.Component {
  onClose() {
    ModalService.resolve();
  }

}
AgoraConfigureFirewallModalComponent.meta = {
  selector: '[agora-configure-firewall-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form" [innerHTML]="'bhere_configure_firewall' | label"></div>
			<div class="group--cta">
				<button type="button" class="btn--accept" (click)="onClose()">
					<span>Chiudi</span>
				</button>
			</div>
		</div>
	`
};

AgoraConfigureFirewallModalComponent.chunk = () =>
/* html */
`<div class="configure-firewall-modal" agora-configure-firewall-modal></div>`;class AgoraChecklistComponent extends rxcomp.Component {
  onInit() {
    this.platform = DeviceService.platform;
    this.checklist = {};
    this.errors = {};
    this.state = {};
    this.busy = true;
    this.shouldCheckAudio = false;
    this.shouldCheckVideo = false;
    AgoraChecklistService.checkEvent$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('AgoraChecklistService', event, event.errors);
      this.shouldCheckAudio = event.shouldCheckAudio;
      this.shouldCheckVideo = event.shouldCheckVideo;
      this.checklist = event.checklist;
      this.errors = event.errors || {}; // console.log(JSON.stringify(event.errors));

      const success = AgoraChecklistService.isChecked(event);

      if (success) {
        this.checklist.success = success;
        this.busy = false;
        this.pushChanges();

        if (this.state.role === RoleType.SmartDevice) {
          this.onNext();
        }
      } else {
        this.pushChanges();
      } // console.log(event);

    }, error => {
      // console.log('AgoraChecklistService.error', error);
      this.errors = error.errors || {};
      this.checklist.error = true;
      this.busy = false;
      this.pushChanges();
    });
  }

  onNext() {
    this.checked.next(this.checklist);
  }

  openHttps() {
    window.location.href = window.location.href.replace('http://', 'https://').replace(':5000', ':6443');
  }

  showFirewallConfiguration() {
    ModalService.open$({
      template: AgoraConfigureFirewallModalComponent.chunk()
    }).pipe(operators.first()).subscribe();
  }

}
AgoraChecklistComponent.meta = {
  selector: '[agora-checklist]',
  outputs: ['checked'],
  template:
  /* html */
  `
	<div class="group--info">
		<div class="group--info__content stagger--childs">
			<div class="title" *if="busy" [innerHTML]="'bhere_checklist_busy' | label"></div>
			<div class="title" *if="checklist.success" [innerHTML]="'bhere_checklist_success' | label"></div>
			<div class="title" *if="checklist.error" [innerHTML]="'bhere_checklist_error' | label"></div>
			<ul class="group--checklist stagger--childs">
				<li class="checklist__item check"><span>Browser</span> <span agora-check [value]="checklist.browser"></span></li>
				<li class="checklist__item error" *if="errors.browser"><a class="btn--link" href="https://browsehappy.com/" target="_blank" rel="noopener" [innerHTML]="errors.browser"></a></li>
				<li class="checklist__item check"><span>Https</span> <span agora-check [value]="checklist.https"></span></li>
				<li class="checklist__item error" *if="errors.https"><a class="btn--link" (click)="openHttps()" [innerHTML]="errors.https"></a></li>
				<li class="checklist__item check" *if="shouldCheckAudio"><span>Audio</span> <span agora-check [value]="checklist.audio"></span></li>
				<li class="checklist__item error" *if="errors.audio"><span [innerHTML]="errors.audio"></span></li>
				<li class="checklist__item check" *if="shouldCheckVideo"><span>Video</span> <span agora-check [value]="checklist.video"></span></li>
				<li class="checklist__item error" *if="errors.video"><span [innerHTML]="errors.video"></span></li>
				<li class="checklist__item check"><span>Realtime Communication</span> <span agora-check [value]="checklist.rtc"></span></li>
				<li class="checklist__item error" *if="errors.rtc"><a class="btn--link" (click)="showFirewallConfiguration()" [innerHTML]="errors.rtc"></a></li>
				<li class="checklist__item check"><span>Realtime Messaging</span> <span agora-check [value]="checklist.rtm"></span></li>
				<li class="checklist__item error" *if="errors.rtm"><a class="btn--link" (click)="showFirewallConfiguration()" [innerHTML]="errors.rtm"></a></li>
			</ul>
			<button type="submit" class="btn--next" [class]="{ disabled: !checklist.success, ready: checklist.success }" (click)="onNext()">
				<span [innerHTML]="'bhere_proceed' | label"></span>
			</button>
		</div>
	</div>
	`
};class AudioStreamService {
  static get context() {
    if (!this.context_ && 'AudioContext' in window) {
      this.context_ = new AudioContext();
    }

    return this.context_;
  }
  /*
  static get processorNode() {
  	if (!this.processorNode_) {
  		this.processorNode_ = this.context.createScriptProcessor(BUFF_SIZE, 1, 1);
  	}
  	return this.processorNode_;
  }
  */

  /*
  static get gain() {
  	if (!this.gain_) {
  		this.gain_ = this.context.createGain();
  	}
  	return this.gain_;
  }
  */


  static get analyser() {
    if (!this.analyser_) {
      try {
        this.analyser_ = this.context.createAnalyser();
      } catch (error) {
        console.log('AudioStreamService.analyser', error);
      }
    }

    return this.analyser_;
  }

  static addSource(streamOrElement) {
    const key = streamOrElement instanceof MediaStream ? streamOrElement.id : streamOrElement;

    if (!this.sources_[key]) {
      if (streamOrElement instanceof MediaStream) {
        this.sources_[key] = this.context.createMediaStreamSource(streamOrElement.clone());
      } else {
        this.sources_[key] = this.context.createMediaElementSource(streamOrElement);
      } // this.sources_[key] = streamOrElement instanceof MediaStream ? this.context.createMediaStreamSource(streamOrElement) : this.context.createMediaElementSource(streamOrElement);

    }

    return this.sources_[key];
  }

  static removeSource(streamOrElement) {
    const key = streamOrElement instanceof MediaStream ? streamOrElement.id : streamOrElement;
    return this.removeSourceKey(key);
  }

  static removeSourceKey(key) {
    // console.log('AudioStreamService.removeSourceKey', key);
    let source;

    if (this.sources_[key]) {
      source = this.sources_[key];
      /*
      if (source.mediaStream) {
      	source.mediaStream.stop();
      }
      source.stop();
      */

      if (this.analyser) {
        source.disconnect(this.analyser);
      }

      source.disconnect();
      delete this.sources_[key];
    }

    return source;
  }

  static frequency$(streamOrElement, fftSize) {
    if (fftSize === void 0) {
      fftSize = 64;
    }

    if (fftSize % 2 === 1) {
      throw fftSize;
    }

    const state = new Uint8Array(fftSize / 2);
    const context = this.context;

    if (context) {
      const analyser = this.analyser;

      if (analyser) {
        // Connect the output of the analyser to the destination
        // analyser.connect(context.destination); // no audio !
        // console.log(analyser.fftSize); // 2048 by default
        // console.log(analyser.frequencyBinCount); // will give us 1024 data points
        analyser.fftSize = fftSize; // 64
        // console.log(analyser.frequencyBinCount); // fftSize/2 = 32 data points

        const source = this.addSource(streamOrElement); // source.connect(context.destination); // no audio!
        // Connect the output of the source to the input of the analyser

        source.connect(analyser);
      }

      const state$ = new rxjs.BehaviorSubject(state);
      return AudioStreamService.frame$.pipe(operators.withLatestFrom(state$), operators.map(_ref => {
        let [deltaTime, state] = _ref;

        if (analyser) {
          // Get the new frequency data
          analyser.getByteFrequencyData(state);
          /*
          const max = state.reduce((p, c, i) => {
          	return Math.max(c, p);
          }, 0);
          if (max > 0) {
          	// console.log(max);
          }
          */
          // Update the visualisation
        }

        return state;
      }), operators.tap(state => state$.next(state)), operators.finalize(() => {
        this.removeSource(streamOrElement);
      }));
    } else {
      return rxjs.of(state);
    }
  } // unused


  static volume$(streamOrElement) {
    const state = {
      volume: 0,
      clipped: false
    };
    const context = this.context; // console.log('AudioStreamService.volume$', context, state);

    if (context) {
      const source = this.addSource(streamOrElement);
      const meter = AudioStreamService.audioMeterCreate();
      source.connect(meter);
      const state$ = new rxjs.BehaviorSubject(state);
      return AudioStreamService.frame$.pipe(operators.withLatestFrom(state$), operators.map(_ref2 => {
        let [deltaTime, state] = _ref2;
        state.clipped = meter.checkClipping();
        state.volume = meter.volume;
        return state;
      }), operators.tap(state => state$.next(state)), operators.finalize(() => {
        this.removeSource(streamOrElement);
      }));
    } else {
      return rxjs.of(state);
    }
  } // unused


  static audioMeterCreate(clipLevel, averaging, clipLag) {
    if (clipLevel === void 0) {
      clipLevel = 0.98;
    }

    if (averaging === void 0) {
      averaging = 0.95;
    }

    if (clipLag === void 0) {
      clipLag = 750;
    }

    const context = this.context;

    if (context) {
      const processor = context.createScriptProcessor(512);
      processor.onaudioprocess = this.audioMeterProcess;
      processor.checkClipping = this.audioMeterClip;
      processor.dispose = this.audioMeterDispose;
      processor.clipping = false;
      processor.lastClip = 0;
      processor.volume = 0;
      processor.clipLevel = clipLevel;
      processor.averaging = averaging;
      processor.clipLag = clipLag; // this will have no effect, since we don't copy the input to the output,
      // but works around a current Chrome bug.

      processor.connect(context.destination);
      return processor;
    }
  }

  static audioMeterProcess(event) {
    const buffer = event.inputBuffer.getChannelData(0);
    const bufferLength = buffer.length;
    let sum = 0;
    let x; // Do a root-mean-square on the samples: sum up the squares...

    for (let i = 0; i < bufferLength; i++) {
      x = buffer[i];

      if (Math.abs(x) >= this.clipLevel) {
        this.clipping = true;
        this.lastClip = window.performance.now();
      }

      sum += x * x;
    } // ... then take the square root of the sum.


    const rms = Math.sqrt(sum / bufferLength); // Now smooth this out with the averaging factor applied
    // to the previous sample - take the max here because we
    // want 'fast attack, slow release.'

    this.volume = Math.max(rms, this.volume * this.averaging);
  }

  static audioMeterClip() {
    if (!this.clipping) {
      return false;
    }

    if (this.lastClip + this.clipLag < window.performance.now()) {
      this.clipping = false;
    }

    return this.clipping;
  }

  static audioMeterDispose() {
    this.disconnect();
    this.onaudioprocess = null;
  }

  static step$(previous) {
    /**
     * This function returns an observable that will emit the next frame once the
     * browser has returned an animation frame step. Given the previous frame it calculates
     * the delta time, and we also clamp it to 30FPS in case we get long frames.
     */
    return rxjs.Observable.create(observer => {
      requestAnimationFrame(startTime => {
        // Millis to seconds
        const deltaTime = previous ? (startTime - previous.startTime) / 1000 : 0;
        observer.next({
          startTime,
          deltaTime
        });
      });
    }).pipe(operators.map(frame => {
      if (frame.deltaTime > 1 / 30) {
        frame.deltaTime = 1 / 30;
      }

      return frame;
    }));
  }

  static dispose() {
    Object.keys(this.sources_).forEach(key => {
      this.removeSourceKey(key);
    });
    const analyser = this.analyser;

    if (analyser) {
      analyser.disconnect();
    }

    this.sources_ = {}; // this.context_.close().then(() => console.log('AudioStreamService.dispose'));
    // this.context_ = null;
  }

}
AudioStreamService.sources_ = {};
AudioStreamService.frame$ = rxjs.of(undefined).pipe(operators.expand(value => AudioStreamService.step$(value)), // Expand emits the first value provided to it, and in this
//  case we just want to ignore the undefined input frame
operators.filter(frame => frame !== undefined), operators.map(frame => frame.deltaTime), operators.share());class AgoraDevicePreviewComponent extends rxcomp.Component {
  get video() {
    return this.video_;
  }

  set video(video) {
    if (this.video_ !== video) {
      this.video_ = video;

      if (this.change) {
        this.change.next();
        this.init();
        this.initStream();
      }
    }
  }

  get audio() {
    return this.audio_;
  }

  set audio(audio) {
    if (this.audio_ !== audio) {
      this.audio_ = audio;

      if (this.change) {
        this.change.next();
        this.init();
        this.initStream();
      }
    }
  }

  get hasPreview() {
    return this.platform !== DevicePlatform.IOS && this.platform !== DevicePlatform.VRHeadset;
  }

  onInit() {
    this.init();
  }

  init() {
    if (this.initialized_) {
      return;
    }

    this.initialized_ = true;
    this.platform = DeviceService.platform;
    const {
      node
    } = rxcomp.getContext(this);
    this.onLoadedMetadata = this.onLoadedMetadata.bind(this);
    const preview = this.preview = node.querySelector('video');
    preview.addEventListener('loadedmetadata', this.onLoadedMetadata);
    const audio = node.querySelector('.audio');

    if (this.hasPreview) {
      this.bars = new Array(32).fill(0).map(x => {
        const bar = document.createElement('div');
        bar.classList.add('bar');
        audio.appendChild(bar);
        return bar;
      });
    }
  }

  onDestroy() {
    const preview = this.preview;
    preview.removeEventListener('loadedmetadata', this.onLoadedMetadata);

    if (this.hasPreview) {
      AudioStreamService.dispose();
    }
  }

  initStream() {
    const preview = this.preview;

    if (!this.preview) {
      return;
    } // console.log(this.video_, this.audio_);


    const {
      node
    } = rxcomp.getContext(this);

    if (this.video_ || this.audio_) {
      node.classList.add('ready');

      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const state = StateService.state;
        const quality = getStreamQuality(state);
        const options = {
          video: this.video_ ? {
            deviceId: this.video_,
            width: {
              ideal: quality.resolution.width
            },
            height: {
              ideal: quality.resolution.height
            },
            frameRate: {
              ideal: quality.frameRate.min,
              max: quality.frameRate.max
            }
          } : false,
          audio: this.audio_ ? {
            deviceId: this.audio_
          } : false
        };

        if (this.platform === DevicePlatform.IOS) {
          options.video.facingMode = 'user';
        } // console.log('AgoraDevicePreviewComponent.initStream.getUserMedia', options);


        navigator.mediaDevices.getUserMedia(options).then(stream => {
          if (this.hasPreview) {
            if ('srcObject' in preview) {
              preview.srcObject = stream;
            } else {
              preview.src = window.URL.createObjectURL(stream);
            }

            if (this.audio_) {
              this.analyzeData(stream);
            }

            this.loadingStream_ = stream;
          } else {
            this.stream.next(stream);
          }
        }).catch(error => {
          console.log('AgoraDevicePreviewComponent.initStream.error', error.name, error.message);
          this.stream.next(null);
        });
      }
    } else {
      node.classList.remove('ready');

      if (this.hasPreview) {
        if ('srcObject' in preview) {
          preview.srcObject = null;
        } else {
          preview.src = null;
        }

        this.analyzeData(null);
      }

      this.stream.next(null);
    }
  }

  onLoadedMetadata(event) {
    // console.log('AgoraDevicePreview.onLoadedMetadata', event);
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('loaded');
    this.preview.play();
    this.stream.next(this.loadingStream_);
  }

  analyzeData(stream) {
    if (this.frequencySubscription) {
      this.frequencySubscription.unsubscribe();
    } // console.log('AgoraDevicePreviewComponent.analyzeData', stream);


    if (stream) {
      this.frequencySubscription = AudioStreamService.frequency$(stream, 64).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(frequency => {
        // 32 data points
        // console.log(frequency);
        const spacing = 100 / 32;
        const bars = this.bars;
        bars.forEach((bar, i) => {
          const pow = Math.min(100, 5 + frequency[i]) / 100;
          bar.style.left = i * spacing + '%';
          bar.style.transform = `scale(1,${pow})`;
          bar.style.opacity = pow;
        });
      });
    }
  }

}
AgoraDevicePreviewComponent.meta = {
  selector: '[agora-device-preview]',
  outputs: ['stream', 'change'],
  inputs: ['video', 'audio']
};class AgoraDeviceComponent extends rxcomp.Component {
  get hasPreview() {
    return this.platform !== DevicePlatform.IOS && this.platform !== DevicePlatform.VRHeadset; // && this.form && this.form.value.video;
  }

  onInit() {
    this.platform = DeviceService.platform;
    this.isHttps = window.location.protocol === 'https:';
    this.state = {};
    this.devices = {
      videos: [],
      audios: []
    };
    this.stream = null;
    this.form = null;

    if (this.isHttps) {
      const agora = this.agora = AgoraService.getSingleton();
      StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
        // console.log('AgoraDeviceComponent.state', state);
        this.state = state;
        this.pushChanges();
      });

      if (agora) {
        agora.devices$().subscribe(devices => {
          // console.log(devices);
          this.devices = devices;
          this.initForm(devices);
          this.pushChanges();
        }, error => {
          console.log('AgoraDeviceComponent.devices$.error', error); // alert('AgoraDeviceComponent ' + error); // !!!
        });
      }
    }
  }

  openHttps(event) {
    window.location.href = window.location.href.replace('http://', 'https://').replace(':5000', ':6443');
  }

  initForm(devices) {
    const form = this.form = new rxcompForm.FormGroup({
      video: new rxcompForm.FormControl(null, devices.videos.length ? rxcompForm.Validators.RequiredValidator() : undefined),
      audio: new rxcompForm.FormControl(null, devices.audios.length ? rxcompForm.Validators.RequiredValidator() : undefined)
    });
    const controls = this.controls = form.controls;
    const videoOptions = devices.videos.map(x => {
      return {
        id: x.deviceId,
        name: x.label
      };
    });

    if (videoOptions.length > 0) {
      videoOptions.unshift({
        id: null,
        name: 'bhere_select_video' // LabelPipe.transform('bhere_select_video')

      });
    }

    controls.video.options = videoOptions;
    const audioOptions = devices.audios.map(x => {
      return {
        id: x.deviceId,
        name: x.label
      };
    });

    if (audioOptions.length > 0) {
      audioOptions.unshift({
        id: null,
        name: 'bhere_select_audio' // LabelPipe.transform('bhere_select_audio')

      });
    }

    controls.audio.options = audioOptions;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraDeviceComponent.changes$', form.value);
      this.pushChanges();
    });
  }

  onStreamDidChange(event) {
    this.stream = null;
    this.pushChanges();
  }

  onStream(stream) {
    this.stream = stream;
    this.pushChanges();
  }

  isValid() {
    const isValid = this.form.valid && (this.stream || !this.hasPreview);
    return isValid;
  }

  onEnter(event) {
    const preferences = this.form.value;
    const devices = this.devices;
    devices.video = devices.videos.find(x => x.deviceId === preferences.video);
    devices.audio = devices.audios.find(x => x.deviceId === preferences.audio);
    this.enter.next(devices);
  }

}
AgoraDeviceComponent.meta = {
  selector: '[agora-device]',
  outputs: ['enter'],
  template:
  /* html */
  `
	<div class="group--info" *if="!isHttps">
		<div class="group--info__content stagger--childs">
			<div class="title" [innerHTML]="'bhere_invalid_protocol' | label"></div>
			<div class="info" [innerHTML]="'bhere_reload_in_https' | label"></div>
			<button type="button" class="btn--connect" (click)="openHttps($event)">
				<span [innerHTML]="'bhere_reload' | label"></span>
			</button>
		</div>
	</div>
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onEnter($event)" name="form" role="form" novalidate autocomplete="off">
			<!-- PREVIEW -->
			<div class="agora-device-preview" agora-device-preview [video]="controls.video.value" [audio]="controls.audio.value" (stream)="onStream($event)" (change)="onStreamDidChange($event)" *if="this.hasPreview">
				<video class="video" muted></video>
				<div class="audio"></div>
			</div>
			<div class="group--info__content stagger--childs">
				<!-- VIDEO -->
				<div control-custom-select [control]="controls.video" label="Video" *if="devices.videos.length"></div>
				<!-- AUDIO -->
				<div control-custom-select [control]="controls.audio" label="Audio" *if="devices.audios.length"></div>
				<div class="info" *if="!isValid()" [innerHTML]="'bhere_select_video_audio' | label"></div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_video_audio_connected' | label"></div>
				<button type="submit" class="btn--connect" [class]="{ disabled: !isValid() }">
					<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
					<span *if="!state.connecting" [innerHTML]="'bhere_enter' | label"></span>
					<span *if="state.connecting" [innerHTML]="'bhere_connecting' | label"></span>
				</button>
			</div>
		</form>
	</div>
	`
};class Path {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }

    this.items = this.items || [];
    this.originalItems = this.items.slice();
  }

  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }

}
Path.allowedProps = ['id', 'name', 'items'];
function mapPath(map) {
  map = new Path(map);
  return map;
}const DEFAULT_PATH = {
  id: null,
  name: "Principale",
  items: []
};
class PathService {
  static set paths(paths) {
    this.paths$.next(paths);
  }

  static get paths() {
    return this.paths$.getValue();
  }

  static set path(path) {
    this.path$.next(path);
  }

  static get path() {
    return this.path$.getValue();
  }

  static getCurrentPath$(pathId) {
    if (pathId === void 0) {
      pathId = null;
    }

    return this.pathGet$().pipe(operators.switchMap(paths => {
      this.paths = paths;
      let path = DEFAULT_PATH;

      if (pathId) {
        const selectedPath = paths.find(x => x.id === pathId);

        if (selectedPath) {
          path = selectedPath;
        }
      }

      this.path = path;
      return this.path$;
    }));
  }

  static pathGet$() {
    if (environment.flags.usePaths) {
      return HttpService.get$(`/api/path`).pipe(operators.map(data => {
        data.paths = data.paths.map(path => mapPath(path));
        data.paths.unshift(DEFAULT_PATH);
        return data.paths;
      }));
    } else {
      return rxjs.of([]);
    }
  }

  static addPath(path) {
    const paths = this.paths.slice();
    paths.push(path);
    this.paths = paths;
    this.path = path;
  }

  static editPath(path) {
    // console.log('PathService.editPath', path);
    const paths = this.paths.slice();
    const index = paths.reduce((p, c, i) => {
      return c.id === path.id ? i : p;
    }, -1); // console.log('PathService.editPath', paths, index);

    if (index > 0) {
      let currentPath = this.path;

      if (currentPath.id === path.id) {
        currentPath = path;
      } // console.log('PathService.editPath', currentPath);


      paths.splice(index, 1, path);
      this.paths = paths;
      this.path = currentPath;
    }
  }

  static deletePath(path) {
    const paths = this.paths.slice();
    const index = paths.indexOf(path);

    if (index > 0) {
      paths.splice(index, 1);
      this.paths = paths;
      let currentPath = this.path;

      if (currentPath.id === path.id) {
        currentPath = paths[0];
      }

      this.path = currentPath;
    }
  }

  static pathCreate$(path) {
    return HttpService.post$(`/api/path`, path).pipe(operators.map(path => mapPath(path)));
  }

  static pathUpdate$(path) {
    return HttpService.put$(`/api/path/${path.id}`, path).pipe(operators.map(x => mapPath(x)));
  }

  static pathDelete$(path) {
    return HttpService.delete$(`/api/path/${path.id}`);
  }
  /*
  static itemCreate$(path, item) {
  	return HttpService.post$(`/api/path/${path.id}/item`, item).pipe(
  		map(item => mapViewItem(item)),
  	);
  }
  
  static itemUpdate$(path, item) {
  	item = mapViewItem(item); // !!! ??
  	return HttpService.put$(`/api/path/${path.id}/item/${item.id}`, item.payload).pipe(
  		map(item => mapViewItem(item)),
  	);
  }
  
  static itemDelete$(path, item) {
  	return HttpService.delete$(`/api/path/${path.id}/item/${item.id}`);
  }
  */


}
PathService.paths$ = new rxjs.BehaviorSubject([DEFAULT_PATH]);
PathService.path$ = new rxjs.BehaviorSubject(DEFAULT_PATH);class AgoraLinkComponent extends rxcomp.Component {
  get selfServiceTourRoute() {
    const pathId = this.form.get('path').value;
    const route = [RoutePipe.transform(':lang.selfServiceTour')];

    if (pathId) {
      route.push(MeetingUrl.validateParams({
        pathId
      }));
    }

    return route;
  }

  onInit() {
    this.state = {};
    this.paths = [];
    this.pathId = null;
    this.form = null;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      // console.log('AgoraLinkComponent.state', state);
      this.state = state;
      this.pushChanges();
    });

    if (environment.flags.usePaths) {
      PathService.getCurrentPath$().pipe(operators.first(), operators.tap(), operators.takeUntil(this.unsubscribe$)).subscribe(path => {
        this.paths = PathService.paths;
        this.pathId = path.id || '';
        this.onLoad();
      });
    } else {
      this.onLoad();
    }
  }

  onLoad() {
    const form = this.form = new rxcompForm.FormGroup({
      path: this.pathId,
      id: new rxcompForm.FormControl(null, [rxcompForm.Validators.PatternValidator(MEETING_ID_VALIDATOR), rxcompForm.Validators.RequiredValidator()]),
      idAttendee: null,
      idStreamer: null,
      idViewer: null,
      idSmartDevice: null // id: new FormControl(null),

    });
    const controls = this.controls = form.controls;
    const pathOptions = this.paths.map(x => {
      return {
        id: x.id || '',
        name: x.name
      };
    });

    if (pathOptions.length > 0) {
      pathOptions.unshift({
        id: null,
        name: 'bhere_select_path' // LabelPipe.transform('bhere_select_path')

      });
    }

    controls.path.options = pathOptions;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraLinkComponent.changes$', form.value);
      // console.log(changes.path, changes.id);
      if (this.pathId !== changes.path && changes.id !== null) {
        this.pathId = changes.path;
        this.onGenerateMeetingId();
      }

      this.pushChanges();
    });
  }

  onGenerateMeetingId($event) {
    let pathId = this.pathId ? String(this.pathId) : null;
    pathId = pathId && pathId.length ? pathId : null; // console.log('onGenerateMeetingId', this.pathId, pathId);

    const meetingId = new MeetingId({
      pathId
    });
    const meetingIdRoles = meetingId.toRoles();
    this.form.patch(meetingIdRoles);
  }

  onInputDidChange($event) {
    // console.log('onInputDidChange', this.form.get('id').value, this.form.get('id').valid);
    if (this.state.role !== 'publisher') {
      return;
    }

    setTimeout(() => {
      if (this.form.get('id').valid) {
        const value = this.form.get('id').value;
        const meetingId = new MeetingId(value);
        const meetingIdRoles = meetingId.toRoles();
        this.form.patch(meetingIdRoles);
      } else {
        this.form.get('idAttendee').reset();
        this.form.get('idStreamer').reset();
        this.form.get('idViewer').reset();
        this.form.get('idSmartDevice').reset();
      }
    }, 1);
  }

  onCopyToClipBoard(id, asAccessCode) {
    if (asAccessCode === void 0) {
      asAccessCode = false;
    }

    const meetingUrl = new MeetingUrl({
      link: id
    });
    meetingUrl.copyToClipBoard(asAccessCode);
  }

  onNext(event) {
    let meetingId = this.controls.id.value;
    MeetingUrl.replaceWithLink(meetingId);
    this.link.next(meetingId);
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }

}
AgoraLinkComponent.meta = {
  selector: '[agora-link]',
  outputs: ['link'],
  template:
  /* html */
  `
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onNext($event)" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<div class="stagger--childs" *if="state.role !== 'publisher'">
					<div class="group--form group--form--addon" [class]="{ required: controls.id.validators.length, 'addon': controls.id.valid }">
						<label [innerHTML]="'bhere_insert_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.id" [placeholder]="'bhere_meeting_id' | label" />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.id.value)" *if="controls.id.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
				</div>
				<div class="stagger--childs" *if="state.role === 'publisher'">
					<!-- PATH -->
					<div control-custom-select [control]="controls.path" [label]="'bhere_path' | label" *if="('usePaths' | flag) && paths.length"></div>
					<!--IDS -->
					<div class="group--form group--form--addon" [class]="{ required: controls.id.validators.length, 'addon': controls.id.valid }">
						<label><svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg> <span [innerHTML]="'bhere_insert_meeting_id' | label"></span></label>
						<input type="text" class="control--text" [formControl]="controls.id" [placeholder]="'bhere_meeting_id' | label" (change)="onInputDidChange($event)" />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.id.value)" *if="controls.id.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('attendee' | flag) && controls.idAttendee.valid && controls.idAttendee.value !== null">
						<label><svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg> <span [innerHTML]="'bhere_attendee_meeting_id' | label"></span></label>
						<input type="text" class="control--text" [formControl]="controls.idAttendee" [placeholder]="'bhere_attendee_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idAttendee.value)" *if="controls.idAttendee.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('streamer' | flag) && controls.idStreamer.valid && controls.idStreamer.value !== null">
						<label [innerHTML]="'bhere_streamer_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idStreamer" [placeholder]="'bhere_streamer_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idStreamer.value)" *if="controls.idStreamer.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('viewer' | flag) && controls.idViewer.valid && controls.idViewer.value !== null">
						<label [innerHTML]="'bhere_viewer_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idViewer" [placeholder]="'bhere_viewer_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idViewer.value)" *if="controls.idViewer.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('smartDevice' | flag) && controls.idSmartDevice.valid && controls.idSmartDevice.value !== null">
						<label [innerHTML]="'bhere_smart_device_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idSmartDevice" [placeholder]="'bhere_smart_device_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idSmartDevice.value, true)" *if="controls.idSmartDevice.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
				</div>
				<div class="info" *if="controls.id.errors.required" [innerHTML]="'bhere_insert_meeting_id' | label"></div>
				<div class="info" *if="controls.id.errors.pattern" [innerHTML]="'bhere_invalid_meeting_id' | label"></div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_take_part_meeting' | label"></div>
				<button type="button" class="btn--generate" *if="state.role == 'publisher'" (click)="onGenerateMeetingId($event)">
					<span [innerHTML]="'bhere_generate_meeting_id' | label"></span>
				</button>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_take_part' | label"></span>
				</button>
				<a [routerLink]="selfServiceTourRoute" class="btn--secondary" *if="state.role === 'publisher'">
					<span [innerHTML]="'bhere_self_service' | label"></span>
				</a>
			</div>
		</form>
	</div>
	`
};class AgoraLoginComponent extends rxcomp.Component {
  onInit() {
    const form = this.form = new rxcompForm.FormGroup({
      username: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      password: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }

  test() {
    this.form.patch({
      username: 'publisher',
      password: 'publisher',
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
  }

  reset() {
    this.form.reset();
  }

  onSubmit() {
    if (this.form.valid) {
      const payload = this.form.value;
      this.form.submitted = true;
      this.error = null;
      this.pushChanges();
      UserService.login$(payload).pipe(operators.first()).subscribe(user => {
        if (StateService.state.role === user.type) {
          // this.login.next(user);
          this.onNext(user);
          this.form.reset();
        } else {
          this.error = {
            friendlyMessage: LabelPipe.transform('error_credentials')
          };
          this.pushChanges();
        }
      }, error => {
        console.log('AccessComponent.error', error);
        this.error = error;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }

  onNext(user) {
    MeetingUrl.replaceWithUser(user);
    this.login.next(user);
  }

}
AgoraLoginComponent.meta = {
  selector: '[agora-login]',
  outputs: ['login'],
  template:
  /* html */
  `
	<div class="group--info">
		<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<div class="title" [innerHTML]="'bhere_login' | label"></div>
				<input name="checkField" [formControl]="controls.checkField" value="" type="text" style="display:none !important;" />
				<div control-text [control]="controls.username" [label]="'bhere_username' | label"></div>
				<div control-password [control]="controls.password" [label]="'bhere_password' | label"></div>
				<div class="group--error" *if="error">
					<span class="status-code" [innerHTML]="error.statusCode"></span>
					<span class="status-message" [innerHTML]="error.statusMessage"></span>
					<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
				</div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_cta' | label"></div>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_cta' | label"></span>
				</button>
				<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
			</div>
		</form>
	</div>
	`
};class AgoraNameComponent extends rxcomp.Component {
  onInit() {
    const meetingUrl = new MeetingUrl();
    this.state = {};
    const fields = this.fields = [];

    if (environment.flags.useExtendedUserInfo) {
      const firstName = meetingUrl.firstName;
      const lastName = meetingUrl.lastName;
      const email = meetingUrl.email;
      fields.push({
        type: 'text',
        name: 'firstName',
        label: 'access_first_name',
        required: true,
        value: firstName,
        test: 'Jhon'
      }, {
        type: 'text',
        name: 'lastName',
        label: 'access_last_name',
        required: true,
        value: lastName,
        test: 'Appleseed'
      }, {
        type: 'email',
        name: 'email',
        label: 'access_email',
        required: true,
        value: email,
        test: 'jhonappleseed@gmail.com'
      });
    } else {
      const name = meetingUrl.name;
      fields.push({
        type: 'text',
        name: 'name',
        label: 'bhere_name_and_surname',
        pattern: /^\w{2,}\s\w{2,}/,
        required: true,
        value: name,
        test: 'Jhon Appleseed'
      });
    }

    fields.push({
      type: 'checkbox',
      name: 'privacy',
      label: 'access_privacy_disclaimer',
      required: true,
      test: true
    }, {
      type: 'hidden',
      name: 'checkField',
      value: '',
      test: ''
    }, {
      type: 'none',
      name: 'checkRequest',
      value: environment.antiforgery || '',
      test: environment.antiforgery || ''
    });
    const form = this.form = fieldsToFormGroup(fields);
    /*
    const form = this.form = new FormGroup({
    	name: new FormControl(name, [Validators.PatternValidator(/^\w{2,}\s\w{2,}/), Validators.RequiredValidator()]),
    });
    */

    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraNameComponent.changes$', form.value);
      this.pushChanges();
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      // console.log('AgoraNameComponent.state', state);
      this.state = state;
      this.pushChanges();
    });
  }

  test() {
    patchFields(this.fields, this.form);
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }

  onNext(event) {
    let name;
    let options;

    if (environment.flags.useExtendedUserInfo) {
      options = {
        firstName: this.controls.firstName.value,
        lastName: this.controls.lastName.value,
        email: this.controls.email.value
      };
      name = `${options.firstName} ${options.lastName}`;
    } else {
      options = {
        name: this.controls.name.value
      };
      name = options.name;
    }

    MeetingUrl.replaceWithOptions(options);
    this.name.next(name);
  }

}
AgoraNameComponent.meta = {
  selector: '[agora-name]',
  outputs: ['name'],
  template:
  /* html */
  `
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onNext($event)" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<!-- controls -->
				<div controls [formGroup]="form" [fields]="fields"></div>
				<!-- NAME -->
				<!--
				<div class="group--form group--form--addon" [class]="{ required: controls.name.validators.length }">
					<label [innerHTML]="'bhere_fill_fullname' | label"></label>
					<input type="text" class="control--text" [formControl]="controls.name" [placeholder]="'bhere_name_and_surname' | label" />
				</div>
				<div class="info" *if="!controls.name.valid" [innerHTML]="'bhere_fill_name_and_surname' | label"></div>
				-->
				<div class="info" *if="!isValid()"><span [innerHTML]="'bhere_fill_name_and_surname' | label"></span></div>
				<div class="info" *if="isValid()"><span [innerHTML]="'bhere_proceed_as' | label"></span> <span [innerHTML]="controls.name.value"></span></div>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_proceed' | label"></span>
				</button>
				<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
			</div>
		</form>
	</div>
	`
};class AgoraStreamComponent extends rxcomp.Component {
  set videoMuted(videoMuted) {
    if (this.videoMuted_ !== videoMuted) {
      this.videoMuted_ = videoMuted;
      const {
        node
      } = rxcomp.getContext(this);
      videoMuted ? node.classList.add('video--muted') : node.classList.remove('video--muted');
    }
  }

  set audioMuted(audioMuted) {
    if (this.audioMuted_ !== audioMuted) {
      this.audioMuted_ = audioMuted;
      const {
        node
      } = rxcomp.getContext(this);
      audioMuted ? node.classList.add('audio--muted') : node.classList.remove('audio--muted');
    }
  }

  get streamId() {
    return this.streamId_;
  }

  set streamId(streamId) {
    this.streamId_ = streamId;
  }

  get stream() {
    return this.stream_;
  }

  set stream(stream) {
    if (this.stream_ !== stream) {
      // console.log('AgoraStreamComponent set stream', stream);
      const {
        node
      } = rxcomp.getContext(this);
      const player = this.player = node.querySelector('.agora-stream__player');

      while (player.childElementCount > 0) {
        player.removeChild(player.firstElementChild);
      } // player.textContent = '';
      // !!!


      if (this.stream_ && this.stream_.isPlaying() && this.stream_.player.div.parentNode === player) {
        console.log('AgoraStreamComponent stopping stream', this.stream_.getId(), 'on', this.stream_.player.div.parentNode);
        this.stream_.stop();
      }

      this.stream_ = stream;

      if (stream) {
        this.videoMuted = stream.userMuteVideo;
        this.audioMuted = stream.userMuteAudio;
      }

      const streamId = stream ? stream.getId() : null;
      this.streamId = streamId; // console.log('AgoraStreamComponent streamId', streamId);

      if (streamId) {
        // const name = `stream-${node.getAttribute('type')}-${streamId}`;
        const name = `stream-${streamId}`;
        player.setAttribute('id', name);
        const self = this;

        if (stream.isPlaying()) {
          player.appendChild(stream.player.div);
        } else {
          this.shouldUseResumeGesture = false;
          stream.play(name, {
            fit: 'cover'
          }, error => {
            if (error && error.status !== 'aborted') {
              // The playback fails, probably due to browser policy. You can resume the playback by user gesture.
              self.shouldUseResumeGesture = true;
              self.pushChanges();
            }
          });
        }
      } else {
        player.removeAttribute('id');
      }
    }
  }

  set vrContainer(vrContainer) {
    if (this.vrContainer_ !== vrContainer) {
      this.vrContainer_ = vrContainer;

      if (vrContainer) {
        this.stream_.vrContainer = vrContainer;
        this.player.appendChild(vrContainer);
      } else if (this.stream_.vrContainer && this.stream_.vrContainer.parentNode) {
        this.stream_.vrContainer.parentNode.removeChild(this.stream_.vrContainer);
        this.stream_.vrContainer = null;
      }
    }
  }

  get videoNode() {
    let videoNode = this.videoNode_;

    if (!videoNode) {
      const player = rxcomp.getContext(this).node.querySelector('.agora-stream__player');
      videoNode = document.createElement('video');
      this.onLoadedMetadata = this.onLoadedMetadata.bind(this);
      videoNode.addEventListener('loadedmetadata', this.onLoadedMetadata);
      player.appendChild(videoNode);
      this.videoNode_ = videoNode;
    }

    return videoNode;
  }

  onInit() {
    this.videoMuted = false;
    this.audioMuted = false;
    this.shouldUseResumeGesture = false;
    this.state = {};
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.pushChanges(); // console.log('AgoraStreamComponent.StateService.state$', this.streamId, state);
    });
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // console.log('AgoraStreamComponent.MessageService.out$', this.streamId, message);
      switch (message.type) {
        case MessageType.AgoraEvent:
          const event = message.event; // console.log('AgoraStreamComponent.AgoraEvent', message.event);

          if (this.streamId && event.streamId === this.streamId) {
            if (event instanceof AgoraMuteVideoEvent) {
              this.videoMuted = true;
            }

            if (event instanceof AgoraUnmuteVideoEvent) {
              this.videoMuted = false;
            }

            if (event instanceof AgoraMuteAudioEvent) {
              this.audioMuted = true;
            }

            if (event instanceof AgoraUnmuteAudioEvent) {
              this.audioMuted = false;
            }
          }

          break;

        case MessageType.VRStarted:
          // console.log('AgoraStreamComponent.VRStarted', this.streamId, message.clientId, message.container);
          if (this.streamId === message.clientId) {
            this.vrContainer = message.container;
          }

          break;

        case MessageType.VREnded:
          // console.log('AgoraStreamComponent.VREnded', this.streamId, message.clientId);
          if (this.streamId === message.clientId) {
            this.vrContainer = null;
          }

          break;
      }
    });
  }

  setMediaStream(mediaStream) {
    const videoNode = this.videoNode;

    if ('srcObject' in videoNode) {
      videoNode.srcObject = mediaStream;
    } else {
      videoNode.src = mediaStream ? window.URL.createObjectURL(mediaStream) : null;
    }
  }

  onLoadedMetadata(event) {
    // console.log('AgoraStreamComponent.onLoadedMetadata', event);
    this.videoNode.play().then(success => {// console.log('AgoraStreamComponent.play.success', success);
    }, error => {
      console.log('AgoraStreamComponent.play.error', error);
    });
  }

  onToggleControl($event) {
    this.toggleControl.next($event);
  }

  onToggleSpy($event) {
    this.toggleSpy.next($event);
  }

}
AgoraStreamComponent.meta = {
  selector: '[agora-stream]',
  outputs: ['toggleControl', 'toggleSpy'],
  inputs: ['stream']
};/* global THREE */
const ViewType = {
  WaitingRoom: {
    id: 1,
    name: 'waiting-room'
  },
  Panorama: {
    id: 2,
    name: 'panorama'
  },
  PanoramaGrid: {
    id: 3,
    name: 'panorama-grid'
  },
  Room3d: {
    id: 4,
    name: 'room-3d'
  },
  Model: {
    id: 5,
    name: 'model'
  },
  Media: {
    id: 6,
    name: 'media'
  }
};
const ViewItemType = {
  Nav: {
    id: 1,
    name: 'nav'
  },
  Plane: {
    id: 2,
    name: 'plane'
  },
  CurvedPlane: {
    id: 3,
    name: 'curved-plane'
  },
  Model: {
    id: 4,
    name: 'model'
  },
  Texture: {
    id: 5,
    name: 'texture'
  }
};
class View$1 {
  // 'liked'
  constructor(options) {
    if (options) {
      Object.assign(this, options);
      this.updateIndices(options.items);
    }

    this.items = (this.items || []).filter(item => filterViewItem(item)).map(item => mapViewItem(item));

    if (this.tiles) {
      this.tiles = this.tiles.map(tile => mapViewTile(tile));
    }

    this.originalItems = this.items.slice();
    this.lastOrientation = {
      latitude: 0,
      longitude: 0
    };
    this.path = true;
  }

  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View$1.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'items':
            payload[key] = this[key].map(item => mapViewItem(item).payload);
            break;

          case 'tiles':
            payload[key] = this[key].map(tile => mapViewTile(tile).payload);
            break;

          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }

  get pathItems() {
    return this.items.filter(x => x.path);
  }

  get shortType() {
    return this.type ? this.type.split('-').map(x => x.substring(0, 1).toUpperCase()).join('') : '??';
  }

  updateIndices(items) {
    if (items) {
      let publisherStreamIndex = 0;
      let attendeeStreamIndex = 0;
      let smartDeviceStream = 0;
      let publisherScreenIndex = 0;
      let attendeeScreenIndex = 0;
      items.forEach((item, index) => {
        item.index = index;

        if (item.asset) {
          switch (item.asset.file) {
            case 'publisherStream':
              item.asset.index = publisherStreamIndex++;
              break;

            case 'nextAttendeeStream':
              item.asset.index = attendeeStreamIndex++;
              break;

            case 'smartDeviceStream':
              item.asset.index = smartDeviceStream++;
              break;

            case 'publisherScreen':
              item.asset.index = publisherScreenIndex++;
              break;

            case 'attendeeScreen':
              item.asset.index = attendeeScreenIndex++;
              break;
          }
        }
        /*
        if (item.asset && item.asset.file === 'publisherStream') {
        	item.asset.index = publisherStreamIndex++;
        }
        if (item.asset && item.asset.file === 'nextAttendeeStream') {
        	item.asset.index = attendeeStreamIndex++;
        }
        */

      });
    }
  }

}
View$1.allowedProps = ['id', 'type', 'name', 'hidden', 'likes', 'asset', 'items', 'orientation', 'zoom', 'ar', 'tiles', 'invertAxes', 'flipAxes'];
class PanoramaView extends View$1 {
  constructor(options) {
    super(options);
  }

}
class PanoramaGridView extends View$1 {
  static mapTiles(tiles, flipAxes, invertAxes, folder) {
    if (tiles === void 0) {
      tiles = [];
    }

    if (flipAxes === void 0) {
      flipAxes = false;
    }

    if (invertAxes === void 0) {
      invertAxes = false;
    }

    if (folder === void 0) {
      folder = '';
    }

    const axes = flipAxes ? -1 : 1;
    return tiles.map((tile, i) => {
      const indices = new THREE.Vector2();
      tile = typeof tile === 'string' ? {
        id: i + 1,
        asset: {
          folder: folder,
          file: tile
        },
        navs: []
      } : tile;
      tile.asset.file.replace(/_x([-|\d]+)_y([-|\d]+)/g, (a, b, c) => {
        if (invertAxes) {
          indices.y = parseInt(b);
          indices.x = parseInt(c) * axes;
        } else {
          indices.x = parseInt(b);
          indices.y = parseInt(c) * axes;
        }
      });
      return {
        id: tile.id,
        type: Object.assign({}, ViewType.PanoramaGrid),
        asset: tile.asset,
        navs: tile.navs || [],
        indices
      };
    });
  }

  set index(index) {
    if (this.index_ !== index) {
      this.index_ = index;
      this.tiles.forEach((tile, i) => tile.selected = i === index);
      this.updateCurrentItems(); // console.log('PanoramaGridView.index.set', index, this.items);

      this.index$.next(index);
    }
  }

  get index() {
    return this.index_;
  }

  constructor(options) {
    options.tiles = PanoramaGridView.mapTiles(options.tiles, options.flipAxes, options.invertAxes, options.asset ? options.asset.folder : '');
    super(options);
    /*
    if (!this.tiles.length) {
    	throw new Error('PanoramaGridView.constructor tile list is empty!');
    }
    */

    this.index_ = 0;
    this.index$ = new rxjs.Subject();
    this.tiles.forEach((tile, i) => tile.selected = i === 0);

    if (this.tiles.length) {
      this.items = this.originalItems.concat(this.tiles[0].navs);
      this.asset = this.tiles[0].asset;
    }
  }

  updateCurrentItems() {
    this.items = this.originalItems.concat(this.tiles[this.index_].navs);
  }

  getTileIndex(x, y) {
    return this.tiles.reduce((p, c, i) => {
      if (c.indices.x === x && c.indices.y === y) {
        return i;
      } else {
        return p;
      }
    }, -1);
  }

  hasTile(x, y) {
    return this.getTileIndex(x, y) !== -1;
  }

  getTile(x, y) {
    const index = this.getTileIndex(x, y);

    if (index !== -1) {
      this.index = index;
      return this.tiles[index];
    }
  }

}
class Room3DView extends View$1 {
  constructor(options) {
    super(options);
  }

}
class ModelView extends View$1 {
  constructor(options) {
    super(options);
  }

}
class MediaView extends View$1 {
  constructor(options) {
    super(options);
  }

}
class ViewItem {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }

    this.path = true;
    const links = this.links || (this.link ? [this.link] : []);
    this.links = links;
  }

  get firstLink() {
    return this.links && this.links.length ? this.links[0] : null;
  }

  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (ViewItem.allowedProps.indexOf(key) !== -1) {
        payload[key] = this[key];
      }
    });

    if (payload.link && (!payload.link.title || !payload.link.href)) {
      delete payload.link;
    }

    return payload;
  }

  get hasPanel() {
    return this.type.name === ViewItemType.Nav.name && (this.title && this.title !== '' || this.abstract && this.abstract !== '' || this.asset || this.link);
  }

}
ViewItem.allowedProps = ['id', 'type', 'title', 'abstract', 'asset', 'link', 'links', 'viewId', 'hook', 'hookExtra', 'keepOrientation', 'important', 'transparent', 'position', 'rotation', 'scale', 'radius', 'height', 'arc'];
class NavViewItem extends ViewItem {}
class ViewTile {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }

    this.navs = (this.navs || []).map(nav => mapViewItem(nav));
    this.originalItems = this.navs.slice();
  }

  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (ViewTile.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'navs':
            payload[key] = this[key].map(nav => mapViewItem(nav).payload);
            break;

          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }

}
ViewTile.allowedProps = ['id', 'asset', 'navs'];
function mapView(view) {
  switch (view.type.name) {
    case ViewType.Panorama.name:
      view = new PanoramaView(view);
      break;

    case ViewType.PanoramaGrid.name:
      view = new PanoramaGridView(view);
      break;

    case ViewType.Room3d.name:
      view = new Room3DView(view);
      break;

    case ViewType.Model.name:
      view = new ModelView(view);
      break;

    case ViewType.Media.name:
      view = new MediaView(view);
      break;

    default:
      view = new View$1(view);
  }

  return view;
}
function filterViewItem(item) {
  let flag;

  switch (item.type.name) {
    case ViewItemType.Nav.name:
      flag = item.viewId == null || isNavMove(item) || StateService.state.navigable;
      break;

    default:
      flag = true;
  }

  return flag;
}
function mapViewItem(item) {
  switch (item.type.name) {
    case ViewItemType.Nav.name:
      item = new NavViewItem(item);
      break;

    default:
      item = new ViewItem(item);
  }

  return item;
}
function mapViewTile(tile) {
  return new ViewTile(tile);
}
function isNavMove(item) {
  return !isValidText(item.title) && !isValidText(item.abstract);
}
function isValidText(text) {
  return text && text.length > 0;
}class Navmap {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }

    this.items = (this.items || []).map(item => mapViewItem(item));
    this.originalItems = this.items.slice();
  }

  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'items':
            payload[key] = this[key].map(item => mapViewItem(item).payload);
            break;

          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }

}
Navmap.allowedProps = ['id', 'name', 'asset', 'items'];
function mapNavmap(map) {
  map = new Navmap(map);
  return map;
}class NavmapService {
  static set active(active) {
    this.active$.next(active);
  }

  static get active() {
    return this.active$.getValue();
  }

  static navmapGet$() {
    return HttpService.get$(`/api/navmap`).pipe(operators.map(data => {
      data.navmaps.map(navmap => mapNavmap(navmap));
      return data.navmaps;
    }));
  }

  static navmapCreate$(navmap) {
    return HttpService.post$(`/api/navmap`, navmap).pipe(operators.map(navmap => mapNavmap(navmap)));
  }

  static navmapUpdate$(navmap) {
    return HttpService.put$(`/api/navmap/${navmap.id}`, navmap).pipe(operators.map(x => mapNavmap(x)));
  }

  static navmapDelete$(navmap) {
    return HttpService.delete$(`/api/navmap/${navmap.id}`);
  }

  static itemCreate$(navmap, item) {
    return HttpService.post$(`/api/navmap/${navmap.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }

  static itemUpdate$(navmap, item) {
    item = mapViewItem(item); // !!! ??

    return HttpService.put$(`/api/navmap/${navmap.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }

  static itemDelete$(navmap, item) {
    return HttpService.delete$(`/api/navmap/${navmap.id}/item/${item.id}`);
  }

}
NavmapService.active$ = new rxjs.BehaviorSubject(false);function push_(event) {
  const dataLayer = window.dataLayer || [];
  dataLayer.push(event);
  console.log('GtmService.dataLayer', event);
}

class GtmService {
  static push(event) {
    return push_(event);
  }

}const ToastType = {
  Info: 'info',
  Alert: 'alert',
  Dialog: 'dialog'
};
const ToastPosition = {
  Centered: 'centered',
  TopLeft: 'top-left',
  Top: 'top',
  TopRight: 'top-right',
  Right: 'right',
  BottomRight: 'bottom-right',
  Bottom: 'bottom',
  BottomLeft: 'bottom-left',
  Left: 'left'
};
class ToastEvent {
  constructor(toast) {
    this.toast = toast;
  }

}
class ToastResolveEvent extends ToastEvent {}
class ToastRejectEvent extends ToastEvent {}
class ToastService {
  static open$(toast) {
    toast.id = new Date().getTime();
    toast.type = toast.type || ToastType.Info;
    toast.position = toast.position || ToastPosition.Centered;

    switch (toast.type) {
      case ToastType.Alert:
        toast.acceptMessage = toast.acceptMessage || `Ok`;
        break;

      case ToastType.Dialog:
        toast.acceptMessage = toast.acceptMessage || `Accept`;
        toast.rejectMessage = toast.rejectMessage || `Reject`;
        break;
    }

    this.toast$.next(toast);

    if (toast.type === ToastType.Info) {
      setTimeout(() => {
        this.resolve(toast);
      }, toast.duration || 4000);
    }

    return this.events$;
    /*
    return of(toast).pipe(
    	tap(toast => this.toast$.next(toast)),
    	switchMap(toast => this.events$),
    );
    */
  }

  static resolve(toast) {
    this.toast$.next(null);
    this.events$.next(new ToastResolveEvent(toast));
  }

  static reject(toast) {
    this.toast$.next(null);
    this.events$.next(new ToastRejectEvent(toast));
  }

}
ToastService.toast$ = new rxjs.Subject();
ToastService.events$ = new rxjs.Subject();class ModalOutletComponent extends rxcomp.Component {
  get modal() {
    return this.modal_;
  }

  set modal(modal) {
    // console.log('ModalOutletComponent set modal', modal, this);
    const {
      module
    } = rxcomp.getContext(this);

    if (this.modal_ && this.modal_.node) {
      module.remove(this.modal_.node, this);
      this.modalNode.removeChild(this.modal_.node);
    }

    if (modal && modal.node) {
      this.modal_ = modal;
      this.modalNode.appendChild(modal.node);
      module.compile(modal.node);
    }

    this.modal_ = modal;
    this.pushChanges();
  }

  get busy() {
    return this.busy_;
  }

  set busy(busy) {
    // console.log('ModalOutletComponent set busy', busy, this);
    if (this.busy_ !== busy) {
      this.busy_ = busy;
      this.pushChanges();
    }
  }

  onInit() {
    this.busy_ = false;
    const {
      node
    } = rxcomp.getContext(this);
    this.modalNode = node.querySelector('.modal-outlet__modal');
    ModalService.modal$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(modal => this.modal = modal);
    ModalService.busy$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(busy => this.busy = busy);
  }

  reject(event) {
    ModalService.reject();
  }

}
ModalOutletComponent.meta = {
  selector: '[modal-outlet]',
  template:
  /* html */
  `
	<div class="modal-outlet__container" [class]="{ active: modal, busy: busy }">
		<div class="modal-outlet__background" (click)="reject($event)"></div>
		<div class="modal-outlet__modal"></div>
		<!-- spinner -->
		<div class="spinner spinner--contrasted" *if="busy"></div>
	</div>
	`
};class TryInARModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance,
      node
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      const data = this.data = parentInstance.modal.data; // console.log('data', data);

      if (data && data.ar) {
        const url = TryInARModalComponent.getUrl(data);
        new QRious({
          element: node.querySelector('.qrcode'),
          value: url,
          size: 256
        });
      }
    }
  }

  onClose() {
    ModalService.reject();
  }

  static getUrl(data) {
    const path = RouterService.buildUrl(RoutePipe.transform(':lang.tryInAr'), {
      viewId: data.id
    });
    const url = window.location.origin + path;
    console.log('TryInARModalComponent.getUrl', url);
    return url;
  }

  static openInAR(data) {
    const url = this.getUrl(data);
    window.open(url, '_blank');
  }

}
TryInARModalComponent.meta = {
  selector: '[try-in-ar-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Inquadra il qrcode con il cellulare o il tablet per vedere il VR.</div>
				<div class="picture">
					<canvas class="qrcode"></canvas>
				</div>
				<div class="group--cta">
					<button type="button" class="btn--accept" (click)="onClose()">
						<span>Chiudi</span>
					</button>
				</div>
			</div>
		</div>
	`
};

TryInARModalComponent.chunk = () =>
/* html */
`<div class="try-in-ar-modal" try-in-ar-modal></div>`;const EXT_IMAGE = ['jpeg', 'jpg', 'png', 'hdr'];
const EXT_VIDEO = ['mp4', 'webm'];
const EXT_MODEL = ['fbx', 'gltf', 'glb', 'usdz'];
const AssetType = {
  Image: {
    id: 1,
    name: 'image'
  },
  // jpg, png, ...
  Video: {
    id: 2,
    name: 'video'
  },
  // mp4, webm, ...
  Model: {
    id: 3,
    name: 'model'
  },
  // fbx, gltf, glb, usdz ...
  PublisherStream: {
    id: 4,
    name: 'publisher-stream',
    file: 'publisherStream'
  },
  // valore fisso di file a ‘publisherStream’ e folder string.empty
  AttendeeStream: {
    id: 5,
    name: 'next-attendee-stream',
    file: 'nextAttendeeStream'
  },
  // valore fisso di file a ‘nextAttendeeStream’ e folder string.empty
  PublisherScreen: {
    id: 6,
    name: 'publisher-screen',
    file: 'publisherScreen'
  },
  // valore fisso di file a ‘publisherScreen’ e folder string.empty
  AttendeeScreen: {
    id: 7,
    name: 'attendee-screen',
    file: 'attendeeScreen'
  },
  // valore fisso di file a ‘attendeeScreen’ e folder string.empty
  SmartDeviceStream: {
    id: 8,
    name: 'smart-device-stream',
    file: 'smartDeviceStream'
  } // valore fisso di file a smartDeviceStream e folder string.empty

};
const AssetGroupType = {
  ImageOrVideo: {
    id: 1,
    name: 'Image or Video',
    ids: [1, 2]
  },
  // Model: { id: 2, name: 'Model 3D', ids: [3] },
  Publisher: {
    id: 3,
    name: 'Publisher',
    ids: [4]
  },
  Attendee: {
    id: 4,
    name: 'Attendee',
    ids: [5]
  } // PublisherScreen: { id: 5, name: 'PublisherScreen', ids: [6] },
  // AttendeeScreen: { id: 6, name: 'AttendeeScreen', ids: [7] },

};
function AssetGroupTypeInit() {
  // console.log('environment.flags.editorAssetScreen', environment.flags.editorAssetScreen, environment);
  if (environment.flags.editorAssetScreen) {
    AssetGroupType.PublisherScreen = {
      id: 5,
      name: 'PublisherScreen',
      ids: [6]
    };
    AssetGroupType.AttendeeScreen = {
      id: 6,
      name: 'AttendeeScreen',
      ids: [7]
    };
  }

  AssetGroupType.SmartDevice = {
    id: 7,
    name: 'Smart Device',
    ids: [8]
  };
}
const STREAM_TYPES = [AssetType.PublisherStream.name, AssetType.AttendeeStream.name, AssetType.PublisherScreen.name, AssetType.AttendeeScreen.name, AssetType.SmartDeviceStream.name];
function assetIsStream(asset) {
  // console.log('assetIsStream', asset.type.name, STREAM_TYPES);
  return asset && STREAM_TYPES.indexOf(asset.type.name) !== -1;
}
function assetTypeById(id) {
  const type = Object.keys(AssetType).reduce((p, key) => {
    const type = AssetType[key];
    return type.id === id ? type : p;
  }, null);
  return type; // return Object.keys(AssetType).map(x => AssetType[x]).find(x => x.id === id);
}
function assetGroupTypeById(id) {
  const type = Object.keys(AssetGroupType).reduce((p, key) => {
    const type = AssetGroupType[key];
    return type.id === id ? type : p;
  }, null);
  return type; // return Object.keys(AssetGroupType).map(x => AssetGroupType[x]).find(x => x.id === id);
}
function assetGroupTypeFromItem(item) {
  let key;

  if (item && item.asset) {
    key = Object.keys(AssetGroupType).find(key => {
      // console.log(key, AssetGroupType[key].ids, item.asset.type.id);
      return AssetGroupType[key].ids.indexOf(item.asset.type.id) !== -1;
    });
  }

  return AssetGroupType[key || 'ImageOrVideo'];
}
function assetPayloadFromGroupTypeId(groupTypeId) {
  const groupType = assetGroupTypeById(groupTypeId);
  const type = assetTypeById(groupType.ids[0]);
  const file = type.file;
  const asset = {
    type: type,
    folder: '',
    file: file
  }; // console.log('assetPayloadFromGroupTypeId', asset);

  return new Asset(asset);
}
function assetTypeFromPath(path) {
  const extension = path.split('.').pop().toLowerCase();

  if (EXT_IMAGE.indexOf(extension) !== -1) {
    return AssetType.Image;
  } else if (EXT_VIDEO.indexOf(extension) !== -1) {
    return AssetType.Video;
  } else if (EXT_MODEL.indexOf(extension) !== -1) {
    return AssetType.Model;
  }
}
class Asset {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }

  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (Asset.allowedProps.indexOf(key) !== -1) {
        payload[key] = this[key];
      }
    });
    return payload;
  }

  static fromUrl(url) {
    const segments = url.split('/');
    const file = segments.pop();
    const folder = segments.join('/') + '/';
    const type = assetTypeFromPath(file);
    return new Asset({
      type: type,
      folder: folder,
      file: file
    });
  }

  static get defaultMediaAsset() {
    const asset = {
      id: -1,
      type: {
        id: AssetType.Image,
        name: 'image'
      },
      folder: '/textures/grid/',
      file: 'grid.jpg'
    };
    return asset;
  }

}
Asset.allowedProps = ['id', 'type', 'folder', 'file', 'linkedPlayId', 'chromaKeyColor', 'autoplay', 'loop'];
function mapAsset(asset) {
  switch (asset.type.name) {
    default:
      asset = new Asset(asset);
  }

  return asset;
}const DEFAULT_WAITING_ROOM = {
  id: 'waiting-room',
  type: {
    id: 1,
    name: 'waiting-room'
  },
  name: 'Waiting Room',
  likes: 0,
  liked: false,
  asset: {
    type: {
      id: 1,
      name: 'image'
    },
    folder: '/textures/waiting-room/',
    file: 'waiting-room.jpg'
  },
  items: [],
  orientation: {
    latitude: 0,
    longitude: 0
  }
};
class ViewService {
  static get dataViews() {
    return this.data ? this.data.views : [];
  }

  static get validViews() {
    return this.data ? this.data.views.filter(x => x.type.name !== ViewType.WaitingRoom.name) : [];
  }

  static get pathViews() {
    const views = this.validViews;
    return views.filter(x => x.path);
  }

  static get validPathViews() {
    const views = this.editor ? this.data.views : this.validViews;
    return views.filter(x => x.path);
  } // action: { viewId:number, keepOrientation:boolean, useLastOrientation:boolean };


  static set action(action) {
    this.action$_.next(action);
  }

  static get action() {
    return this.action$_.getValue();
  } // static viewId$_ = new BehaviorSubject(null);


  static set viewId(viewId) {
    this.action$_.next({
      viewId,
      keepOrientation: false,
      useLastOrientation: false
    });
  }

  static get viewId() {
    const action = this.action$_.getValue();
    return action ? action.viewId : null;
  }

  static getDataView(viewId) {
    const views = this.dataViews;
    return views.find(x => x.id === viewId) || null;
  }

  static get currentView() {
    const viewId = this.viewId;

    if (viewId !== null) {
      return this.getDataView(viewId);
    }

    return null;
  }

  static getValidPathId(viewId) {
    if (!viewId) {
      return null;
    }

    const views = this.validPathViews;

    if (views.find(x => x.id === viewId) == null) {
      return null;
    }

    return viewId;
  }

  static getFirstPathId() {
    const views = this.editor && this.path.id === null ? this.dataViews : this.pathViews; // console.log('ViewService.getFirstPathId', this.editor, this.path, views);

    return views.length ? views[0].id : null;
  }

  static data$() {
    if (!this.data$_) {
      const dataUrl = (environment.flags.production ? '/api/view' : `${environment.assets}api/data.json`) + '?lang=' + LanguageService.lang;
      this.data$_ = HttpService.get$(dataUrl).pipe(operators.map(data => {
        data.views = data.views.map(view => mapView(view));
        this.data = data;
        return data;
      }), operators.shareReplay(1));
    }

    return this.data$_;
  }

  static view$() {
    // const editor = this.editor;
    const meetingUrl = new MeetingUrl(); // const pathId = meetingUrl.pathId;

    const viewId = this.getValidPathId(meetingUrl.viewId);
    const embedViewId = this.getValidPathId(meetingUrl.embedViewId);
    const initialViewId = embedViewId || viewId || this.getFirstPathId(); // console.log('ViewService.view$', viewId, embedViewId, initialViewId);

    this.action$_.next({
      viewId: initialViewId
    });
    return this.action$_.pipe(operators.distinctUntilChanged((a, b) => a.viewId === b.viewId), operators.map(action => {
      // const view = data.views.find(view => view.id === action.viewId);
      // console.log('ViewService.view$', 'path', path);
      // filter path
      let view = this.dataViews.find(view => view.id === action.viewId);
      /*
      if (path && !editor) {
      	if (path.items.indexOf(view.id) === -1) {
      		const newView = Object.assign({}, view);
      		newView.items = view.items.filter(x => {
      			if (x.type.name === ViewItemType.Nav.name) {
      				return path.items.indexOf(x.viewId) === -1;
      			} else {
      				return true;
      			}
      		});
      		view = mapView(newView);
      	} else {
      		view = null;
      	}
      }
      // console.log('ViewService.view$', view, path);
      */

      if (view) {
        view.keepOrientation = action.keepOrientation || false;
        view.useLastOrientation = action.useLastOrientation || false;
      } // console.log('ViewService.view$', action.viewId, action.keepOrientation, action.useLastOrientation);


      return view || this.getWaitingRoom();
    }));
  }

  static setDataAndPath(data, path) {
    this.data = data;
    data.views.forEach(view => {
      view.path = !path || path.items.indexOf(view.id) === -1;
      view.items.forEach(item => {
        let valid = true;

        if (path) {
          if (item.type.name === ViewItemType.Nav.name) {
            valid = path.items.indexOf(item.viewId) === -1;
          }

          item.path = valid;
        }
      });
    });
    this.path = path;
  }

  static hostedView$(data, path) {
    this.setDataAndPath(data, path);
    this.editor = false;
    const waitingRoom = this.getWaitingRoom();
    return rxjs.combineLatest([this.view$(), this.hosted$()]).pipe(operators.map(datas => {
      const view = datas[0];
      const hosted = datas[1];
      return hosted ? view : waitingRoom;
    }), operators.distinctUntilChanged((a, b) => {
      return a.id === b.id;
    }), operators.tap(view => {
      if (view.id !== waitingRoom.id) {
        MeetingUrl.replaceWithOptions({
          viewId: view.id
        });
        const prefetchAssets = ViewService.getPrefetchAssets(view);
        view.prefetchAssets = prefetchAssets;
      }
    }));
  }

  static editorView$(data, path) {
    this.setDataAndPath(data, path);
    this.editor = true;
    const waitingRoom = this.getWaitingRoom();
    return this.view$().pipe(operators.map(view => {
      // console.log('ViewService.editorView$.view', view.updateIndices);
      const options = {
        pathId: null
      };

      if (view.id !== waitingRoom.id) {
        options.viewId = view.id;
      }

      if (path && path.id !== null) {
        options.pathId = path.id;
      }

      MeetingUrl.replaceWithOptions(options);
      return view;
    }));
  }

  static hosted$() {
    return StateService.state$.pipe(operators.map(state => state.hosted), operators.distinctUntilChanged());
  }

  static viewById$(viewId) {
    return this.data$().pipe(operators.map(data => this.dataViews.find(x => x.id === viewId)));
  }

  static viewLike$(view) {
    if (!view.liked) {
      view.liked = true;

      if (environment.flags.production) {
        return HttpService.get$(`/api/view/${view.id}/like`);
      } else {
        view.likes = view.likes || 0;
        view.likes++;
        return rxjs.of(view);
      }
    } else {
      return rxjs.of(null);
    }
  }

  static setViewLike$(message) {
    return this.viewById$(message.viewId).pipe(operators.tap(view => {
      if (view) {
        view.likes = message.likes;
      }
    }));
  }

  static getWaitingRoom() {
    return this.dataViews.find(x => x.type.name === ViewType.WaitingRoom.name) || DEFAULT_WAITING_ROOM;
  }

  static getPrefetchAssets(view) {
    const views = this.validPathViews;
    const assets = view.items // filter nav items
    .filter(x => x.type.name === ViewItemType.Nav.name && x.viewId != null) // map to view
    .map(x => views.find(v => v.id === x.viewId)) // filter view with image
    .filter(v => v && v.asset && v.asset.type.name === AssetType.Image.name) // map to asset
    .map(v => environment.getPath(v.asset.folder + v.asset.file)); // console.log('ViewService.getPrefetchAssets', assets);

    return assets;
  }

  static addView(view) {
    const data = this.data;
    const views = data.views.slice();
    views.push(view);
    data.views = views;
    this.viewId = view.id;
  }

  static deleteView(view) {
    const data = this.data;
    const views = data.views.slice();
    const index = views.reduce((p, c, i) => {
      return c.id === view.id ? i : p;
    }, -1);

    if (index > 0) {
      views.splice(index, 1);
      data.views = views;
      const dataViews = this.dataViews;

      if (dataViews.length > 0) {
        this.viewId = dataViews[0].id;
      }
    } // this.pushChanges();

  }

}
ViewService.action$_ = new rxjs.BehaviorSubject(null);let items$_ = null;
class WishlistService {
  static get items$() {
    if (!items$_) {
      const items = LocalStorageService.get('wishlist') || [];
      items$_ = new rxjs.BehaviorSubject(items);
    }

    return items$_;
  }

  static getItems() {
    return this.items$.getValue();
  }

  static indexOf(item) {
    const items = this.getItems();
    return items.reduce((p, c, i) => {
      return p === -1 && c.viewId === item.viewId && c.itemId === item.itemId ? i : p;
    }, -1);
  }

  static has(item) {
    return this.indexOf(item) !== -1;
  }

  static add$(item) {
    const items = this.getItems();

    if (!this.has(item)) {
      items.push(item);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }

    return this.items$;
  }

  static remove$(item) {
    const items = this.getItems();
    const index = this.indexOf(item);

    if (index !== -1) {
      items.splice(index, 1);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }

    return this.items$;
  }

  static toggle$(item) {
    const items = this.getItems();
    const index = this.indexOf(item);

    if (index !== -1) {
      items.splice(index, 1);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    } else {
      items.push(item);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }

    return this.items$;
  }

}class MediaLoaderEvent {
  constructor(loader) {
    this.loader = loader;
  }

}
class MediaLoaderPlayEvent extends MediaLoaderEvent {}
class MediaLoaderPauseEvent extends MediaLoaderEvent {}
class MediaLoaderDisposeEvent extends MediaLoaderEvent {}
class MediaLoaderTimeUpdateEvent extends MediaLoaderEvent {}
class MediaLoaderTimeSetEvent extends MediaLoaderEvent {}
class MediaLoader {
  static getLoader() {
    return MediaLoader.loader || (MediaLoader.loader = new THREE.TextureLoader());
  }

  static getPath(item) {
    return environment.getPath(item.asset.folder + item.asset.file);
  }

  static loadTexture(item, callback) {
    const path = MediaLoader.getPath(item);
    return MediaLoader.getLoader().load(path, callback);
  }

  static isVideo(item) {
    return item.asset && item.asset.file && (item.asset.file.indexOf('.mp4') !== -1 || item.asset.file.indexOf('.webm') !== -1);
  }

  static isStream(item) {
    return assetIsStream(item.asset);
  }

  static isMutedStream(item) {
    let isMutedStream = false;

    switch (item.asset.type.name) {
      case AssetType.PublisherStream.name:
        isMutedStream = StateService.state.role === RoleType.Publisher;
        break;

      case AssetType.AttendeeStream.name:
        isMutedStream = StateService.state.role === RoleType.Attendee;
        break;

      case AssetType.PublisherScreen.name:
        isMutedStream = true;
        break;

      case AssetType.AttendeeScreen.name:
        isMutedStream = true;
        break;

      case AssetType.SmartDeviceStream.name:
        isMutedStream = StateService.state.role === RoleType.SmartDevice;
        break;
    } // console.log('isMutedStream', isMutedStream, item.asset.type.name, AssetType.PublisherStream.name, StateService.state.role, RoleType.Publisher);


    return isMutedStream;
  }

  static isPublisherStream(item) {
    return item.asset && item.asset.type.name === AssetType.PublisherStream.name;
  }

  static isAttendeeStream(item) {
    return item.asset && item.asset.type.name === AssetType.AttendeeStream.name;
  }

  static isSmartDeviceStream(item) {
    return item.asset && item.asset.type.name === AssetType.SmartDeviceStream.name;
  }

  static isPublisherScreen(item) {
    return item.asset && item.asset.type.name === AssetType.PublisherScreen.name;
  }

  static isAttendeeScreen(item) {
    return item.asset && item.asset.type.name === AssetType.AttendeeScreen.name;
  }

  get isVideo() {
    return MediaLoader.isVideo(this.item);
  }

  get isStream() {
    return MediaLoader.isStream(this.item);
  }

  get isMutedStream() {
    return MediaLoader.isMutedStream(this.item);
  }

  get isPublisherStream() {
    return MediaLoader.isPublisherStream(this.item);
  }

  get isAttendeeStream() {
    return MediaLoader.isAttendeeStream(this.item);
  }

  get isSmartDeviceStream() {
    return MediaLoader.isSmartDeviceStream(this.item);
  }

  get isPublisherScreen() {
    return MediaLoader.isPublisherScreen(this.item);
  }

  get isAttendeeScreen() {
    return MediaLoader.isAttendeeScreen(this.item);
  }

  get isPlayableVideo() {
    return this.isVideo; // && !this.item.asset.autoplay;
  }

  get isAutoplayVideo() {
    return this.isStream; // || (this.isVideo && (this.item.asset.autoplay != null));
  }

  get muted() {
    return this.muted_;
  }

  set muted(muted) {
    this.muted_ = muted; // console.log('MediaLoader.muted', muted, this.video);

    if (this.video && this.isVideo) {
      this.video.muted = muted === true;
    }
  }

  constructor(item) {
    this.item = item;
    this.toggle = this.toggle.bind(this);
    this.muted_ = false;
    this.subscription = StateService.state$.subscribe(state => this.muted = state.volumeMuted);
  }

  load(callback) {
    const item = this.item;
    let texture; // console.log('MediaLoader.load', item, this.isStream);

    if (this.isStream && item.streamId) {
      const streamId = item.streamId;
      const video = document.querySelector(`#stream-${streamId} video`); // document.querySelector(`#stream-remote-${streamId} video`) || document.querySelector(`#stream-local-${streamId} video`);

      if (!video) {
        return;
      }

      const onCanPlay = () => {
        if (this.disposed) {
          return;
        }

        video.removeEventListener('canplay', onCanPlay);
        texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;
        // texture.image.width = video.videoWidth;
        // texture.image.height = video.videoHeight;

        texture.needsUpdate = true;

        if (typeof callback === 'function') {
          callback(texture, this);
        }
      };

      const isMutedStream = this.isMutedStream;
      video.crossOrigin = 'anonymous';
      video.volume = isMutedStream ? 0 : 1;
      video.muted = isMutedStream;

      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onCanPlay();
      } else {
        video.addEventListener('canplay', onCanPlay);
      }
    } else if (this.isVideo) {
      // create the video element
      const autoplay = item.asset && item.asset.autoplay || false;
      const loop = item.asset && item.asset.loop || false;
      const video = this.video = document.createElement('video');
      video.crossOrigin = 'anonymous';
      video.preload = 'metadata';
      video.volume = 0.8;
      video.muted = autoplay;
      video.playsInline = true;
      video.loop = loop;

      const onCanPlay = () => {
        if (this.disposed) {
          return;
        } // console.log('MediaLoader', 'onCanPlay');


        video.oncanplay = null;
        texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping; // texture.encoding = THREE.sRGBEncoding;
        // texture.format = THREE.RGBAFormat;
        // texture.image.width = video.videoWidth;
        // texture.image.height = video.videoHeight;

        texture.needsUpdate = true;

        if (typeof callback === 'function') {
          callback(texture, this);
        }

        if (autoplay) {
          this.play(item.silent);
        } else {
          video.pause();
        }
      };

      const onTimeUpdate = () => {
        if (this.disposed) {
          return;
        }

        MediaLoader.events$.next(new MediaLoaderTimeUpdateEvent(this));
      };

      const onEnded = () => {
        if (this.disposed) {
          return;
        }

        if (!loop) {
          MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
        }
      };

      video.oncanplay = onCanPlay;
      video.ontimeupdate = onTimeUpdate;
      video.onended = onEnded;
      video.src = MediaLoader.getPath(item);
      video.load(); // must call after setting/changing source
    } else if (item.asset) {
      MediaLoader.loadTexture(item, texture => {
        if (this.disposed) {
          return;
        }

        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;

        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;

        if (typeof callback === 'function') {
          callback(texture, this);
        }
      });
    } else {
      callback(null, this);
    }

    return this;
  }

  get progress() {
    if (this.video) {
      return this.video.currentTime / this.video.duration;
    } else {
      return 0;
    }
  }

  set progress(progress) {
    if (this.video) {
      const currentTime = this.video.duration * progress;

      if (this.video.seekable.length > progress && this.video.currentTime !== currentTime) {
        // console.log('MediaLoader', 'progress', progress, 'currentTime', currentTime, 'duration', this.video.duration, 'seekable', this.video.seekable);
        this.video.currentTime = currentTime;
        MediaLoader.events$.next(new MediaLoaderTimeSetEvent(this));
      }
    }
  }

  play(silent) {
    // console.log('MediaLoader.play');
    if (this.video) {
      this.video.muted = this.muted_;
      this.video.play().then(() => {
        // console.log('MediaLoader.play.success', this.item.asset.file);
        if (!silent) {
          MediaLoader.events$.next(new MediaLoaderPlayEvent(this));
        }
      }, error => {
        console.log('MediaLoader.play.error', this.item.asset.file, error);
      });
    }
  }

  pause(silent) {
    // console.log('MediaLoader.pause');
    if (this.video && this.isVideo) {
      this.video.muted = true;
      this.video.pause();

      if (!silent) {
        MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
      }
    }
  }

  toggle() {
    // console.log('MediaLoader.toggle', this.video);
    if (this.video && this.isVideo) {
      if (this.video.paused) {
        this.video.muted = this.muted_;
        this.play();
        return true;
      } else {
        this.pause();
        return false;
      }
    }
  }

  dispose() {
    // console.log('MediaLoader.dispose');
    this.subscription.unsubscribe();
    this.pause(true);

    if (this.isVideo && this.video) {
      this.video.ontimeupdate = null;
      this.video.onended = null;
      MediaLoader.events$.next(new MediaLoaderDisposeEvent(this));
    }

    this.disposed = true;
    delete this.video;
  }

}
MediaLoader.events$ = new rxjs.ReplaySubject(1);// import * as THREE from 'three';
const PANORAMA_RADIUS = 101;
class Geometry {
  static get defaultGeometry() {
    return Geometry.defaultGeometry_ || (Geometry.defaultGeometry_ = new THREE.BoxBufferGeometry(1, 1, 1));
  }

  static get planeGeometry() {
    return Geometry.planeGeometry_ || (Geometry.planeGeometry_ = new THREE.PlaneBufferGeometry(1, 1, 2, 2));
  }

  static get sphereGeometry() {
    return Geometry.sphereGeometry_ || (Geometry.sphereGeometry_ = new THREE.SphereBufferGeometry(3, 12, 12));
  }

  static get panoramaGeometry() {
    return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.SphereBufferGeometry(PANORAMA_RADIUS, 36, 36)); // 101, 44, 30
    // return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.IcosahedronBufferGeometry(PANORAMA_RADIUS, 4)); // 101, 44, 30
    // return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.SphereBufferGeometry(PANORAMA_RADIUS, 40, 40)); // 101, 44, 30
  }

}// import * as THREE from 'three';
new THREE.Vector3();
class Host {
  static get origin() {
    const host = this.host;

    if (host) {
      const origin = this.origin_;
      origin.set(0, 0, 0);
      const camera = host.renderer.xr.isPresenting ? host.renderer.xr.getCamera(host.camera) : host.camera;
      camera.localToWorld(origin); // return host.cameraGroup.position;
    }

    return this.origin_;
  }

  static getDistanceToCamera(camera, fov, aspect, size, fitOffset) {
    if (fitOffset === void 0) {
      fitOffset = 0.88;
    }

    const factor = 2 * Math.atan(Math.PI * fov / 360);
    const heightDistance = size.y * camera.zoom / factor;
    const widthDistance = size.x * camera.zoom / factor / aspect;
    const distance = fitOffset * Math.max(heightDistance, widthDistance);
    return distance;
  }

}
Host.origin_ = new THREE.Vector3();// import DebugService from '../debug.service';
class Interactive {}
Interactive.items = [];
Interactive.hittest = interactiveHittest.bind(Interactive);
Interactive.dispose = interactiveDispose.bind(Interactive);
function interactiveHittest(raycaster, down, event) {
  if (down === void 0) {
    down = false;
  }

  // const debugService = DebugService.getService();
  let dirty = false;

  if (this.down !== down) {
    this.down = down;
    this.lock = false;
    dirty = true;
  }

  const items = this.items.filter(x => x.parent && !x.freezed);
  const intersections = raycaster.intersectObjects(items);
  let key, hit;
  const hash = {};
  intersections.forEach((intersection, i) => {
    const object = intersection.object;
    key = object.uuid;

    if (i === 0) {
      if (this.lastIntersectedObject !== object || dirty) {
        this.lastIntersectedObject = object;
        hit = object; // debugService.setMessage(hit.name || hit.id);
        // haptic feedback
      } else if (object.intersection && (Math.abs(object.intersection.point.x - intersection.point.x) > 0.01 || Math.abs(object.intersection.point.y - intersection.point.y) > 0.01)) {
        object.intersection = intersection;
        object.emit('move', object);
      }
    }

    hash[key] = intersection;
  });

  if (intersections.length === 0) {
    this.lastIntersectedObject = null;
  }

  items.forEach(x => {
    x.intersection = hash[x.uuid];
    x.over = x === this.lastIntersectedObject || x.intersection && !x.depthTest && (!this.lastIntersectedObject || this.lastIntersectedObject.depthTest);
    x.down = down && x.over && !this.lock;

    if (x.down) {
      this.lock = true;
    }
  });
  return hit;
}
function interactiveDispose(object) {
  if (object) {
    const index = this.items.indexOf(object);

    if (index !== -1) {
      this.items.splice(index, 1);
    }
  }
}// import * as THREE from 'three';
class FreezableMesh extends three.Mesh {
  get freezed() {
    return this.freezed_;
  }

  set freezed(freezed) {
    // !!! cycle through freezable and not freezable
    this.freezed_ = freezed;
    this.children.filter(x => x.__lookupGetter__('freezed')).forEach(x => x.freezed = freezed);
  }

  constructor(geometry, material) {
    geometry = geometry || Geometry.defaultGeometry;
    material = material || new THREE.MeshBasicMaterial({
      color: 0xff00ff // opacity: 1,
      // transparent: true,

    });
    super(geometry, material);
    this.freezed = false;
  }

  freeze() {
    this.freezed = true;
  }

  unfreeze() {
    this.freezed = false;
  }

}// import * as THREE from 'three';
class EmittableMesh extends FreezableMesh {
  constructor(geometry, material) {
    geometry = geometry || Geometry.defaultGeometry;
    material = material || new THREE.MeshBasicMaterial({
      color: 0xff00ff // opacity: 1,
      // transparent: true,

    });
    super(geometry, material);
    this.events = {};
  }

  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }

  off(type, callback) {
    const event = this.events[type];

    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }

  emit(type, data) {
    const event = this.events[type];

    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }

    const broadcast = this.events.broadcast;

    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }

}class InteractiveMesh extends EmittableMesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.depthTest = true;
    this.over_ = false;
    this.down_ = false;
    Interactive.items.push(this);
  }

  get isInteractiveMesh() {
    return true;
  }

  get over() {
    return this.over_;
  }

  set over(over) {
    if (this.over_ != over) {
      this.over_ = over;
      /*
      if (over) {
      	this.emit('hit', this);
      }
      */

      if (over) {
        this.emit('over', this);
      } else {
        this.emit('out', this);
      }
    }
  }

  get down() {
    return this.down_;
  }

  set down(down) {
    down = down && this.over;

    if (this.down_ != down) {
      this.down_ = down;

      if (down) {
        this.emit('down', this);
      } else {
        this.emit('up', this);
      }
    }
  }

}// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

class RGBELoader extends three.DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = three.HalfFloatType;

	}

	// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

	parse( buffer ) {

		const
			/* return codes for rgbe routines */
			//RGBE_RETURN_SUCCESS = 0,
			RGBE_RETURN_FAILURE = - 1,

			/* default error routine.  change this to change error handling */
			rgbe_read_error = 1,
			rgbe_write_error = 2,
			rgbe_format_error = 3,
			rgbe_memory_error = 4,
			rgbe_error = function ( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {

					case rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );
						break;
					case rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );
						break;
					case rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );
						break;
					default:
					case rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );

				}

				return RGBE_RETURN_FAILURE;

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			//RGBE_DATA_RED = 0,
			//RGBE_DATA_GREEN = 1,
			//RGBE_DATA_BLUE = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			//RGBE_DATA_SIZE = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE = 1,
			RGBE_VALID_FORMAT = 2,
			RGBE_VALID_DIMENSIONS = 4,

			NEWLINE = '\n',

			fgets = function ( buffer, lineLimit, consume ) {

				const chunkSize = 128;

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				let p = buffer.pos,
					i = - 1, len = 0, s = '',
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( - 1 < i ) {

					/*for (i=l-1; i>=0; i--) {
						byteCode = m.charCodeAt(i);
						if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
						else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
						if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
					}*/
					if ( false !== consume ) buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}

				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function ( buffer ) {


				// regexes to parse header info fields
				const magic_token_re = /^#\?(\S+)/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0, /* indicate which fields are valid */

						string: '', /* the actual header string */

						comments: '', /* comments found in header */

						programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

						format: '', /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

						exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

						width: 0, height: 0 /* image dimensions, width/height */

					};

				let line, match;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					return rgbe_error( rgbe_read_error, 'no header found' );

				}

				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					return rgbe_error( rgbe_format_error, 'bad initial token' );

				}

				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + '\n';

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + '\n';

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + '\n';
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}

					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					return rgbe_error( rgbe_format_error, 'missing format specifier' );

				}

				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					return rgbe_error( rgbe_format_error, 'missing image size specifier' );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

				const scanline_width = w;

				if (
					// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
					// this file is not run length encoded
					( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					return rgbe_error( rgbe_format_error, 'wrong scanline width' );

				}

				const data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba.length ) {

					return rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );

				}

				let offset = 0, pos = 0;

				const ptr_end = 4 * scanline_width;
				const rgbeStart = new Uint8Array( 4 );
				const scanline_buffer = new Uint8Array( ptr_end );
				let num_scanlines = h;

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						return rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						return rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					let ptr = 0, count;

					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						const isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							return rgbe_error( rgbe_format_error, 'bad scanline data' );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							const byteValue = buffer[ pos ++ ];
							for ( let i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					const l = scanline_width; //scanline_buffer.byteLength;
					for ( let i = 0; i < l; i ++ ) {

						let off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			};

		const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
			destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
			destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;
			destArray[ destOffset + 3 ] = 1;

		};

		const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			// clamping to 65504, the maximum representable value in float16
			destArray[ destOffset + 0 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );
			destArray[ destOffset + 1 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );
			destArray[ destOffset + 2 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );
			destArray[ destOffset + 3 ] = three.DataUtils.toHalfFloat( 1 );

		};

		const byteArray = new Uint8Array( buffer );
		byteArray.pos = 0;
		const rgbe_header_info = RGBE_ReadHeader( byteArray );

		if ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {

			const w = rgbe_header_info.width,
				h = rgbe_header_info.height,
				image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );

			if ( RGBE_RETURN_FAILURE !== image_rgba_data ) {

				let data, format, type;
				let numElements;

				switch ( this.type ) {

					case three.FloatType:

						numElements = image_rgba_data.length / 4;
						const floatArray = new Float32Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );

						}

						data = floatArray;
						type = three.FloatType;
						break;

					case three.HalfFloatType:

						numElements = image_rgba_data.length / 4;
						const halfArray = new Uint16Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );

						}

						data = halfArray;
						type = three.HalfFloatType;
						break;

					default:

						console.error( 'THREE.RGBELoader: unsupported type: ', this.type );
						break;

				}

				return {
					width: w, height: h,
					data: data,
					header: rgbe_header_info.string,
					gamma: rgbe_header_info.gamma,
					exposure: rgbe_header_info.exposure,
					format: format,
					type: type
				};

			}

		}

		return null;

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			switch ( texture.type ) {

				case three.FloatType:

					texture.encoding = three.LinearEncoding;
					texture.minFilter = three.LinearFilter;
					texture.magFilter = three.LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;
					break;

				case three.HalfFloatType:

					texture.encoding = three.LinearEncoding;
					texture.minFilter = three.LinearFilter;
					texture.magFilter = three.LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;
					break;

			}

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}class KeyboardService {
  static keydown$() {
    if (!this.keydown$_) {
      this.keydown$_ = rxjs.fromEvent(window, 'keydown').pipe(operators.shareReplay(1));
    }

    return this.keydown$_;
  }

  static keyup$() {
    if (!this.keyup$_) {
      this.keyup$_ = rxjs.fromEvent(window, 'keyup').pipe(operators.shareReplay(1));
    }

    return this.keyup$_;
  }

  static keys$() {
    if (!this.keys$_) {
      this.keys$_ = rxjs.merge(this.keydown$(), this.keyup$()).pipe(operators.map(event => {
        const keys = this.keys;

        if (event.type === 'keydown') {
          keys[event.key] = true;
        } else {
          delete keys[event.key];
        }

        return this.keys;
      }), operators.startWith(this.keys), operators.shareReplay(1));
    }

    return this.keys$_;
  }

  static key$() {
    if (!this.key$_) {
      const regexp = /\w/;
      this.key$_ = this.keydown$().pipe(operators.filter(event => event.key && event.key.match(regexp)), operators.map(event => event.key), operators.shareReplay(1));
    }

    return this.key$_;
  }

  static typing$() {
    if (!this.typing$_) {
      let typing = '',
          to;
      this.typing$_ = this.key$().pipe(operators.map(key => {
        if (to) {
          clearTimeout(to);
        }

        typing += key;
        to = setTimeout(() => {
          typing = '';
        }, 1500);
        return typing;
      }), operators.shareReplay(1));
    }

    return this.typing$_;
  }

}
KeyboardService.keys = {};let LOADER_UID = 0;
class LoaderService {
  // merge(this.statusSubject, this.validatorsSubject)
  static switchLoaders() {
    const items = Object.keys(this.items).map(key => this.items[key]);
    const items$ = items.length ? rxjs.combineLatest(items) : rxjs.of(items);
    this.progress$.next(items$);
  }

  static getRef() {
    const ref = ++LOADER_UID;
    this.items[ref] = new rxjs.BehaviorSubject({
      loaded: 0,
      total: 1
    });
    this.switchLoaders();
    return ref;
  }

  static setProgress(ref, loaded, total) {
    if (total === void 0) {
      total = 1;
    }

    // console.log('LoaderService.setProgress');
    const item = this.items[ref];

    if (item) {
      item.next({
        loaded,
        total
      });
    }

    if (loaded >= total) {
      setTimeout(() => {
        delete this.items[ref];
        this.switchLoaders();
      }, 300);
    }

    this.switchLoaders();
  }

}
LoaderService.progress = {
  value: 0,
  loaded: 0,
  total: 0,
  count: 0,
  title: ''
};
LoaderService.items = {};
LoaderService.progress$ = new rxjs.ReplaySubject(1).pipe(operators.switchAll(), operators.map(() => {
  const items = Object.keys(LoaderService.items).map(key => LoaderService.items[key]);
  const progress = items.reduce((progress, subject, i, items) => {
    const item = subject.getValue();
    const loaded = item.loaded || 0;
    const total = item.total || 1;
    const value = loaded / total;
    progress.value += value;
    progress.loaded += loaded;
    progress.total += total;
    return progress;
  }, {
    value: 0,
    loaded: 0,
    total: 0
  });
  progress.count = items.length;

  if (items.length) {
    progress.value /= progress.count;
  }

  progress.title = `${Math.round(progress.value * 100)}%`;
  LoaderService.progress = progress;
  return progress;
}));let UID$1 = 0;
const PrefetchServiceEvent = {
  Progress: 'progress',
  Complete: 'complete'
};
class PrefetchService {
  static worker() {
    if (!this.worker_) {
      this.worker_ = new Worker(environment.workers.prefetch);
    }

    return this.worker_;
  }

  static events$(assets) {
    if (!('Worker' in window)) {
      return rxjs.of({
        type: PrefetchServiceEvent.Complete,
        data: assets
      });
    }

    const worker = this.worker();
    worker.postMessage({
      id: UID$1
    });
    const id = ++UID$1;
    worker.postMessage({
      id,
      assets
    });
    return rxjs.fromEvent(worker, 'message').pipe(operators.map(event => event.data), operators.filter(event => event.assets === assets), operators.tap(event => {
    }), operators.takeWhile(event => event.type !== PrefetchServiceEvent.Complete, true), operators.finalize(() => {
      // console.log('PrefetchService.finalize', lastEvent);
      worker.postMessage({
        id
      });
    }));
  }

  static load$(assets) {
    return this.events$(assets).pipe(operators.filter(event => event.type === PrefetchServiceEvent.Complete), operators.map(event => event.data));
  }

  static prefetch(assets) {
    this.load$(assets).subscribe(event => {// console.log('PrefetchService.prefetch', event);
    });
  }

  static cancel() {
    if (!('Worker' in window)) {
      return null;
    }

    const worker = this.worker();
    worker.postMessage({
      id: UID$1
    });
    return worker;
  }

}class Rect {
  constructor(rect) {
    this.x = 0;
    this.y = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
    this.left = 0;
    this.width = 0;
    this.height = 0;
    this.set(rect);
  }

  static contains(rect, left, top) {
    return rect.top <= top && top <= rect.bottom && rect.left <= left && left <= rect.right;
  }

  static intersectRect(r1, r2) {
    return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);
  }

  static fromNode(node) {
    if (!node) {
      return;
    }

    const rect = node.rect_ || (node.rect_ = new Rect());
    const rects = node.getClientRects();

    if (!rects.length) {
      // console.log(rects, node);
      return rect;
    }

    const boundingRect = node.getBoundingClientRect(); // rect.top: boundingRect.top + defaultView.pageYOffset,
    // rect.left: boundingRect.left + defaultView.pageXOffset,

    rect.x = boundingRect.left;
    rect.y = boundingRect.top;
    rect.top = boundingRect.top;
    rect.left = boundingRect.left;
    rect.width = boundingRect.width;
    rect.height = boundingRect.height;
    rect.right = rect.left + rect.width;
    rect.bottom = rect.top + rect.height;
    rect.setCenter();
    return rect;
  }

  set(rect) {
    if (rect) {
      Object.assign(this, rect);
      this.right = this.left + this.width;
      this.bottom = this.top + this.height;
    }

    this.setCenter();
  }

  setSize(w, h) {
    this.width = w;
    this.height = h;
    this.right = this.left + this.width;
    this.bottom = this.top + this.height;
    this.setCenter(); // console.log(w, h);
  }

  setCenter() {
    const center = this.center || (this.center = {});
    center.top = this.top + this.height / 2;
    center.left = this.left + this.width / 2;
    center.x = center.left;
    center.y = center.top;
  }

  contains(left, top) {
    return Rect.contains(this, left, top);
  }

  intersect(rect) {
    return Rect.intersectRect(this, rect);
  }

  intersection(rect) {
    const intersection = this.intersection_ || (this.intersection_ = {
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      pow: {
        x: -1,
        y: -1
      },
      offset: function (offset) {
        offset = offset || 0;
        const pow = (this.top - this.rect.height / 2 + offset) / -this.height;
        return pow;
      },
      scroll: function (offset) {
        offset = offset || 0;
        const pow = (this.top - this.rect.height / 2 + offset) / -this.height;
        return pow;
      }
    });
    intersection.left = this.left;
    intersection.top = this.top;
    intersection.width = this.width;
    intersection.height = this.height;
    intersection.x = this.left + this.width / 2;
    intersection.y = this.top + this.height / 2;
    intersection.rect = rect;
    const pow = intersection.offset(0);
    intersection.pow.y = pow;
    return intersection;
  }

}// import { auditTime, tap } from 'rxjs/operators';
const W$1 = 320;
const H$1 = 240;
const COLORS$1 = [0xffcc00, 0x00ffcc, 0x00ccff, 0xccff00, 0xcc00ff, 0xffffff];
class AvatarElement {
  static get headGeometry() {
    if (!this.headGeometry_) {
      this.headGeometry_ = new THREE.SphereBufferGeometry(0.2, 36, 24);
    }

    return this.headGeometry_;
  }

  constructor(message) {
    const clientId = this.clientId = message.clientId;
    const container = this.container = message.container;
    const renderer = this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: false,
      premultipliedAlpha: true // physicallyCorrectLights: true,

    });
    renderer.setClearColor(0x000000, 1);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(W$1, H$1);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.8;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);
    const camera = this.camera = new THREE.PerspectiveCamera(70, W$1 / H$1, 0.01, 1000);
    camera.position.set(0, 0, -0.5);
    camera.target = new THREE.Vector3();
    camera.lookAt(camera.target);
    const scene = this.scene = new THREE.Scene();
    /*
    const ambient = this.ambient = new THREE.AmbientLight(0x202020);
    scene.add(ambient);
    */

    const light = this.light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(0, 2, -2);
    scene.add(light);
    const head = this.head = this.addHead();
    scene.add(head);
    this.remote = StreamService.getRemoteById(clientId);
    /*
    if (remote) {
    	this.subscription = AudioStreamService.volume$(remote.stream).pipe(
    		auditTime(Math.floor(1000 / 15)),
    		tap(meter => {
    			this.chalk(meter.volume);
    		})
    	);
    }
    */
  }

  addHead() {
    const geometry = AvatarElement.headGeometry;
    const canvas = this.canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 512;
    this.ctx = this.canvas.getContext('2d');
    const map = this.map = new THREE.CanvasTexture(canvas);
    map.offset.x = -0.25;
    const color = COLORS$1[this.clientId % COLORS$1.length];
    const material = new THREE.MeshStandardMaterial({
      map: map,
      color: color
    });
    this.chalk(0);
    return new THREE.Mesh(geometry, material);
  }

  render() {
    this.tick_ ? ++this.tick_ : this.tick_ = 1; // if (tick % 2 === 1) {

    if (this.remote) {
      const audioLevel = this.remote.getAudioLevel() * 12;
      this.chalk(audioLevel);
    }

    const renderer = this.renderer,
          scene = this.scene,
          camera = this.camera;
    renderer.render(scene, camera); // }
  }

  update(message) {
    const camera = message.camera;
    const head = this.head;
    head.quaternion.set(camera[3], camera[4], camera[5], camera[6]);
    /*
    head.position.set(camera[0], camera[1], camera[2]);
    */
  }

  dispose() {
    // !!! dispose threejs
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }

  chalk(i) {
    i = (i + Math.PI * 0.5) % (Math.PI * 2);
    const vol = Math.sin(i) * 30;
    const smile = Math.cos(i) * 10;
    const x = 512;
    const y = 256;
    const ctx = this.ctx;
    ctx.fillStyle = '#888888';
    ctx.fillRect(0, 0, 1024, 512);
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - 40, y - 50, 7, 0, 2 * Math.PI);
    ctx.arc(x + 40, y - 50, 7, 0, 2 * Math.PI);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath(); // ctx.quadraticCurveTo(x - 30, y + 30, x - 30, y + 30);
    // ctx.quadraticCurveTo(x - 30, y + 60, x, y + 60);
    // ctx.quadraticCurveTo(x + 30, y + 60, x + 30, y + 30);
    // ctx.quadraticCurveTo(x + 30, y, x, y);

    ctx.moveTo(x - 40 - smile, y + 30);
    ctx.bezierCurveTo(x - 40 - smile, y + 60, x + 40 + smile, y + 60, x + 40 + smile, y + 30);
    ctx.bezierCurveTo(x + 40 + smile, y + vol, x - 40 - smile, y + vol, x - 40 - smile, y + 30); // ctx.arc(x, 256 + 50, 50, 0, 2 * Math.PI);

    ctx.closePath();
    ctx.fill();
    this.map.needsUpdate = true;
  }

}// import * as THREE from 'three';
class Texture {
  static get defaultTexture() {
    return Texture.defaultTexture_ || (Texture.defaultTexture_ = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDYuMC1jMDA2IDc5LjE2NDc1MywgMjAyMS8wMi8xNS0xMTo1MjoxMyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjMgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjcyODFGQkE0QUMxODExRUJBQkRBQTEyMzUzMjUxRjg2IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjcyODFGQkE1QUMxODExRUJBQkRBQTEyMzUzMjUxRjg2Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NzI4MUZCQTJBQzE4MTFFQkFCREFBMTIzNTMyNTFGODYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NzI4MUZCQTNBQzE4MTFFQkFCREFBMTIzNTMyNTFGODYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz55AlN+AAAAZUlEQVR42uzQAQEAAAQDMPTvfD3YIqyT1GdTzwkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAgAtWgAEAVbYDfaostxgAAAAASUVORK5CYII='));
  }

  static get gridTexture() {
    return Texture.gridTexture_ || (Texture.gridTexture_ = new THREE.TextureLoader().load(environment.getPath(environment.textures.grid)));
  }

}class MediaPlayMesh extends InteractiveMesh {
  static getLoader() {
    return MediaPlayMesh.loader || (MediaPlayMesh.loader = new THREE.TextureLoader());
  }

  static getTextureOff() {
    return MediaPlayMesh.textureOff || (MediaPlayMesh.textureOff = MediaPlayMesh.getLoader().load(environment.getPath('textures/ui/play-off.png')));
  }

  static getTextureOn() {
    return MediaPlayMesh.textureOn || (MediaPlayMesh.textureOn = MediaPlayMesh.getLoader().load(environment.getPath('textures/ui/play-on.png')));
  }

  static getMaterial() {
    const material = new THREE.MeshBasicMaterial({
      map: MediaPlayMesh.getTextureOff(),
      color: 0xffffff,
      opacity: 1,
      transparent: true
    });
    return material;
  }

  get playing() {
    return this.playing_;
  }

  set playing(playing) {
    if (this.playing_ !== playing) {
      this.playing_ = playing;
      const material = this.material;
      material.map = playing ? MediaPlayMesh.getTextureOn() : MediaPlayMesh.getTextureOff();
      this.onOut(); // material.needsUpdate = true;
      // this.emit('playing', playing);
      // console.log('MediaPlayMesh.playing', playing);
    }
  }

  constructor(host) {
    const geometry = Geometry.planeGeometry;
    const material = MediaPlayMesh.getMaterial();
    super(geometry, material);
    this.playing_ = false;
    this.material = material;
    this.host = host; // this.color = new THREE.Color(material.color.getHex());

    this.colorOff = new THREE.Color(material.color.getHex());
    this.colorOn = new THREE.Color('#888888'); // new THREE.Color('#0099ff');

    this.addEventListener();
  }

  update(parent) {
    const scale = this.scale;
    const parentRatio = parent.scale.x / parent.scale.y;
    const size = 0.3;
    scale.set(size / parentRatio, size, 1); // console.log('MediaPlayMesh.setParentScale', parent.scale, scale, position);
  }

  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }

      this.material.dispose(); // this.material = null;
    }
  }

  dispose() {
    this.removeEventListener();
    this.disposeMaterial();
  }

  onOver() {
    const color = this.material.color;
    const target = this.colorOn;
    const material = this.material; // console.log('MediaPlayMesh.onOver');

    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
    });
    gsap.to(material, {
      opacity: 1,
      duration: 0.2,
      ease: Power2.easeInOut
    });
  }

  onOut() {
    const color = this.material.color;
    const target = this.colorOff;
    const material = this.material; // console.log('MediaPlayMesh.onOut');

    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
    });
    gsap.to(material, {
      opacity: this.playing ? 0 : 1,
      duration: 0.2,
      ease: Power2.easeInOut
    });
  }

  addEventListener() {
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.on('over', this.onOver);
    this.on('out', this.onOut);
  }

  removeEventListener() {
    this.off('over', this.onOver);
    this.off('out', this.onOut);
  }

}class MediaZoomMesh extends InteractiveMesh {
  static getLoader() {
    return MediaZoomMesh.loader || (MediaZoomMesh.loader = new THREE.TextureLoader());
  }

  static getTextureOff() {
    return MediaZoomMesh.textureOff || (MediaZoomMesh.textureOff = MediaZoomMesh.getLoader().load(environment.getPath('textures/ui/zoom-off.png')));
  }

  static getTextureOn() {
    return MediaZoomMesh.textureOn || (MediaZoomMesh.textureOn = MediaZoomMesh.getLoader().load(environment.getPath('textures/ui/zoom-on.png')));
  }

  static getMaterial() {
    const material = new THREE.MeshBasicMaterial({
      map: MediaZoomMesh.getTextureOff(),
      color: 0xffffff,
      opacity: 1,
      transparent: true
    });
    return material;
  }

  get zoomed() {
    return this.zoomed_;
  }

  set zoomed(zoomed) {
    if (this.zoomed_ !== zoomed) {
      this.zoomed_ = zoomed;
      const material = this.material;
      material.map = zoomed ? MediaZoomMesh.getTextureOn() : MediaZoomMesh.getTextureOff(); // material.needsUpdate = true;

      /*
      if (zoomed) {
      	// this.originalPosition = this.parent.position.clone();
      	// this.originalQuaternion = this.parent.rotation.clone();
      	// this.originalScale = this.parent.scale.clone();
      } else {
      	this.object.position.copy(this.originalPosition);
      	this.object.scale.copy(this.originalScale);
      	this.object.quaternion.copy(this.originalQuaternion);
      }
      this.updateObjectMatrix();
      */
      // console.log('MediaZoomMesh.zoomed', zoomed);
    }
  }

  constructor(host) {
    const geometry = Geometry.planeGeometry;
    const material = MediaZoomMesh.getMaterial();
    super(geometry, material);
    this.zoomed_ = false;
    this.material = material;
    this.host = host; // this.color = new THREE.Color(material.color.getHex());

    this.colorOff = new THREE.Color(material.color.getHex());
    this.colorOn = new THREE.Color('#888888'); // new THREE.Color('#0099ff');

    this.object = new THREE.Object3D();
    this.addEventListener();
  }

  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }

      this.material.dispose(); // this.material = null;
    }
  }

  dispose() {
    this.removeEventListener();
    this.disposeMaterial();
  }

  onOver() {
    const color = this.material.color;
    const target = this.colorOn;
    this.material; // console.log('MediaZoomMesh.onOver');

    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
      /*
      onUpdate: () => {
      	material.needsUpdate = true;
      },
      */

    }); // this.innerVisible = true;
  }

  onOut() {
    const color = this.material.color;
    const target = this.colorOff;
    this.material; // console.log('MediaZoomMesh.onOut');

    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
      /*
      onUpdate: () => {
      	material.needsUpdate = true;
      },
      */

    }); // this.innerVisible = false;
  }

  onToggle() {
    // console.log('MediaZoomMesh.onToggle', !this.zoomed);
    // this.zoomed = !this.zoomed;
    this.emit('zoomed', !this.zoomed);
  }

  addEventListener() {
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.onToggle = this.onToggle.bind(this);
    this.on('over', this.onOver);
    this.on('out', this.onOut);
    this.on('down', this.onToggle);
  }

  removeEventListener() {
    this.off('over', this.onOver);
    this.off('out', this.onOut);
    this.off('down', this.onToggle);
  }

}const VERTEX_SHADER$1 = `
varying vec2 vUvShader;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {
	vUvShader = uv;

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`;
const FRAGMENT_SHADER$1 = `
#define USE_MAP

varying vec2 vUvShader;

uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// uniform sampler2D map;
uniform sampler2D playMap;
uniform vec2 mapResolution;
uniform vec2 playMapResolution;
uniform float mapTween;
uniform float playMapTween;
uniform vec3 playMapColor;
uniform bool isVideo;

void main() {
	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4(vec3(1.0), opacity);

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	// main
	vec4 mapRgba = texture2D(map, vUvShader);
	if (isVideo) {
		vec4 playMapRgba = texture2D(playMap, vUvShader);
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2) + (playMapRgba.rgb * mapTween * playMapRgba.a), opacity);
	} else {
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity);
	}

	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;
const FRAGMENT_CHROMA_KEY_SHADER = `
#define USE_MAP
#define threshold 0.55
#define padding 0.05
varying vec2 vUvShader;

uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// uniform sampler2D map;
uniform sampler2D playMap;
uniform vec2 mapResolution;
uniform vec2 playMapResolution;
uniform float mapTween;
uniform float playMapTween;
uniform vec3 playMapColor;
uniform vec3 chromaKeyColor;
uniform bool isVideo;

void main() {
	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	// main
	vec4 mapRgba = texture2D(map, vUvShader);
	vec4 chromaKey = vec4(chromaKeyColor, 1.0);
    vec3 chromaKeyDiff = mapRgba.rgb - chromaKey.rgb;
    float chromaKeyValue = smoothstep(threshold - padding, threshold + padding, dot(chromaKeyDiff, chromaKeyDiff));
	/*
	if (isVideo) {
		vec4 playMapRgba = texture2D(playMap, vUvShader);
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2) + (playMapRgba.rgb * mapTween * playMapRgba.a), opacity * chromaKeyValue);
	} else {
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity * chromaKeyValue);
	}
	*/
	// diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity * chromaKeyValue);
	diffuseColor = vec4(mapRgba.rgb, opacity * chromaKeyValue);

	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4(outgoingLight, diffuseColor.a);

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;
class MediaMesh extends InteractiveMesh {
  static getMaterial(useChromaKey) {
    const material = new THREE.ShaderMaterial({
      depthTest: true,
      // !!!
      depthWrite: true,
      transparent: true,
      toneMapped: false,
      // side: THREE.DoubleSide,
      // blending: THREE.AdditiveBlending,
      vertexShader: VERTEX_SHADER$1,
      fragmentShader: useChromaKey ? FRAGMENT_CHROMA_KEY_SHADER : FRAGMENT_SHADER$1,
      uniforms: {
        map: {
          type: 't',
          value: Texture.defaultTexture
        },
        mapResolution: {
          value: new THREE.Vector2()
        },
        mapTween: {
          value: 1
        },
        color: {
          value: new THREE.Color('#FFFFFF')
        },
        playMap: {
          type: 't',
          value: Texture.defaultTexture
        },
        playMapResolution: {
          value: new THREE.Vector2()
        },
        playMapTween: {
          value: 0
        },
        playMapColor: {
          value: new THREE.Color('#000000')
        },
        opacity: {
          value: 0
        },
        isVideo: {
          value: false
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    return material;
  }

  static getChromaKeyMaterial(chromaKeyColor) {
    if (chromaKeyColor === void 0) {
      chromaKeyColor = [0.0, 1.0, 0.0];
    }

    const material = new THREE.ShaderMaterial({
      depthTest: true,
      // !!!
      depthWrite: true,
      transparent: true,
      toneMapped: false,
      // side: THREE.DoubleSide,
      // blending: THREE.AdditiveBlending,
      vertexShader: VERTEX_SHADER$1,
      fragmentShader: FRAGMENT_CHROMA_KEY_SHADER,
      uniforms: {
        map: {
          type: 't',
          value: null
        },
        // Texture.defaultTexture
        mapResolution: {
          value: new THREE.Vector2()
        },
        mapTween: {
          value: 1
        },
        color: {
          value: new THREE.Color('#FFFFFF')
        },
        chromaKeyColor: {
          value: new THREE.Color(chromaKeyColor[0], chromaKeyColor[1], chromaKeyColor[2])
        },
        playMap: {
          type: 't',
          value: Texture.defaultTexture
        },
        playMapResolution: {
          value: new THREE.Vector2()
        },
        playMapTween: {
          value: 0
        },
        playMapColor: {
          value: new THREE.Color('#000000')
        },
        opacity: {
          value: 0
        },
        isVideo: {
          value: false
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    material.map = true;
    return material;
  }

  static isPublisherStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Publisher && stream.clientInfo.uid === stream.getId();
  }

  static isAttendeeStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Attendee && stream.clientInfo.uid === stream.getId();
  }

  static isSmartDeviceStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.SmartDevice && stream.clientInfo.uid === stream.getId();
  }

  static isPublisherScreen(stream) {
    // console.log(stream.clientInfo, stream.clientInfo ? [stream.clientInfo.role, stream.clientInfo.screenUid, stream.getId()] : null);
    return stream.clientInfo && stream.clientInfo.role === RoleType.Publisher && stream.clientInfo.screenUid === stream.getId();
  }

  static isAttendeeScreen(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Attendee && stream.clientInfo.screenUid === stream.getId();
  }

  static getTypeMatcher(assetType) {
    let matcher;

    switch (assetType.name) {
      case AssetType.PublisherStream.name:
        matcher = this.isPublisherStream;
        break;

      case AssetType.AttendeeStream.name:
        matcher = this.isAttendeeStream;
        break;

      case AssetType.SmartDeviceStream.name:
        matcher = this.isSmartDeviceStream;
        break;

      case AssetType.PublisherScreen.name:
        matcher = this.isPublisherScreen;
        break;

      case AssetType.AttendeeScreen.name:
        matcher = this.isAttendeeScreen;
        break;

      default:
        matcher = stream => {
          return false;
        };

    }

    return matcher;
  }

  static getStreamId$(item) {
    if (!item.asset) {
      return rxjs.of(null);
    }

    const assetType = item.asset.type;
    const file = item.asset.file; // console.log(item.asset, assetIsStream(item.asset));

    if (assetIsStream(item.asset)) {
      // console.log('MediaMesh.getStreamId$', item.asset.type.name);
      return StreamService.streams$.pipe(operators.map(streams => {
        let stream;
        let i = 0;
        const matchType = this.getTypeMatcher(assetType);
        streams.forEach(x => {
          // console.log('MediaMesh.getStreamId$', x.clientInfo, x.clientInfo ? [x.clientInfo.screenUid, x.getId()] : null);
          if (matchType(x)) {
            if (i === item.asset.index) {
              stream = x;
            }

            i++;
          }
        });

        if (stream) {
          // console.log('MediaMesh.getStreamId$', assetType.name, stream.clientInfo.role, stream.getId());
          return stream.getId();
        } else {
          // console.log('MediaMesh.getStreamId$.notfound', assetType.name);
          return null;
        }
      }));
    } else {
      return rxjs.of(file);
    }
  }

  static getMaterialByItem(item) {
    let material;

    if (item.asset && item.asset.chromaKeyColor) {
      material = MediaMesh.getChromaKeyMaterial(item.asset.chromaKeyColor);
    } else if (item.asset) {
      // material = new THREE.MeshBasicMaterial({ color: 0x888888 });
      // material = new THREE.MeshBasicMaterial({ color: 0xffffff, toneMapped: false });
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        toneMapped: false
      }); // material = new THREE.MeshPhysicalMaterial({ clearcoat: 1, clearcoatRoughness: 0, toneMapped: false, encoding: THREE.sRGBEncoding });
    } else {
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        toneMapped: false
      });
    }

    return material;
  }

  static getUniformsByItem(item) {
    let uniforms = null;

    if (item.asset) {
      uniforms = {
        mapTween: 1,
        playMapTween: 0,
        opacity: 0
      };
    }

    return uniforms;
  }

  get editing() {
    return this.editing_;
  }

  set editing(editing) {
    if (this.editing_ !== editing) {
      this.editing_ = editing; // this.zoomed = editing ? false : (this.view.type.name === 'media' ? true : this.zoomed);

      this.zoomed = this.view.type.name === 'media' ? true : editing ? false : this.zoomed;
    }
  }

  constructor(item, view, geometry, host) {
    const material = MediaMesh.getMaterialByItem(item);
    super(geometry, material); // this.renderOrder = environment.renderOrder.plane;

    this.zoomed_ = false;
    this.item = item;
    this.view = view;
    this.items = view.items;
    this.host = host;
    this.uniforms = MediaMesh.getUniformsByItem(item);
    this.object = new THREE.Object3D();
    this.tempPosition = new THREE.Vector3();
    this.tempRotation = new THREE.Vector3();
    item.silent = this.isAutoplayLoop; // !!!

    this.mediaLoader = new MediaLoader(item);
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.onToggle = this.onToggle.bind(this);
    this.onZoomed = this.onZoomed.bind(this);
    this.addPlayBtn();
    this.addZoomBtn();

    this.userData.render = (time, tick) => {
      this.render(this, time, tick);
    };
  }

  load(callback) {
    if (this.playBtn) {
      this.remove(this.playBtn);
    }

    if (this.zoomBtn) {
      this.remove(this.zoomBtn);
    }

    if (!this.item.asset) {
      this.onAppear();

      if (typeof callback === 'function') {
        callback(this);
      }

      return;
    }

    const material = this.material;
    const mediaLoader = this.mediaLoader;

    const onMediaLoaderLoaded = texture => {
      // console.log('MediaMesh.texture', texture);
      const loader = this.mediaLoader;

      if (!loader) {
        return;
      }

      if (texture) {
        // texture.encoding = THREE.sRGBEncoding;
        material.map = texture; // !!! Enables USE_MAP

        if (material.uniforms) {
          material.uniforms.map.value = texture; // material.uniforms.mapResolution.value.x = texture.image.width;
          // material.uniforms.mapResolution.value.y = texture.image.height;

          material.uniforms.mapResolution.value = new THREE.Vector2(texture.image.width || texture.image.videoWidth, texture.image.height || texture.image.videoHeight);

          if (loader.isPlayableVideo) {
            this.makePlayMap(texture, playMap => {
              // console.log('MediaMesh.playMap', playMap);
              playMap.minFilter = THREE.LinearFilter;
              playMap.magFilter = THREE.LinearFilter;
              playMap.mapping = THREE.UVMapping; // playMap.format = THREE.RGBAFormat;

              playMap.wrapS = THREE.RepeatWrapping;
              playMap.wrapT = THREE.RepeatWrapping;
              material.uniforms.playMap.value = playMap; // material.uniforms.playMapResolution.value.x = playMap.image.width;
              // material.uniforms.playMapResolution.value.y = playMap.image.height;

              material.uniforms.playMapResolution.value = new THREE.Vector2(playMap.image.width, playMap.image.height); // console.log(material.uniforms.playMapResolution.value, playMap);

              material.needsUpdate = true;
            });
          }
        }
      }

      material.needsUpdate = true;
      this.onAppear();

      if (loader.isPlayableVideo && this.playBtn) {
        if (material.uniforms) {
          material.uniforms.isVideo.value = true;
        }

        this.on('over', this.onOver);
        this.on('out', this.onOut);
        this.on('down', this.onToggle);
        this.add(this.playBtn);
      }

      if (this.zoomBtn) {
        this.add(this.zoomBtn);
      }

      if (typeof callback === 'function') {
        callback(this);
      }
    };
    /*
    setTimeout(() => {
    	mediaLoader.load(onMediaLoaderLoaded);
    }, 5000);
    */


    mediaLoader.load(onMediaLoaderLoaded);
  }

  makePlayMap(texture, callback) {
    const aw = texture.image.width || texture.image.videoWidth;
    const ah = texture.image.height || texture.image.videoHeight;
    const ar = aw / ah;
    const scale = 0.32;
    const canvas = document.createElement('canvas'); // document.querySelector('body').appendChild(canvas);

    canvas.width = aw;
    canvas.height = ah;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    const image = new Image();

    image.onload = function () {
      const bw = image.width;
      const bh = image.height;
      const br = bw / bh;
      let w;
      let h;

      if (ar > br) {
        w = ah * scale;
        h = w / br;
      } else {
        h = aw * scale;
        w = h * br;
      }

      ctx.drawImage(image, aw / 2 - w / 2, ah / 2 - h / 2, w, h);
      const playMap = new THREE.CanvasTexture(canvas);

      if (typeof callback === 'function') {
        callback(playMap);
      }
    };

    image.crossOrigin = 'anonymous';
    image.src = environment.getPath('textures/ui/play.png');
  }

  events$() {
    const item = this.item;
    const items = this.items;

    if (item.asset && item.asset.linkedPlayId) {
      this.freeze();
    }

    return MediaLoader.events$.pipe(operators.filter(event => event.loader.item && event.loader.item.id === item.id), operators.map(event => {
      if (event instanceof MediaLoaderPlayEvent) {
        this.playing = true;

        if (!this.isAutoplayLoop) {
          if (this.playBtn) {
            this.playBtn.playing = true;
          }

          this.emit('playing', true);
        }

        this.onOut();
      } else if (event instanceof MediaLoaderPauseEvent) {
        this.playing = false;

        if (this.playBtn) {
          this.playBtn.playing = false;
        }

        this.emit('playing', false);
        this.onOut();
      } else if (event instanceof MediaLoaderTimeSetEvent) {
        this.emit('currentTime', event.loader.video.currentTime);
      } // console.log('MediaMesh', this.playing);


      if (item.asset && item.asset.linkedPlayId) {
        const eventItem = items.find(x => x.asset && event.src.indexOf(x.asset.file) !== -1 && event.id === item.asset.linkedPlayId);

        if (eventItem) {
          // console.log('MediaLoader.events$.eventItem', event, eventItem);
          if (event instanceof MediaLoaderPlayEvent) {
            this.play();
          } else if (event instanceof MediaLoaderPauseEvent) {
            this.pause();
          }
        }
      }

      return event;
    }));
  }

  onAppear() {
    const uniforms = this.uniforms;
    const material = this.material;

    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        opacity: 1,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.uniforms.opacity.value = uniforms.opacity; // material.needsUpdate = true;
        }
      });
    }

    this.zoomed = this.view.type.name === 'media' ? true : this.editing ? false : this.zoomed;
  }

  onDisappear() {
    const uniforms = this.uniforms;
    const material = this.material;

    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        opacity: 0,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.uniforms.opacity.value = uniforms.opacity; // material.needsUpdate = true;
        }
      });
    }
  }

  onOver() {
    const uniforms = this.uniforms;
    const material = this.material;

    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        mapTween: this.playing ? 0 : 1,
        playMapTween: 1,
        opacity: 1,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          material.uniforms.mapTween.value = uniforms.mapTween;
          material.uniforms.playMapTween.value = uniforms.playMapTween;
          material.uniforms.opacity.value = uniforms.opacity; // material.needsUpdate = true;
        }
      });
    }

    if (this.playBtn) {
      this.playBtn.onOver();
    }
  }

  onOut() {
    const uniforms = this.uniforms;
    const material = this.material;

    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        mapTween: this.playing ? 0 : 1,
        playMapTween: 0,
        opacity: 1,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          material.uniforms.mapTween.value = uniforms.mapTween;
          material.uniforms.playMapTween.value = uniforms.playMapTween;
          material.uniforms.opacity.value = uniforms.opacity; // material.needsUpdate = true;
        }
      });
    }

    if (this.playBtn) {
      this.playBtn.onOut();
    }
  }

  onToggle() {
    this.playing = this.mediaLoader.toggle();

    if (this.playBtn) {
      this.playBtn.playing = this.playing;
    }

    this.emit('playing', this.playing);
    this.onOut();
  }

  play() {
    this.mediaLoader.play();
  }

  pause() {
    this.mediaLoader.pause();
  }

  setPlayingState(playing) {
    if (this.playing !== playing) {
      this.playing = playing;
      playing ? this.mediaLoader.play() : this.mediaLoader.pause();
      this.onOut();

      if (this.playBtn) {
        this.playBtn.playing = playing;
      }
    }
  }

  setZoomedState(zoomed) {
    this.zoomed = zoomed;
  }

  setCurrentTime(currentTime) {
    // !!!
    if (this.mediaLoader.video) {
      this.mediaLoader.video.currentTime = currentTime;
    }
  }

  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }

      this.material.dispose(); // this.material = null;
    }
  }

  disposeMediaLoader() {
    const mediaLoader = this.mediaLoader;

    if (mediaLoader) {
      if (mediaLoader.isPlayableVideo) {
        this.off('over', this.onOver);
        this.off('out', this.onOut);
        this.off('down', this.onToggle);
      }

      mediaLoader.dispose();
      this.mediaLoader = null;
    }
  }

  dispose() {
    // console.log('MediaMesh.dispose');
    this.removePlayBtn();
    this.removeZoomBtn();
    this.disposeMediaLoader();
  }

  get isAutoplayLoop() {
    const isAutoplayLoop = this.view.type.name !== 'media' && this.item.asset && this.item.asset.autoplay && this.item.asset.loop; // console.log('MediaMesh', isAutoplayLoop);

    return isAutoplayLoop;
  }

  addPlayBtn() {
    this.removePlayBtn();

    if (!this.isAutoplayLoop) {
      const playBtn = this.playBtn = new MediaPlayMesh(this.host);
      playBtn.on('over', this.onOver);
      playBtn.on('out', this.onOut);
      playBtn.on('down', this.onToggle);
      playBtn.position.z = 0.01;
    }
  }

  removePlayBtn() {
    if (this.playBtn) {
      this.remove(this.playBtn);
      this.playBtn.off('over', this.onOver);
      this.playBtn.off('out', this.onOut);
      this.playBtn.off('down', this.onToggle);
      this.playBtn.dispose();
      delete this.playBtn;
    }
  }

  onZoomed(zoomed) {
    this.zoomed = zoomed;
    this.emit('zoomed', zoomed);
  }

  addZoomBtn() {
    this.removeZoomBtn();

    if (this.view.type.name !== 'media' && (!this.item.asset || !this.item.asset.chromaKeyColor)) {
      const zoomBtn = this.zoomBtn = new MediaZoomMesh(this.host);
      zoomBtn.on('zoomed', this.onZoomed);
    }
  }

  removeZoomBtn() {
    if (this.zoomBtn) {
      this.remove(this.zoomBtn);
      this.zoomBtn.off('zoomed', this.onZoomed);
      this.zoomBtn.dispose();
      this.zoomBtn = null;
      delete this.zoomBtn;
    }
  }

  updateByItem(item) {
    this.disposeMaterial();
    this.disposeMediaLoader();
    this.material = MediaMesh.getMaterialByItem(item);
    this.uniforms = MediaMesh.getUniformsByItem(item);
    this.addPlayBtn();
    this.addZoomBtn();
    item.silent = this.isAutoplayLoop; // !!!

    this.mediaLoader = new MediaLoader(item);
  }

  updateFromItem(item) {
    // console.log('MediaMesh.updateFromItem', item);
    if (item.position) {
      this.position.fromArray(item.position);
    }

    if (item.rotation) {
      this.rotation.fromArray(item.rotation);
    }

    if (item.scale) {
      this.scale.fromArray(item.scale);
    }

    if (this.playBtn) {
      this.playBtn.update(this);
    }
    /*
    if (this.zoomBtn) {
    	this.zoomBtn.update(this);
    }
    */


    this.updateZoom();
  }

  updateZoom() {
    this.originalPosition = this.position.clone();
    this.originalScale = this.scale.clone();
    this.originalQuaternion = this.quaternion.clone();
    this.object.position.copy(this.originalPosition);
    this.object.scale.copy(this.originalScale);
    this.object.quaternion.copy(this.originalQuaternion);

    if (this.zoomBtn) {
      const scale = this.zoomBtn.scale;
      const position = this.zoomBtn.position;
      const ratio = this.scale.x / this.scale.y;
      const size = 0.1;
      scale.set(size / ratio, size, 1);
      position.x = 0.5 - size / ratio / 2;
      position.y = size / 2 - 0.5;
      position.z = 0.01;
    } // console.log('MediaMesh.updateZoom', this.scale);

  } // zoom


  render(time, tick) {
    /*
    if (this.zoomBtn && !this.editing) {
    	this.zoomBtn.render(time, tick);
    }
    */
    if (!this.editing) {
      const object = this.object;
      /*
      parent.position.lerp(object.position, 0.2);
      parent.scale.lerp(object.scale, 0.2);
      parent.quaternion.slerp(object.quaternion, 0.2);
      */

      if (this.zoomed && !this.host.renderer.xr.isPresenting) {
        this.updateObjectMatrix();
      }

      this.position.copy(object.position);
      this.scale.copy(object.scale);
      this.quaternion.copy(object.quaternion);
    }
  }

  updateObjectMatrix() {
    const object = this.object;
    const host = this.host;

    if (this.zoomed) {
      // const cameraGroup = host.cameraGroup;
      const originalScale = this.originalScale;
      let camera = host.camera,
          fov = camera.fov,
          aspect = camera.aspect,
          scale;
      const position = this.tempPosition;
      const rotation = this.tempRotation; // const aspect = originalScale.x / originalScale.y;

      scale = 0.01; // 0.01;

      const xr = host.renderer.xr;

      if (xr.isPresenting) {
        camera = xr.getCamera(camera);
        const mat = camera.projectionMatrix.elements;
        const a = mat[0];
        const b = mat[5]; // const c = mat[10];
        // const d = mat[14];

        aspect = b / a; // const k = (c - 1) / (c + 1);
        // const clip_min = (d * (1 - k)) / (2 * k);
        // const clip_max = k * clip_min;

        const RAD2DEG = 180 / 3.14159265358979323846;
        fov = RAD2DEG * (2 * Math.atan(1 / b));
        scale = 1;
      }

      object.scale.copy(originalScale).multiplyScalar(scale);
      const distance = Host.getDistanceToCamera(camera, fov, aspect, object.scale);
      camera.getWorldDirection(rotation);
      rotation.multiplyScalar(distance);
      position.set(0, 0, 0);
      camera.localToWorld(position);
      position.add(rotation);
      object.position.copy(position);
      object.lookAt(Host.origin);

      if (xr.isPresenting) {
        object.position.y -= object.scale.y / 2;
      }
    }
  }

  get zoomed() {
    return this.zoomed_;
  }

  set zoomed(zoomed) {
    if (this.zoomed_ !== zoomed) {
      this.zoomed_ = zoomed;

      if (zoomed) {
        this.renderOrder = environment.renderOrder.panel + 5;
        this.material.depthTest = true; // !!! false
        // this.originalPosition = this.position.clone();
        // this.originalQuaternion = this.rotation.clone();
        // this.originalScale = this.scale.clone();
      } else {
        this.renderOrder = 0;
        this.material.depthTest = true;
        this.object.position.copy(this.originalPosition);
        this.object.scale.copy(this.originalScale);
        this.object.quaternion.copy(this.originalQuaternion);
      }

      this.material.needsUpdate = true;
      this.updateObjectMatrix();

      if (this.zoomBtn) {
        this.zoomBtn.zoomed = zoomed;
      }
    }
  }

}class DragPoint {
  constructor() {
    this.x = 0;
    this.y = 0;
  }

}
class DragEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }

}
class DragDownEvent extends DragEvent {
  constructor(options) {
    super(options);
    this.distance = new DragPoint();
    this.strength = new DragPoint();
    this.speed = new DragPoint();
  }

}
class DragMoveEvent extends DragEvent {
  constructor(options) {
    super(options);
    this.distance = new DragPoint();
    this.strength = new DragPoint();
    this.speed = new DragPoint();
  }

}
class DragUpEvent extends DragEvent {
  constructor(options) {
    super(options);
  }

}
let upEvent;
class DragService {
  static getPosition(event, point) {
    if (event instanceof MouseEvent) {
      point ? (point.x = event.clientX, point.y = event.clientY) : point = {
        x: event.clientX,
        y: event.clientY
      };
    } else if (window.TouchEvent && event instanceof TouchEvent) {
      if (event.touches.length > 0) {
        point ? (point.x = event.touches[0].pageX, point.y = event.touches[0].pageY) : point = {
          x: event.touches[0].pageX,
          y: event.touches[0].pageY
        };
      }
    }

    return point;
  }

  static down$(target, events$) {
    let downEvent;
    return rxjs.merge(rxjs.fromEvent(target, 'mousedown').pipe(operators.filter(event => event.button === 0)), rxjs.fromEvent(target, 'touchstart')).pipe(operators.map(event => {
      downEvent = downEvent || new DragDownEvent();
      downEvent.node = target;
      downEvent.target = event.target;
      downEvent.originalEvent = event;
      downEvent.down = this.getPosition(event, downEvent.down);

      if (downEvent.down) {
        downEvent.distance = new DragPoint();
        downEvent.strength = new DragPoint();
        downEvent.speed = new DragPoint();
        events$.next(downEvent);
        return downEvent;
      }
    }), operators.filter(event => event !== undefined));
  }

  static move$(target, events$, dismiss$, downEvent) {
    let moveEvent;
    return rxjs.fromEvent(document, downEvent.originalEvent instanceof MouseEvent ? 'mousemove' : 'touchmove').pipe(operators.startWith(downEvent), operators.map(event => {
      moveEvent = moveEvent || new DragMoveEvent();
      moveEvent.node = target;
      moveEvent.target = event.target;
      moveEvent.originalEvent = event;
      moveEvent.position = this.getPosition(event, moveEvent.position);
      const dragging = downEvent.down !== undefined && moveEvent.position !== undefined;

      if (dragging) {
        moveEvent.distance.x = moveEvent.position.x - downEvent.down.x;
        moveEvent.distance.y = moveEvent.position.y - downEvent.down.y;
        moveEvent.strength.x = moveEvent.distance.x / window.innerWidth * 2;
        moveEvent.strength.y = moveEvent.distance.y / window.innerHeight * 2;
        moveEvent.speed.x = downEvent.speed.x + (moveEvent.strength.x - downEvent.strength.x) * 0.1;
        moveEvent.speed.y = downEvent.speed.y + (moveEvent.strength.y - downEvent.strength.y) * 0.1;
        downEvent.distance.x = moveEvent.distance.x;
        downEvent.distance.y = moveEvent.distance.y;
        downEvent.speed.x = moveEvent.speed.x;
        downEvent.speed.y = moveEvent.speed.y;
        downEvent.strength.x = moveEvent.strength.x;
        downEvent.strength.y = moveEvent.strength.y;
        events$.next(moveEvent);
        return moveEvent;
      }
    }));
  }

  static dismissEvent(event, events$, dismiss$, downEvent) {
    // console.log('DragService.dismissEvent', event);
    upEvent = upEvent || new DragUpEvent();
    events$.next(upEvent);
    dismiss$.next(); // console.log(downEvent.distance);

    if (downEvent && Math.abs(downEvent.distance.x) > 10) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    return upEvent;
  }

  static up$(target, events$, dismiss$, downEvent) {
    return rxjs.fromEvent(document, downEvent.originalEvent instanceof MouseEvent ? 'mouseup' : 'touchend').pipe(operators.map(event => this.dismissEvent(event, events$, dismiss$, downEvent)));
  }

  static observe$(target) {
    target = target || document;
    const events$ = DragService.events$;
    const dismiss$ = DragService.dismiss$;
    return this.down$(target, events$).pipe(operators.switchMap(downEvent => {
      DragService.downEvent = downEvent;
      return rxjs.merge(this.move$(target, events$, dismiss$, downEvent), this.up$(target, events$, dismiss$, downEvent)).pipe(operators.takeUntil(dismiss$));
    }), operators.switchMap(() => events$));
  }

}
DragService.events$ = new rxjs.ReplaySubject(1);
DragService.dismiss$ = new rxjs.Subject();const OrbitMode = {
  Panorama: 'panorama',
  PanoramaGrid: 'panorama-grid',
  Model: 'model'
};
class OrbitEvent {}
class OrbitDragEvent extends OrbitEvent {}
class OrbitResizeEvent extends OrbitEvent {}
class OrbitMoveEvent extends OrbitEvent {}
const orbitMoveEvent = new OrbitMoveEvent();
const orbitDragEvent = new OrbitDragEvent();
const orbitResizeEvent = new OrbitResizeEvent();
const DOLLY_MIN = 1; // 15;

const DOLLY_MAX = 75; // 115

const ZOOM_MIN = 1; // 15;

const ZOOM_MAX = 75;
class OrbitService {
  get dolly() {
    return this.dolly_;
  }

  set dolly(dolly) {
    const clampedDolly = THREE.Math.clamp(dolly, DOLLY_MIN, DOLLY_MAX);

    if (this.dolly_ !== clampedDolly) {
      this.dolly_ = clampedDolly;
      this.markAsDirty();
    }
  }

  getDollyValue() {
    return 1 - (this.dolly_ - DOLLY_MIN) / (DOLLY_MAX - DOLLY_MIN) - 0.5;
  }

  get zoom() {
    return this.zoom_;
  }

  set zoom(zoom) {
    const clampedDolly = THREE.Math.clamp(zoom, DOLLY_MIN, DOLLY_MAX);

    if (this.zoom_ !== clampedDolly) {
      this.zoom_ = clampedDolly;
      this.markAsDirty();
    }
  }

  getZoomValue() {
    return 1 + 1 - (this.zoom_ - ZOOM_MIN) / (ZOOM_MAX - ZOOM_MIN);
  }

  get mode() {
    return this.mode_;
  }

  set mode(mode) {
    if (this.mode_ !== mode) {
      this.mode_ = mode;
      OrbitService.mode = mode;
      this.markAsDirty();
    }
  }

  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }

  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }

  get silencing() {
    return StateService.state.silencing;
  }

  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }

  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }

  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }

  get isMediaView() {
    const currentView = ViewService.currentView;
    return currentView && currentView.type.name === ViewType.Media.name;
  }

  get locked() {
    return this.controlled || this.spying || this.isMediaView;
  }

  constructor(camera) {
    this.mode_ = OrbitService.mode = OrbitMode.Panorama;
    this.dolly_ = 70;
    this.zoom_ = 70;
    this.longitude = 0;
    this.latitude = 0;
    this.direction = 1;
    this.radius = 101;
    this.position = new THREE.Vector3(); // this.speed = 1;

    this.inertia = new THREE.Vector2();
    this.rotation = new THREE.Euler(0, 0, 0, 'XYZ');
    this.target = new THREE.Vector3();
    this.updatePosition = new THREE.Vector3();
    this.updateTarget = new THREE.Vector3();
    this.camera = camera;
    this.setLongitudeLatitude(0, 0);
    this.events$ = new rxjs.ReplaySubject(1);
  }

  setOrientation(orientation) {
    if (orientation) {
      this.setLongitudeLatitude(orientation.longitude, orientation.latitude);
      this.markAsDirty();
    }
  }

  getOrientation() {
    return {
      latitude: this.latitude,
      longitude: this.longitude
    };
  }

  setLongitudeLatitude(longitude, latitude) {
    latitude = Math.max(-80, Math.min(80, latitude));
    this.longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
    this.latitude = latitude; // console.log(this.longitude);

    const phi = THREE.Math.degToRad(90 - latitude);
    const theta = THREE.Math.degToRad(longitude);
    this.phi = phi;
    this.theta = theta;
  }

  observe$(node) {
    // const camera = this.camera;
    let latitude, longitude;
    return rxjs.combineLatest([KeyboardService.keys$(), DragService.observe$(node)]).pipe(operators.filter(event => !this.locked), operators.map(datas => {
      const keys = datas[0];
      const event = datas[1]; // const group = this.objects.children[this.index];

      if (event instanceof DragDownEvent) {
        latitude = this.latitude;
        longitude = this.longitude;
      } else if (event instanceof DragMoveEvent) {
        if (keys.Shift) {
          this.events$.next(orbitDragEvent);
        } else if (keys.Control) {
          this.events$.next(orbitResizeEvent);
        } else {
          const flip = this.mode_ === OrbitMode.Model ? -1 : 1;
          this.setLongitudeLatitude(longitude - event.distance.x * 0.1 * flip, latitude + event.distance.y * 0.1);
        }
      } else ;

      return event;
    }), operators.filter(event => event instanceof DragMoveEvent), operators.startWith({
      latitude: this.latitude,
      longitude: this.longitude
    }), operators.tap(event => this.markAsDirty()), operators.switchMap(event => this.events$));
  }

  walk(position, callback) {
    let radius;

    switch (this.mode_) {
      case OrbitMode.Model:
        radius = 3;
        break;

      default:
        radius = this.radius;
    }

    const heading = new THREE.Vector2(position.x, position.y).normalize().multiplyScalar(radius);
    const headingTheta = Math.atan2(heading.y, heading.x);
    let headingLongitude = THREE.MathUtils.radToDeg(headingTheta);
    headingLongitude = (headingLongitude < 0 ? 360 + headingLongitude : headingLongitude) % 360;
    const headingLatitude = 0;
    const latitude = this.latitude;
    const longitude = this.longitude;
    let differenceLongitude = headingLongitude - longitude;
    differenceLongitude = Math.abs(differenceLongitude) > 180 ? differenceLongitude - 360 * (differenceLongitude / Math.abs(differenceLongitude)) : differenceLongitude;
    let differenceLatitude = headingLatitude - latitude;
    differenceLatitude = Math.abs(differenceLatitude) > 90 ? differenceLatitude - 90 * (differenceLatitude / Math.abs(differenceLatitude)) : differenceLatitude; // console.log('headingTheta', headingTheta, 'headingLongitude', headingLongitude, 'differenceLongitude', differenceLongitude);

    const from = {
      tween: 0
    };
    gsap.to(from, {
      duration: 0.7,
      tween: 1,
      delay: 0,
      ease: Power2.easeInOut,
      onUpdate: () => {
        this.setLongitudeLatitude(longitude + differenceLongitude * from.tween, latitude + differenceLatitude * from.tween);
        this.position.set(position.x * from.tween, 0, position.y * from.tween);
        this.markAsDirty();
      },
      onComplete: () => {
        // this.walkComplete(headingLongitude, headingLatitude);
        if (typeof callback === 'function') {
          callback(headingLongitude, headingLatitude);
        }
      }
    });
  }

  walkComplete(headingLongitude, headingLatitude) {
    this.setLongitudeLatitude(headingLongitude, headingLatitude);
    this.position.set(0, 0, 0);
    this.markAsDirty();
  }

  lookAt(object) {
    // console.log('OrbitService.lookAt', object);
    if (object) {
      let position = object.position.clone();
      const camera = this.camera;
      const cameraGroup = camera.parent;
      position = cameraGroup.worldToLocal(position);
      let radius;

      switch (this.mode_) {
        case OrbitMode.Model:
          radius = 3;
          break;

        default:
          radius = this.radius;
      }

      const heading = new THREE.Vector3(position.x, position.z, position.y).normalize().multiplyScalar(radius);
      const theta = Math.atan2(heading.y, heading.x);
      const phi = Math.acos(heading.z / radius);
      let longitude = THREE.MathUtils.radToDeg(theta);
      longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
      let latitude = 90 - THREE.MathUtils.radToDeg(phi);
      latitude = Math.max(-80, Math.min(80, latitude));
      this.setLongitudeLatitude(longitude, latitude);
      this.markAsDirty();
    }
  }

  setVRCamera(camera) {
    if (camera) {
      const radius = this.radius;
      const position = new THREE.Vector3(0, 0, -radius);
      const quaternion = new THREE.Quaternion(camera[3], camera[4], camera[5], camera[6]);
      position.applyQuaternion(quaternion);
      const heading = new THREE.Vector3(position.x, position.z, position.y).normalize().multiplyScalar(radius);
      const theta = Math.atan2(heading.y, heading.x);
      const phi = Math.acos(heading.z / radius);
      let longitude = THREE.MathUtils.radToDeg(theta);
      longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
      let latitude = 90 - THREE.MathUtils.radToDeg(phi);
      latitude = Math.max(-80, Math.min(80, latitude));
      this.setLongitudeLatitude(longitude, latitude);
      this.markAsDirty();
    }
  }

  render() {
    // slowly rotate scene when not hosted
    if (!StateService.state.hosted) {
      this.longitude += 0.025;
      this.isDirty = true;
    }

    if (this.isDirty) {
      this.isDirty = false;
      this.update();
    }
  }

  markAsDirty() {
    this.isDirty = true;
  }

  update() {
    let radius,
        position = this.updatePosition,
        target = this.updateTarget;
    const zoom = this.getZoomValue();
    this.getDollyValue(); // console.log('dolly', dolly);

    const phi = THREE.MathUtils.degToRad(90 - this.latitude);
    const theta = THREE.MathUtils.degToRad(this.longitude);
    const camera = this.camera;
    const cameraGroup = camera.parent;

    switch (this.mode_) {
      case OrbitMode.Model:
        radius = 3;
        position.copy(this.position);
        target.x = this.position.x + radius * Math.sin(phi) * Math.cos(theta);
        target.y = this.position.y + radius * Math.cos(phi);
        target.z = this.position.z + radius * Math.sin(phi) * Math.sin(theta); // position = cameraGroup.worldToLocal(position);

        target = cameraGroup.worldToLocal(target);
        camera.target.copy(position);
        camera.position.copy(target);
        break;

      default:
        radius = this.radius;
        target.x = this.position.x + radius * Math.sin(phi) * Math.cos(theta);
        target.y = this.position.y + radius * Math.cos(phi);
        target.z = this.position.z + radius * Math.sin(phi) * Math.sin(theta);

        {
          position.copy(this.position);
        } // !!! position for walking panorama-grid
        // position = cameraGroup.worldToLocal(position);


        target = cameraGroup.worldToLocal(target); // camera.position.copy(position);

        camera.target.copy(target);
        camera.position.copy(position);
    } // console.log(camera.position.x, camera.position.y, camera.position.z);
    // console.log(camera.target.x, camera.target.y, camera.target.z);
    // console.log('phi', phi, 'theta', theta);
    // this.inverse();


    {
      camera.zoom = zoom;
    }

    camera.lookAt(camera.target);
    camera.updateProjectionMatrix();
    const currentView = ViewService.currentView;

    if (currentView) {
      currentView.lastOrientation.longitude = this.longitude;
      currentView.lastOrientation.latitude = this.latitude;
    }

    this.events$.next(orbitMoveEvent);
  }

}
OrbitService.orbitMoveEvent = orbitMoveEvent;let UID = 0;
const ImageServiceEvent = {
  Progress: 'progress',
  Complete: 'complete'
};
class ImageService {
  static worker() {
    if (!this.worker_) {
      this.worker_ = new Worker(environment.workers.image);
    }

    return this.worker_;
  }

  static events$(src, size) {
    if (!('Worker' in window) || this.isBlob(src) || this.isCors(src)) {
      return rxjs.of({
        type: ImageServiceEvent.Complete,
        data: src
      });
    }

    const id = ++UID;
    const worker = this.worker();
    worker.postMessage({
      src,
      id,
      size
    });
    return rxjs.fromEvent(worker, 'message').pipe(operators.map(event => event.data), operators.filter(event => event.src === src), operators.auditTime(100), operators.map(event => {
      // console.log('ImageService', event);
      if (event.type === ImageServiceEvent.Complete && event.data instanceof Blob) {
        const url = URL.createObjectURL(event.data);
        event.data = url;
      }
      return event;
    }), operators.takeWhile(event => event.type !== ImageServiceEvent.Complete, true), operators.finalize(() => {
      // console.log('ImageService.finalize', lastEvent);
      worker.postMessage({
        id
      });
      /*
      if (lastEvent && lastEvent.type === ImageServiceEvent.Complete && lastEvent.data) {
      	URL.revokeObjectURL(lastEvent.data);
      }
      */
    }));
  }

  static load$(src, size) {
    return this.events$(src, size).pipe(operators.filter(event => event.type === ImageServiceEvent.Complete), operators.map(event => event.data));
  }

  static isCors(src) {
    // !!! handle cors environment flag
    return false;
  }

  static isBlob(src) {
    return src.indexOf('blob:') === 0;
  }

}class PanoramaLoader {
  static get video() {
    return this.video_;
  }

  static set video(video) {
    if (this.video_) {
      this.video_.muted = true;
      this.video_.pause();

      if (this.video_.parentNode) {
        this.video_.parentNode.removeChild(this.video_);
      }

      this.video_ = null;
    }

    if (video) {
      const video = this.video_ = document.createElement('video');
      video.loop = true;
      video.playsInline = true;
      video.crossOrigin = 'anonymous'; // document.querySelector('body').appendChild(video);
    }
  }

  static get muted() {
    return this.muted_;
  }

  static set muted(muted) {
    this.muted_ = muted; // console.log('PanoramaLoader.muted', muted, this.video);

    if (this.video) {
      this.video.muted = muted === true;
    }
  }

  static set cubeRenderTarget(cubeRenderTarget) {
    if (this.cubeRenderTarget_) {
      this.cubeRenderTarget_.texture.dispose();
      this.cubeRenderTarget_.dispose();
    }

    this.cubeRenderTarget_ = cubeRenderTarget;
  }

  static set texture(texture) {
    if (this.texture_) {
      this.texture_.dispose();
    }

    this.texture_ = texture;
  }

  static load(asset, renderer, callback) {
    MediaLoader.events$.next(new MediaLoaderDisposeEvent(this));
    this.video = null;

    if (!asset) {
      return;
    } // console.log('PanoramaLoader.load', asset.type.name, AssetType);


    if (asset.type.name === AssetType.PublisherStream.name) {
      return this.loadPublisherStreamBackground(renderer, callback);
    } else if (asset.type.name === AssetType.AttendeeStream.name) {
      return this.loadAttendeeStreamBackground(renderer, callback);
      /*} else if (assetIsStream(asset)) {
      	return this.loadStreamBackground(renderer, callback, asset);
      	*/
    } else if (asset.file.indexOf('.mp4') !== -1 || asset.file.indexOf('.webm') !== -1) {
      return this.loadVideoBackground(environment.getPath(asset.folder), asset.file, renderer, callback);
    } else if (asset.file.indexOf('.m3u8') !== -1) {
      return this.loadHlslVideoBackground(asset.file, renderer, callback);
    } else if (asset.file.indexOf('.hdr') !== -1) {
      return this.loadRgbeBackground(environment.getPath(asset.folder), asset.file, renderer, callback);
    } else {
      return this.loadBackgroundImageService(environment.getPath(asset.folder), asset.file, renderer, callback);
    }
  }

  static loadBackgroundImageService(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const image = new Image();
    ImageService.events$(folder + file).pipe(operators.tap(event => {
      if (event.type === ImageServiceEvent.Progress) {
        LoaderService.setProgress(progressRef, event.data.loaded, event.data.total);
      }
    }), operators.filter(event => event.type === ImageServiceEvent.Complete), operators.switchMap(event => {
      const load = rxjs.fromEvent(image, 'load');
      image.crossOrigin = 'anonymous';
      image.src = event.data;
      return load;
    }), operators.takeWhile(event => event.type !== ImageServiceEvent.Complete, true)).subscribe(event => {
      const texture = new THREE.Texture(image);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping; // console.log('texture', texture, THREE.RGBAFormat, THREE.LinearEncoding);
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;

      texture.toneMapped = false;
      texture.needsUpdate = true;

      if (typeof callback === 'function') {
        callback(texture);
        URL.revokeObjectURL(event.data);
      }

      LoaderService.setProgress(progressRef, 1);
    });
  }

  static loadBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const loader = new THREE.TextureLoader();
    loader.setPath(folder).load(file, texture => {
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;

      texture.needsUpdate = true;

      if (typeof callback === 'function') {
        callback(texture);
      }

      LoaderService.setProgress(progressRef, 1);
    }, request => {
      LoaderService.setProgress(progressRef, request.loaded, request.total);
    });
    return loader;
  }

  static loadRgbeBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const loader = new RGBELoader();
    loader.setDataType(THREE.UnsignedByteType).setPath(folder).load(file, texture => {
      if (typeof callback === 'function') {
        callback(texture, true);
      }

      LoaderService.setProgress(progressRef, 1);
    }, request => {
      LoaderService.setProgress(progressRef, request.loaded, request.total);
    });
    return loader;
  }

  static loadHlslVideoBackground(src, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const video = document.createElement('video');

    const onPlaying = () => {
      video.oncanplay = null;
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;

      texture.needsUpdate = true;

      if (typeof callback === 'function') {
        callback(texture);
      }

      LoaderService.setProgress(progressRef, 1);
    };

    video.oncanplay = () => {
      // console.log('videoReady', videoReady);
      onPlaying();
    };

    if (Hls.isSupported()) {
      var hls = new Hls();
      hls.attachMedia(video);
      hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        hls.loadSource(src);
        hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
          video.play();
        });
      });
    }
  } // !!! implementing medialoader interface
  // static get progress
  // static set progress
  // static play
  // static pause


  static get progress() {
    const video = this.video;

    if (video) {
      return video.currentTime / video.duration;
    } else {
      return 0;
    }
  }

  static set progress(progress) {
    const video = this.video;

    if (video) {
      const currentTime = video.duration * progress;

      if (video.seekable.length > progress && video.currentTime !== currentTime) {
        // console.log('PanoramaLoader', 'progress', progress, 'currentTime', currentTime, 'duration', this.video.duration, 'seekable', this.video.seekable);
        video.currentTime = currentTime;
        MediaLoader.events$.next(new MediaLoaderTimeSetEvent(this));
      }
    }
  }

  static play(silent) {
    // console.log('PanoramaLoader.play');
    const video = this.video;

    if (video) {
      video.muted = this.muted_;
      video.play().then(() => {
        // console.log('PanoramaLoader.play.success', this.video.src);
        if (!silent) {
          MediaLoader.events$.next(new MediaLoaderPlayEvent(this));
        }
      }, error => {
        console.log('PanoramaLoader.play.error', video.src, error);
      });
    }
  }

  static pause(silent) {
    // console.log('PanoramaLoader.pause');
    const video = this.video;

    if (video) {
      video.muted = true;
      video.pause();

      if (!silent) {
        MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
      }
    }
  }

  static loadVideoBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    this.video = true;
    const video = this.video;

    const onCanPlay = () => {
      // console.log('PanoramaLoader', 'onPlaying');
      video.oncanplay = null;
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;

      texture.needsUpdate = true;

      if (typeof callback === 'function') {
        callback(texture);
      } // console.log('loadVideoBackground.loaded');


      LoaderService.setProgress(progressRef, 1);

      {
        this.play();
      }
    };

    const onTimeUpdate = () => {
      MediaLoader.events$.next(new MediaLoaderTimeUpdateEvent(this));
    };

    const onEnded = () => {
    };

    video.oncanplay = onCanPlay;
    video.ontimeupdate = onTimeUpdate;
    video.onended = onEnded;
    video.crossOrigin = 'anonymous';
    video.src = folder + file;
    video.load();
  }

  static loadPublisherStreamBackground(renderer, callback) {
    const onPublisherStreamId = publisherStreamId => {
      const video = document.querySelector(`#stream-${publisherStreamId} video`);

      if (!video) {
        return;
      }

      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;

        texture.needsUpdate = true;

        if (typeof callback === 'function') {
          callback(texture);
        }
      };

      video.crossOrigin = 'anonymous';

      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };

    StreamService.getPublisherStreamId$().pipe(operators.first()).subscribe(publisherStreamId => onPublisherStreamId(publisherStreamId));
  }

  static loadAttendeeStreamBackground(renderer, callback) {
    const onAttendeeStreamId = attendeeStreamId => {
      const video = document.querySelector(`#stream-${attendeeStreamId} video`);

      if (!video) {
        return;
      }

      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;

        texture.needsUpdate = true;

        if (typeof callback === 'function') {
          callback(texture);
        }
      };

      video.crossOrigin = 'anonymous';

      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };

    StreamService.getAttendeeStreamId$().pipe(operators.first()).subscribe(attendeeStreamId => onAttendeeStreamId(attendeeStreamId));
  }

  static loadStreamBackground(renderer, callback, asset) {
    const onStreamId = streamId => {
      const video = document.querySelector(`#stream-${streamId} video`);

      if (!video) {
        return;
      }

      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;

        texture.needsUpdate = true;

        if (typeof callback === 'function') {
          callback(texture);
        }
      };

      video.crossOrigin = 'anonymous';

      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };

    PanoramaLoader.getStreamId$(asset).pipe(operators.takeUntil(MediaLoader.events$.pipe(operators.filter(event => event instanceof MediaLoaderDisposeEvent)))).subscribe(streamId => {
      onStreamId(streamId);
    });
  }

  static getStreamId$(asset) {
    const assetType = asset.type;
    return StreamService.streams$.pipe(operators.map(streams => {
      // console.log('streams', streams);
      let stream;
      let i = 0;
      const matchType = MediaMesh.getTypeMatcher(assetType);
      streams.forEach(x => {
        // console.log('streams', matchType(x), x, asset);
        if (matchType(x)) {
          if (i === asset.index) {
            stream = x;
          }

          i++;
        }
      });

      if (stream) {
        return stream.getId();
      } else {
        return null;
      }
    }));
  }

}// import * as THREE from 'three';
class Panorama {
  constructor(renderer) {
    this.muted_ = false;
    this.subscription = StateService.state$.subscribe(state => PanoramaLoader.muted = state.volumeMuted);
    this.tween = 0;
    this.create(renderer);
  }

  create(renderer) {
    this.renderer = renderer;
    this.onCubeMapDispose = this.onCubeMapDispose.bind(this);
    const geometry = new THREE.BoxGeometry(202, 202, 202);
    const material = this.getBlackMaterial();
    const mesh = new InteractiveMesh(geometry, material);
    mesh.userData = {
      render: (time, tick, renderer, scene, camera) => {
        mesh.matrixWorld.copyPosition(camera.matrixWorld);
        const cubeMap = this.cubeMap;
        const texture = this.texture;

        if (cubeMap && texture && texture.isVideoTexture) {
          this.updateCubeMapEquirectangularTexture(cubeMap, renderer, texture);
        }
      }
    };
    mesh.name = '[panorama]';
    this.mesh = mesh;
  }

  getBlackMaterial() {
    return new THREE.MeshBasicMaterial({
      name: 'PanoramaStandardMaterial',
      color: 0x000000,
      side: THREE.BackSide,
      depthTest: false,
      depthWrite: false,
      fog: false
    });
  }

  getShaderMaterial(texture) {
    const material = new THREE.ShaderMaterial({
      name: 'PanoramaCubeMaterial',
      uniforms: this.cloneUniforms(THREE.ShaderLib.cube.uniforms),
      vertexShader: THREE.ShaderLib.cube.vertexShader,
      fragmentShader: THREE.ShaderLib.cube.fragmentShader,
      side: THREE.BackSide,
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false
    });
    texture.mapping = THREE.EquirectangularReflectionMapping;
    const cubeMap = this.toCubeMap(texture, this.renderer);
    material.map = cubeMap;
    material.uniforms.envMap.value = cubeMap;
    material.uniforms.flipEnvMap.value = cubeMap.isCubeTexture && cubeMap._needsFlipEnvMap ? -1 : 1;
    material.needsUpdate = true;
    this.mesh.geometry.deleteAttribute('normal');
    this.mesh.geometry.deleteAttribute('uv');
    Object.defineProperty(material, 'envMap', {
      get: function () {
        return this.uniforms.envMap.value;
      },
      configurable: true
    });
    return material;
  }

  makeEnvMap(texture) {
    let material = this.mesh.material;

    if (!material.uniforms) {
      material.dispose();
      material = this.getShaderMaterial(texture);
      this.mesh.material = material;
    } else {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      const cubeMap = this.toCubeMap(texture, this.renderer);
      material.map = cubeMap;
      material.uniforms.envMap.value = cubeMap;
      material.uniforms.flipEnvMap.value = cubeMap.isCubeTexture && cubeMap._needsFlipEnvMap ? -1 : 1;
      material.needsUpdate = true;
    } // console.log('Panorama.makeEnvMap', this.texture, this.cubeMap);

  }

  toCubeMap(texture, renderer) {
    if (this.cubeMap) {
      this.cubeMap.dispose();
    }

    const image = texture.image;
    const height = image.height || image.videoHeight;
    const cubeMap = new THREE.WebGLCubeRenderTarget(height / 2, {
      generateMipmaps: true,
      type: THREE.HalfFloatType,
      encoding: THREE.LinearEncoding,
      // minFilter: THREE.LinearMipmapLinearFilter,
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      // mapping: THREE.CubeReflectionMapping,
      // mapping: THREE.EquirectangularReflectionMapping,
      mapping: THREE.CubeUVReflectionMapping,
      // mapping: THREE.UVMapping,
      format: THREE.RGBAFormat
    });
    cubeMap.addEventListener('dispose', this.onCubeMapDispose);
    this.setCubeMapEquirectangularTexture(cubeMap, texture);
    this.updateCubeMapEquirectangularTexture(cubeMap, renderer, texture);
    this.cubeMap = cubeMap;
    this.texture = texture;
    return this.mapTextureMapping(cubeMap.texture, texture.mapping);
  }

  setCubeMapEquirectangularTexture(cubeMap, texture) {
    cubeMap.texture.type = texture.type;
    cubeMap.texture.format = THREE.RGBAFormat;
    cubeMap.texture.encoding = THREE.sRGBEncoding;
    cubeMap.texture.generateMipmaps = texture.generateMipmaps;
    cubeMap.texture.minFilter = texture.minFilter;
    cubeMap.texture.magFilter = texture.magFilter;
    cubeMap.texture.needsUpdate = true;
    const shader = {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader:
      /* glsl */
      `
					varying vec3 vWorldDirection;
					vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
						return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
					}
					void main() {
						vWorldDirection = transformDirection( position, modelMatrix );
						#include <begin_vertex>
						#include <project_vertex>
					}
				`,
      fragmentShader:
      /* glsl */
      `
					uniform sampler2D tEquirect;
					varying vec3 vWorldDirection;
					#include <common>
					void main() {
						vec3 direction = normalize( vWorldDirection );
						vec2 sampleUV = equirectUv( direction );
						gl_FragColor = texture2D( tEquirect, sampleUV );
					}
				`
    };
    const geometry = new THREE.BoxGeometry(5, 5, 5);
    const material = new THREE.ShaderMaterial({
      name: 'CubemapFromEquirect',
      uniforms: this.cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: THREE.BackSide,
      blending: THREE.NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new THREE.Mesh(geometry, material);
    const camera = new THREE.CubeCamera(1, 10, cubeMap);
    cubeMap.camera = camera;
    cubeMap.mesh = mesh;
    return cubeMap;
  }

  updateCubeMapEquirectangularTexture(cubeMap, renderer, texture) {
    const previousMinFilter = texture.minFilter; // Avoid blurred poles

    if (texture.minFilter === THREE.LinearMipmapLinearFilter) {
      texture.minFilter = THREE.LinearFilter;
    }
    /*
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    const toneMappingExposure = renderer.toneMappingExposure;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.outputEncoding = THREE.LinearEncoding;
    renderer.toneMappingExposure = 2;
    */


    cubeMap.camera.update(renderer, cubeMap.mesh);
    /*
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.toneMappingExposure = toneMappingExposure;
    */

    texture.minFilter = previousMinFilter; // console.log('updateCubeMapEquirectangularTexture');
  }

  cloneUniforms(src) {
    const dst = {};

    for (const u in src) {
      dst[u] = {};

      for (const p in src[u]) {
        const property = src[u][p];

        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }

    return dst;
  }

  mapTextureMapping(texture, mapping) {
    if (mapping === THREE.EquirectangularReflectionMapping) {
      texture.mapping = THREE.CubeReflectionMapping;
    } else if (mapping === THREE.EquirectangularRefractionMapping) {
      texture.mapping = THREE.CubeRefractionMapping;
    }

    return texture;
  }

  onCubeMapDispose() {
    const cubeMap = this.cubeMap;

    if (cubeMap) {
      // console.log('Panorama.onCubeMapDispose', cubeMap);
      cubeMap.removeEventListener('dispose', this.onCubeMapDispose);
      cubeMap.texture.dispose();
      cubeMap.mesh.geometry.dispose();
      cubeMap.mesh.material.dispose();

      if (cubeMap !== undefined) {
        this.cubeMap = null;
      }
    }
  }

  change(view, renderer, callback, onexit) {
    const item = view instanceof PanoramaGridView ? view.tiles[view.index_] : view;
    const material = this.mesh.material;
    this.load(item, renderer, envMap => {
      if (typeof onexit === 'function') {
        onexit(view);
      }

      if (material.uniforms && material.uniforms.uTween) {
        material.uniforms.uTween.value = 1;
        material.needsUpdate = true;
      }

      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }

  crossfade(item, renderer, callback) {
    const material = this.mesh.material;
    this.load(item, renderer, envMap => {
      if (material.uniforms && material.uniforms.uTween) {
        material.uniforms.uTween.value = 1;
        material.needsUpdate = true;
      }

      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }

  getLocalizedAsset(asset) {
    if (asset && asset.locale) {
      const localizedAsset = asset.locale[LanguageService.lang];

      if (localizedAsset) {
        asset = localizedAsset;
      }
    }

    return asset;
  }

  load(item, renderer, callback) {
    const asset = item.type.name === ViewType.Media.name ? Asset.defaultMediaAsset : item.asset;

    if (!asset) {
      return;
    }

    if (asset.type.name === AssetType.Model.name) {
      if (typeof callback === 'function') {
        callback(null);
      }

      return;
    }

    const localizedAsset = this.getLocalizedAsset(asset); // console.log('Panorama.load.localizedAsset', localizedAsset, 'asset', asset);

    this.currentAsset = localizedAsset.folder + localizedAsset.file;
    PanoramaLoader.load(localizedAsset, renderer, (texture, rgbe) => {
      if (localizedAsset.folder + localizedAsset.file !== this.currentAsset) {
        texture.dispose();
        return;
      }

      const envMap = this.makeEnvMap(texture);

      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }

  dispose() {
    this.subscription.unsubscribe();

    if (this.cubeMap) {
      this.cubeMap.dispose();
    }
  }

}// import * as THREE from 'three';
const W = 12;
const H = 27;
const D = 0.5;
const R = 4 / 3;
const COLORS = [0xffffff, 0xffcc00, 0x00ffcc, 0x00ccff, 0xccff00, 0xcc00ff];
class PhoneStreamElement {
  static get geometry() {
    const geometry = new THREE.PlaneBufferGeometry(0.01 * W, 0.01 * W / R, 2, 2);
    return geometry;
  }

  setRemote(remote, i, total) {
    this.remote = remote;
    let s,
        c,
        r,
        w,
        h,
        sx,
        sy,
        sz = 0.01 * D; // !!! double distance

    if (total < 4) {
      s = 1;
      c = 0;
      r = i;
      w = 0.01 * W * s;
      h = w / R;
      sx = 0;
      sy = h / 2 - total * h / 2;
      this.plane.position.set(sx, sy + h * i, sz);
    } else {
      s = 0.5;
      c = i % 2;
      r = Math.floor(i / 2);
      w = 0.01 * W * s;
      h = w / R;
      sx = -w / 2;
      sy = h / 2 - Math.ceil(total / 2) * h / 2;
      this.plane.position.set(sx + c * w, sy + r * h, sz);
    }

    this.plane.scale.set(s, s, s); // console.log(this.plane.position);

    if (typeof remote === 'number') {
      this.plane.material.color.set(COLORS[i % COLORS.length]);
    } else {
      if (remote.texture) {
        this.plane.material.map = remote.texture;
        this.plane.material.needsUpdate = true;
      } else {
        this.addStreamTexture(remote.getId(), texture => {
          remote.texture = texture;
          this.plane.material.map = texture;
          this.plane.material.needsUpdate = true;
        });
      }
    }
  }

  addStreamTexture(streamId, callback) {
    const target = `#stream-${streamId}`; // `#stream-remote-${streamId}`;

    const video = document.querySelector(`${target} video`);

    if (!video) {
      return;
    }

    const onPlaying = () => {
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping; // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.sRGBEncoding;

      texture.needsUpdate = true;

      if (typeof callback === 'function') {
        callback(texture);
      }
    };

    video.crossOrigin = 'anonymous';

    if (video.readyState >= video.HAVE_FUTURE_DATA) {
      onPlaying();
    } else {
      video.oncanplay = () => {
        onPlaying();
      };
    }
  }

  constructor() {
    const geometry = PhoneStreamElement.geometry;
    const material = new THREE.MeshBasicMaterial({
      // depthTest: false,
      color: 0xffffff // side: THREE.DoubleSide,

    });
    this.plane = new THREE.Mesh(geometry, material);
  }

}
class PhoneElement {
  set remotes(remotes) {
    // console.log('PhoneElement', remotes);
    remotes.forEach((remote, i) => {
      let stream = this.streams[i];

      if (!stream) {
        stream = new PhoneStreamElement();
      }

      stream.setRemote(remote, i, remotes.length);
      this.phone.add(stream.plane);
      this.streams[i] = stream;
    });

    for (let i = remotes.length; i < this.streams.length; i++) {
      this.phone.remove(this.streams[i].plane);
    }

    this.streams.length = remotes.length;
  }

  constructor() {
    const mesh = this.mesh = new THREE.Group();
    const phone = this.phone = this.create();
    mesh.add(phone);
    this.streams = [];
    StreamService.remotes$.subscribe(remotes => {
      this.remotes = remotes;
    });
  }

  create() {
    const geometry = new THREE.BoxBufferGeometry(0.01 * W, 0.01 * H, 0.01 * D, 2, 2, 1);
    const material = new THREE.MeshStandardMaterial({
      // depthTest: false,
      color: 0x000000,
      transparent: true,
      opacity: 0.6
    });
    const phone = new THREE.Mesh(geometry, material);
    phone.rotation.set(-Math.PI / 4, 0, 0);
    return phone;
  }

}// import * as THREE from 'three';
class PointerElement {
  constructor(color) {
    if (color === void 0) {
      color = '#ffffff';
    }

    this.position = new THREE.Vector3(); // const targetPosition = this.targetPosition = new THREE.Vector3();

    const geometry = Geometry.planeGeometry; // new THREE.PlaneBufferGeometry(1.2, 1.2, 2, 2);

    const loader = new THREE.TextureLoader();
    const texture = loader.load(environment.getPath('textures/ui/nav-point.png'));
    const material = new THREE.MeshBasicMaterial({
      color: new THREE.Color(color),
      depthTest: false,
      depthWrite: false,
      map: texture,
      transparent: true,
      opacity: 0.9
    });
    const mesh = this.mesh = new THREE.Mesh(geometry, material);
    mesh.renderOrder = environment.renderOrder.pointer;
    mesh.position.set(-100000, -100000, -100000);
  }

  update(camera) {
    if (Interactive.lastIntersectedObject) {
      const position = this.position;
      position.copy(Interactive.lastIntersectedObject.intersection.point);
      position.multiplyScalar(0.99);
      const mesh = this.mesh;
      mesh.position.set(position.x, position.y, position.z);
      position.sub(camera.position);
      const s = position.length() / 80;
      mesh.scale.set(s, s, s);
      /*
      const targetPosition = this.targetPosition;
      targetPosition.set(0, 0, 0);
      camera.localToWorld(targetPosition);
      */

      mesh.lookAt(Host.origin);
    }
  }

  setPosition(x, y, z, camera) {
    const position = this.position;
    position.set(x, y, z).multiplyScalar(80);
    const mesh = this.mesh;
    mesh.position.copy(position);
    position.sub(camera.position);
    const s = position.length() / 80;
    mesh.scale.set(s, s, s);
    /*
    const targetPosition = this.targetPosition;
    targetPosition.set(0, 0, 0);
    camera.localToWorld(targetPosition);
    */

    mesh.lookAt(Host.origin);
  }

}// import * as THREE from 'three';
const LINE_SEGMENTS = 10;
class TeleportElement {
  constructor() {
    this.gravity = new THREE.Vector3(0, -9.8, 0);
    this.controllerPosition = new THREE.Vector3();
    this.controllerDirection = new THREE.Vector3();
    this.currentPosition = new THREE.Vector3();
    this.targetPosition = new THREE.Vector3();
    const geometry = new THREE.BufferGeometry();
    const vertices = this.vertices = new Float32Array((LINE_SEGMENTS + 1) * 3);
    vertices.fill(0);
    const colors = new Float32Array((LINE_SEGMENTS + 1) * 3);
    colors.fill(0.5);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const lineMaterial = new THREE.LineBasicMaterial({
      vertexColors: true,
      blending: THREE.AdditiveBlending
    });
    this.line = new THREE.Line(geometry, lineMaterial); // const light = this.light = new THREE.PointLight(0xffeeaa, 0, 2);

    const loader = new THREE.TextureLoader();
    const texture = loader.load(environment.getPath('textures/ui/nav-point.png'));
    const target = this.target = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.3, 0.3, 1, 1), new THREE.MeshBasicMaterial({
      map: texture,
      blending: THREE.AdditiveBlending,
      color: 0x555555,
      transparent: true
    }));
    target.rotation.x = -Math.PI / 2;
  }

  addToController(controller, scene) {
    this.currentController = controller; // this.light.intensity = 1;

    controller.add(this.line);
    scene.add(this.target);
  }

  removeFromController(controller, scene, renderer, camera, cameraGroup) {
    const currentController = this.currentController;

    if (currentController === controller) {
      const gravity = this.gravity;
      const currentPosition = this.currentPosition;
      const controllerPosition = this.controllerPosition;
      const controllerDirection = this.controllerDirection;
      renderer.xr.getCamera(camera).getWorldPosition(currentPosition);
      currentPosition.y = 0;
      currentController.getWorldPosition(controllerPosition);
      currentController.getWorldDirection(controllerDirection);
      controllerDirection.multiplyScalar(6);
      const T = (-controllerDirection.y + Math.sqrt(controllerDirection.y ** 2 - 2 * controllerPosition.y * gravity.y)) / gravity.y;
      const targetPosition = this.getPositionT(this.targetPosition, T, controllerPosition, controllerDirection, gravity);
      targetPosition.addScaledVector(currentPosition, -1);
      cameraGroup.position.add(targetPosition); // this.teleport(targetPosition, cameraGroup);

      this.currentController = null; // this.light.intensity = 0;

      currentController.remove(this.line);
      scene.remove(this.target);
    }
  }

  update() {
    const currentController = this.currentController;

    if (currentController) {
      const gravity = this.gravity;
      const controllerPosition = this.controllerPosition;
      const controllerDirection = this.controllerDirection;
      const targetPosition = this.targetPosition; // Controller start position

      currentController.getWorldPosition(controllerPosition); // Set Vector V to the direction of the controller, at 1m/s

      currentController.getWorldDirection(controllerDirection); // Scale the initial velocity to 6m/s

      controllerDirection.multiplyScalar(6); // Time for tele ball to hit ground

      const T = (-controllerDirection.y + Math.sqrt(controllerDirection.y ** 2 - 2 * controllerPosition.y * gravity.y)) / gravity.y;
      const vertex = targetPosition.set(0, 0, 0);

      for (let i = 1; i <= LINE_SEGMENTS; i++) {
        // set vertex to current position of the virtual ball at time t
        this.getPositionT(vertex, i * T / LINE_SEGMENTS, controllerPosition, controllerDirection, gravity);
        currentController.worldToLocal(vertex);
        vertex.toArray(this.vertices, i * 3);
      }

      this.line.geometry.attributes.position.needsUpdate = true; // Place the light and sprite near the end of the poing
      // this.getPositionT(this.light.position, T * 0.98, controllerPosition, controllerDirection, gravity);

      this.getPositionT(this.target.position, T * 0.98, controllerPosition, controllerDirection, gravity);
    }
  }

  getPositionT(position, T, controllerPosition, controllerDirection, gravity) {
    position.copy(controllerPosition);
    position.addScaledVector(controllerDirection, T);
    position.addScaledVector(gravity, 0.5 * T ** 2);
    return position;
  }
  /*
  teleport(offsetPosition, cameraGroup) {
  	const position = new THREE.Vector3();
  	position.copy(cameraGroup.position);
  	position.add(offsetPosition);
  	// const distance = offsetPosition.length();
  	cameraGroup.position.copy(position);
  }
  */


}const XRStatus = {
  Waiting: 'waiting',
  Enabled: 'enabled',
  Ended: 'ended',
  Started: 'started',
  Disabled: 'disabled',
  NeedsHttps: 'needs-https',
  Unavailable: 'unavailable'
};
class VRService {
  static getService() {
    if (!this.service_) {
      this.service_ = new VRService();
    }

    return this.service_;
  }

  get status() {
    return this.status$.getValue();
  }

  get state() {
    return this.state$.getValue();
  }

  constructor() {
    if (VRService.service_) {
      throw 'VRService is a singleton class!';
    }

    const state = this.state_ = {
      camera: {
        position: new THREE.Vector3(),
        quaternion: new THREE.Quaternion(),
        scale: new THREE.Vector3(),
        array: new Array(3 + 4 + 3).fill(0)
      }
    };
    this.onSessionStarted = this.onSessionStarted.bind(this);
    this.onSessionEnded = this.onSessionEnded.bind(this);
    this.status$ = new rxjs.BehaviorSubject(XRStatus.Waiting);
    this.session$ = new rxjs.Subject();
    this.state$ = new rxjs.BehaviorSubject(state);
    this.currentSession = null;

    if ('xr' in navigator) {
      navigator.xr.isSessionSupported('immersive-vr').then(supported => {
        if (supported) {
          this.status$.next(XRStatus.Enabled);
        } else {
          this.status$.next(XRStatus.Disabled);
        }
      });
    } else {
      if (window.isSecureContext === false) {
        this.status$.next(XRStatus.NeedsHttps);
      } else {
        this.status$.next(XRStatus.Unavailable); // 'https://immersiveweb.dev/';
      }
    }
  }

  onSessionStarted(session) {
    session.addEventListener('end', this.onSessionEnded);
    this.currentSession = session;
    this.session$.next(session);
    this.status$.next(XRStatus.Started);
  }

  onSessionEnded() {
    this.currentSession.removeEventListener('end', this.onSessionEnded);
    this.currentSession = null;
    this.session$.next(null);
    this.status$.next(XRStatus.Ended);
  }

  toggleVR(event) {
    if (this.currentSession === null) {
      // WebXR's requestReferenceSpace only works if the corresponding feature
      // was requested at session creation time. For simplicity, just ask for
      // the interesting ones as optional features, but be aware that the
      // requestReferenceSpace call will fail if it turns out to be unavailable.
      // ('local' is always available for immersive sessions and doesn't need to
      // be requested separately.)
      const sessionInit = {
        optionalFeatures: ['local-floor', 'bounded-floor']
      };
      navigator.xr.requestSession('immersive-vr', sessionInit).then(this.onSessionStarted);
    } else {
      this.currentSession.end();
    }
  }

  isDisabled() {
    const status = this.status$.getValue();

    switch (status) {
      case XRStatus.Waiting:
      case XRStatus.Disabled:
      case XRStatus.NeedsHttps:
      case XRStatus.Unavailable:
        return true;

      default:
        return false;
    }
  }

  getLabel() {
    let label;
    const status = this.status$.getValue();

    switch (status) {
      case XRStatus.Waiting:
        label = 'Waiting VR';
        break;

      case XRStatus.Enabled:
      case XRStatus.Ended:
        label = 'Enter VR';
        break;

      case XRStatus.Started:
        label = 'Exit VR';
        break;

      case XRStatus.Disabled:
        label = 'VR Disabled';
        break;

      case XRStatus.NeedsHttps:
        label = 'VR Needs Https';
        break;

      case XRStatus.Unavailable:
        label = 'VR Unavailable';
        break;
    }

    return label;
  }

  updateState(world) {
    if (this.status === XRStatus.Started) {
      world.renderer;
            world.scene;
            const camera = world.camera,
            state = this.state_;
      camera.matrixWorld.decompose(state.camera.position, state.camera.quaternion, state.camera.scale);
      state.camera.array[0] = state.camera.position.x;
      state.camera.array[1] = state.camera.position.y;
      state.camera.array[2] = state.camera.position.z;
      state.camera.array[3] = state.camera.quaternion.x;
      state.camera.array[4] = state.camera.quaternion.y;
      state.camera.array[5] = state.camera.quaternion.z;
      state.camera.array[6] = state.camera.quaternion.w;
      state.camera.array[7] = state.camera.scale.x;
      state.camera.array[8] = state.camera.scale.y;
      state.camera.array[9] = state.camera.scale.z;
      this.state$.next(state);
    }
  }

}class Emittable {
  constructor() {
    this.events = {};
  }

  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }

  off(type, callback) {
    const event = this.events[type];

    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }

  emit(type, data) {
    const event = this.events[type];

    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }

    const broadcast = this.events.broadcast;

    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }

}// import * as THREE from 'three';
class Gamepad extends Emittable {
  constructor(gamepad) {
    super();
    this.gamepad = gamepad;
    this.buttons = {};
    this.axes = {};
  }

  update() {
    this.updateButtons();
    this.updateAxes();
  }

  updateButtons() {
    this.gamepad.buttons.forEach((x, i) => {
      const pressed = x.pressed;
      const button = this.buttons[i] || (this.buttons[i] = new GamepadButton(i, this));

      if (button.pressed !== pressed) {
        button.pressed = pressed;

        if (pressed) {
          this.emit('press', button);
        } else if (status !== undefined) {
          this.emit('release', button);
        }
      }
    });
  }

  updateAxes() {
    const axes = this.gamepad.axes;

    for (let i = 0; i < axes.length; i += 2) {
      const index = Math.floor(i / 2);
      const axis = this.axes[index] || (this.axes[index] = new GamepadAxis(index, this));
      const x = axes[i];
      const y = axes[i + 1];

      if (axis.x !== x || axis.y !== y) {
        axis.x = x;
        axis.y = y;

        if (Math.abs(x) > Math.abs(y)) {
          const left = x < -0.85;
          const right = x > 0.85;

          if (axis.left !== left) {
            axis.left = left;
            this.emit(left ? 'left' : 'none', axis); // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} left ${left}`);
          }

          if (axis.right !== right) {
            axis.right = right;
            this.emit(right ? 'right' : 'none', axis); // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} right ${right}`);
          }
        } else {
          const up = y < -0.85;
          const down = y > 0.85;

          if (axis.up !== up) {
            axis.up = up;
            this.emit(up ? 'up' : 'none', axis); // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} up ${up}`);
          }

          if (axis.down !== down) {
            axis.down = down;
            this.emit(down ? 'down' : 'none', axis); // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} down ${down}`);
          }
        }

        this.emit('axis', axis);
      }
    }
  }

  feedback(strength, duration) {
    if (strength === void 0) {
      strength = 0.1;
    }

    if (duration === void 0) {
      duration = 50;
    }

    // !!! care for battery
    const actuators = this.gamepad.hapticActuators;

    if (actuators && actuators.length) {
      return actuators[0].pulse(strength, duration);
    } else {
      return Promise.reject();
    }
  }

}

class GamepadButton {
  constructor(index, gamepad) {
    this.index = index;
    this.gamepad = gamepad;
    this.pressed = false;
  }

}

class GamepadAxis extends THREE.Vector2 {
  constructor(index, gamepad) {
    super();
    this.index = index;
    this.gamepad = gamepad;
    this.left = this.right = this.up = this.down = false;
  }

}class GLTFLoader extends three.Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = three.LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new three.FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let content;
		const extensions = {};
		const plugins = {};

		if ( typeof data === 'string' ) {

			content = data;

		} else {

			const magic = three.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = three.LoaderUtils.decodeText( new Uint8Array( data ) );

			}

		}

		const json = JSON.parse( content );

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new three.Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new three.DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new three.PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new three.SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return three.MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new three.Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new three.Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			materialParams.sheenColor.fromArray( extension.sheenColorFactor );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || 0;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new three.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new three.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture ).then( function ( texture ) {

				texture.encoding = three.sRGBEncoding;

			} ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const result = new ArrayBuffer( count * stride );
				const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

				decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
				return result;

			} );

		} else {

			return null;

		}

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: three.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = three.LoaderUtils.decodeText( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
 */

/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */
class GLTFMeshStandardSGMaterial extends three.MeshStandardMaterial {

	constructor( params ) {

		super();

		this.isGLTFSpecularGlossinessMaterial = true;

		//various chunks that need replacing
		const specularMapParsFragmentChunk = [
			'#ifdef USE_SPECULARMAP',
			'	uniform sampler2D specularMap;',
			'#endif'
		].join( '\n' );

		const glossinessMapParsFragmentChunk = [
			'#ifdef USE_GLOSSINESSMAP',
			'	uniform sampler2D glossinessMap;',
			'#endif'
		].join( '\n' );

		const specularMapFragmentChunk = [
			'vec3 specularFactor = specular;',
			'#ifdef USE_SPECULARMAP',
			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	specularFactor *= texelSpecular.rgb;',
			'#endif'
		].join( '\n' );

		const glossinessMapFragmentChunk = [
			'float glossinessFactor = glossiness;',
			'#ifdef USE_GLOSSINESSMAP',
			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	glossinessFactor *= texelGlossiness.a;',
			'#endif'
		].join( '\n' );

		const lightPhysicalFragmentChunk = [
			'PhysicalMaterial material;',
			'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
			'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
			'material.roughness += geometryRoughness;',
			'material.roughness = min( material.roughness, 1.0 );',
			'material.specularColor = specularFactor;',
		].join( '\n' );

		const uniforms = {
			specular: { value: new three.Color().setHex( 0xffffff ) },
			glossiness: { value: 1 },
			specularMap: { value: null },
			glossinessMap: { value: null }
		};

		this._extraUniforms = uniforms;

		this.onBeforeCompile = function ( shader ) {

			for ( const uniformName in uniforms ) {

				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

			}

			shader.fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

		};

		Object.defineProperties( this, {

			specular: {
				get: function () {

					return uniforms.specular.value;

				},
				set: function ( v ) {

					uniforms.specular.value = v;

				}
			},

			specularMap: {
				get: function () {

					return uniforms.specularMap.value;

				},
				set: function ( v ) {

					uniforms.specularMap.value = v;

					if ( v ) {

						this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

					} else {

						delete this.defines.USE_SPECULARMAP;

					}

				}
			},

			glossiness: {
				get: function () {

					return uniforms.glossiness.value;

				},
				set: function ( v ) {

					uniforms.glossiness.value = v;

				}
			},

			glossinessMap: {
				get: function () {

					return uniforms.glossinessMap.value;

				},
				set: function ( v ) {

					uniforms.glossinessMap.value = v;

					if ( v ) {

						this.defines.USE_GLOSSINESSMAP = '';
						this.defines.USE_UV = '';

					} else {

						delete this.defines.USE_GLOSSINESSMAP;
						delete this.defines.USE_UV;

					}

				}
			}

		} );

		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;

		this.setValues( params );

	}

	copy( source ) {

		super.copy( source );

		this.specularMap = source.specularMap;
		this.specular.copy( source.specular );
		this.glossinessMap = source.glossinessMap;
		this.glossiness = source.glossiness;
		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;
		return this;

	}

}


class GLTFMaterialsPbrSpecularGlossinessExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

		this.specularGlossinessParams = [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'normalMapType',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity',
			'refractionRatio',
		];

	}

	getMaterialType() {

		return GLTFMeshStandardSGMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

		materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const pending = [];

		if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

			const array = pbrSpecularGlossiness.diffuseFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

		}

		materialParams.emissive = new three.Color( 0.0, 0.0, 0.0 );
		materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
		materialParams.specular = new three.Color( 1.0, 1.0, 1.0 );

		if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

			materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

		}

		if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

			const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
			pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
			pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

		}

		return Promise.all( pending );

	}

	createMaterial( materialParams ) {

		const material = new GLTFMeshStandardSGMaterial( materialParams );
		material.fog = true;

		material.color = materialParams.color;

		material.map = materialParams.map === undefined ? null : materialParams.map;

		material.lightMap = null;
		material.lightMapIntensity = 1.0;

		material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
		material.aoMapIntensity = 1.0;

		material.emissive = materialParams.emissive;
		material.emissiveIntensity = 1.0;
		material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

		material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
		material.bumpScale = 1;

		material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
		material.normalMapType = three.TangentSpaceNormalMap;

		if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

		material.displacementMap = null;
		material.displacementScale = 1;
		material.displacementBias = 0;

		material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
		material.specular = materialParams.specular;

		material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
		material.glossiness = materialParams.glossiness;

		material.alphaMap = null;

		material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
		material.envMapIntensity = 1.0;

		material.refractionRatio = 0.98;

		return material;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends three.Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

}

GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

	const result = this.resultBuffer;
	const values = this.sampleValues;
	const stride = this.valueSize;

	const stride2 = stride * 2;
	const stride3 = stride * 3;

	const td = t1 - t0;

	const p = ( t - t0 ) / td;
	const pp = p * p;
	const ppp = pp * p;

	const offset1 = i1 * stride3;
	const offset0 = offset1 - stride3;

	const s2 = - 2 * ppp + 3 * pp;
	const s3 = ppp - pp;
	const s0 = 1 - s2;
	const s1 = s3 - pp + p;

	// Layout of keyframe output values for CUBICSPLINE animations:
	//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
	for ( let i = 0; i !== stride; i ++ ) {

		const p0 = values[ offset0 + i + stride ]; // splineVertex_k
		const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
		const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
		const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

		result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

	}

	return result;

};

const _q = new three.Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: three.NearestFilter,
	9729: three.LinearFilter,
	9984: three.NearestMipmapNearestFilter,
	9985: three.LinearMipmapNearestFilter,
	9986: three.NearestMipmapLinearFilter,
	9987: three.LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: three.ClampToEdgeWrapping,
	33648: three.MirroredRepeatWrapping,
	10497: three.RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: three.InterpolateLinear,
	STEP: three.InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new three.MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: three.FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	let geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.
		if ( typeof createImageBitmap !== 'undefined' && /Firefox|^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === false ) {

			this.textureLoader = new three.ImageBitmapLoader( this.options.manager );

		} else {

			this.textureLoader = new three.TextureLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new three.FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this.loadNode( index );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this.loadAnimation( index );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					throw new Error( 'Unknown type: ' + type );

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( three.LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return Promise.resolve( null );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new three.InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new three.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new three.BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new three.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			if ( textureDef.name ) texture.name = textureDef.name;

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || three.LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || three.LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || three.RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || three.RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( function ( texture ) {

				return texture.clone();

			} ).catch( function ( error ) {

				throw error;

			} );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new three.Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( three.LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new three.PointsMaterial();
				three.Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new three.LineBasicMaterial();
				three.Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return three.MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

			const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
			materialType = sgExtension.getMaterialType();
			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = three.DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new three.Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== three.MeshBasicMaterial ) {

			materialParams.emissive = new three.Color().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

		}

		return Promise.all( pending ).then( function () {

			let material;

			if ( materialType === GLTFMeshStandardSGMaterial ) {

				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

			} else {

				material = new materialType( materialParams );

			}

			if ( materialDef.name ) material.name = materialDef.name;

			// baseColorTexture, emissiveTexture, sheenColorMap, specularColorMap and specularGlossinessTexture use sRGB encoding.
			if ( material.map ) material.map.encoding = three.sRGBEncoding;
			if ( material.emissiveMap ) material.emissiveMap.encoding = three.sRGBEncoding;
			if ( material.sheenColorMap ) material.sheenColorMap.encoding = three.sRGBEncoding;
			if ( material.specularColorMap ) material.specularColorMap.encoding = three.sRGBEncoding;
			if ( material.specularMap ) material.specularMap.encoding = three.sRGBEncoding;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = three.PropertyBinding.sanitizeNodeName( originalName || '' );

		let name = sanitizedName;

		for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new three.BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new three.SkinnedMesh( geometry, material )
						: new three.Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, three.TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, three.TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new three.LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new three.Line( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new three.LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new three.Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			const group = new three.Group();

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new three.PerspectiveCamera( three.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new three.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const skinEntry = { joints: skinDef.joints };

		if ( skinDef.inverseBindMatrices === undefined ) {

			return Promise.resolve( skinEntry );

		}

		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;

		const animationDef = json.animations[ animationIndex ];

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();
				node.matrixAutoUpdate = true;

				let TypedKeyframeTrack;

				switch ( PATH_PROPERTIES[ target.path ] ) {

					case PATH_PROPERTIES.weights:

						TypedKeyframeTrack = three.NumberKeyframeTrack;
						break;

					case PATH_PROPERTIES.rotation:

						TypedKeyframeTrack = three.QuaternionKeyframeTrack;
						break;

					case PATH_PROPERTIES.position:
					case PATH_PROPERTIES.scale:
					default:

						TypedKeyframeTrack = three.VectorKeyframeTrack;
						break;

				}

				const targetName = node.name ? node.name : node.uuid;

				const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : three.InterpolateLinear;

				const targetNames = [];

				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

					node.traverse( function ( object ) {

						if ( object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				let outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					const scale = getNormalizedComponentScale( outputArray.constructor );
					const scaled = new Float32Array( outputArray.length );

					for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

					const track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							const interpolantType = ( this instanceof three.QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

							return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new three.AnimationClip( name, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		return ( function () {

			const pending = [];

			const meshPromise = parser._invokeOne( function ( ext ) {

				return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

			} );

			if ( meshPromise ) {

				pending.push( meshPromise );

			}

			if ( nodeDef.camera !== undefined ) {

				pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

					return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

				} ) );

			}

			parser._invokeAll( function ( ext ) {

				return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

			} ).forEach( function ( promise ) {

				pending.push( promise );

			} );

			return Promise.all( pending );

		}() ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new three.Bone();

			} else if ( objects.length > 1 ) {

				node = new three.Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new three.Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new three.Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new three.Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );

		}

		return Promise.all( pending ).then( function () {

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof three.Material || key instanceof three.Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

}

function buildNodeHierarchy( nodeId, parentObject, json, parser ) {

	const nodeDef = json.nodes[ nodeId ];

	return parser.getDependency( 'node', nodeId ).then( function ( node ) {

		if ( nodeDef.skin === undefined ) return node;

		// build skeleton here as well

		let skinEntry;

		return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

			skinEntry = skin;

			const pendingJoints = [];

			for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

				pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

			}

			return Promise.all( pendingJoints );

		} ).then( function ( jointNodes ) {

			node.traverse( function ( mesh ) {

				if ( ! mesh.isMesh ) return;

				const bones = [];
				const boneInverses = [];

				for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

					const jointNode = jointNodes[ j ];

					if ( jointNode ) {

						bones.push( jointNode );

						const mat = new three.Matrix4();

						if ( skinEntry.inverseBindMatrices !== undefined ) {

							mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

						}

						boneInverses.push( mat );

					} else {

						console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

					}

				}

				mesh.bind( new three.Skeleton( bones, boneInverses ), mesh.matrixWorld );

			} );

			return node;

		} );

	} ).then( function ( node ) {

		// build node hierachy

		parentObject.add( node );

		const pending = [];

		if ( nodeDef.children ) {

			const children = nodeDef.children;

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				const child = children[ i ];
				pending.push( buildNodeHierarchy( child, node, json, parser ) );

			}

		}

		return Promise.all( pending );

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new three.Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new three.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new three.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new three.Vector3();
		const vector = new three.Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new three.Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	let index = geometry.getIndex();

	// generate index if not present

	if ( index === null ) {

		const indices = [];

		const position = geometry.getAttribute( 'position' );

		if ( position !== undefined ) {

			for ( let i = 0; i < position.count; i ++ ) {

				indices.push( i );

			}

			geometry.setIndex( indices );
			index = geometry.getIndex();

		} else {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
			return geometry;

		}

	}

	//

	const numberOfTriangles = index.count - 2;
	const newIndices = [];

	if ( drawMode === three.TriangleFanDrawMode ) {

		// gl.TRIANGLE_FAN

		for ( let i = 1; i <= numberOfTriangles; i ++ ) {

			newIndices.push( index.getX( 0 ) );
			newIndices.push( index.getX( i ) );
			newIndices.push( index.getX( i + 1 ) );

		}

	} else {

		// gl.TRIANGLE_STRIP

		for ( let i = 0; i < numberOfTriangles; i ++ ) {

			if ( i % 2 === 0 ) {

				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i + 2 ) );


			} else {

				newIndices.push( index.getX( i + 2 ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i ) );

			}

		}

	}

	if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

		console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

	}

	// build final geometry

	const newGeometry = geometry.clone();
	newGeometry.setIndex( newIndices );

	return newGeometry;

}/**
 * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles
 */
const Constants = {
  Handedness: Object.freeze({
    NONE: 'none',
    LEFT: 'left',
    RIGHT: 'right'
  }),
  ComponentState: Object.freeze({
    DEFAULT: 'default',
    TOUCHED: 'touched',
    PRESSED: 'pressed'
  }),
  ComponentProperty: Object.freeze({
    BUTTON: 'button',
    X_AXIS: 'xAxis',
    Y_AXIS: 'yAxis',
    STATE: 'state'
  }),
  ComponentType: Object.freeze({
    TRIGGER: 'trigger',
    SQUEEZE: 'squeeze',
    TOUCHPAD: 'touchpad',
    THUMBSTICK: 'thumbstick',
    BUTTON: 'button'
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: 'transform',
    VISIBILITY: 'visibility'
  })
};
/** @constant {Object} */

const defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};
/**
 * @description Static helper function to fetch a JSON file and turn it into a JS object
 * @param {string} path - Path to JSON file to be fetched
 */

async function fetchJsonFile(path) {
  const response = await fetch(path);

  if (!response.ok) {
    throw new Error(response.statusText);
  } else {
    return response.json();
  }
}

async function fetchProfilesList(basePath) {
  if (!basePath) {
    throw new Error('No basePath supplied');
  }

  const profileListFileName = 'profilesList.json';
  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
  return profilesList;
}
async function fetchProfile(xrInputSource, basePath, defaultProfile, getAssetPath) {
  if (defaultProfile === void 0) {
    defaultProfile = null;
  }

  if (getAssetPath === void 0) {
    getAssetPath = true;
  }

  if (!xrInputSource) {
    throw new Error('No xrInputSource supplied');
  }

  if (!basePath) {
    throw new Error('No basePath supplied');
  } // Get the list of profiles


  const supportedProfilesList = await fetchProfilesList(basePath); // Find the relative path to the first requested profile that is recognized

  let match;
  xrInputSource.profiles.some(profileId => {
    const supportedProfile = supportedProfilesList[profileId];

    if (supportedProfile) {
      match = {
        profileId,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }

    return !!match;
  });

  if (!match) {
    if (!defaultProfile) {
      throw new Error('No matching profile name found');
    }

    const supportedProfile = supportedProfilesList[defaultProfile];

    if (!supportedProfile) {
      throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
    }

    match = {
      profileId: defaultProfile,
      profilePath: `${basePath}/${supportedProfile.path}`,
      deprecated: !!supportedProfile.deprecated
    };
  }

  const profile = await fetchJsonFile(match.profilePath);
  let assetPath;

  if (getAssetPath) {
    let layout;

    if (xrInputSource.handedness === 'any') {
      layout = profile.layouts[Object.keys(profile.layouts)[0]];
    } else {
      layout = profile.layouts[xrInputSource.handedness];
    }

    if (!layout) {
      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);
    }

    if (layout.assetPath) {
      assetPath = match.profilePath.replace('profile.json', layout.assetPath);
    }
  }

  return {
    profile,
    assetPath
  };
}
/**
 * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad
 * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within
 * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical
 * range of motion and touchpads do not report touch locations off their physical bounds.
 * @param {number} x The original x coordinate in the range -1 to 1
 * @param {number} y The original y coordinate in the range -1 to 1
 */

function normalizeAxes(x, y) {
  if (x === void 0) {
    x = 0;
  }

  if (y === void 0) {
    y = 0;
  }

  let xAxis = x;
  let yAxis = y; // Determine if the point is outside the bounds of the circle
  // and, if so, place it on the edge of the circle

  const hypotenuse = Math.sqrt(x * x + y * y);

  if (hypotenuse > 1) {
    const theta = Math.atan2(y, x);
    xAxis = Math.cos(theta);
    yAxis = Math.sin(theta);
  } // Scale and move the circle so values are in the interpolation range.  The circle's origin moves
  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.


  const result = {
    normalizedXAxis: xAxis * 0.5 + 0.5,
    normalizedYAxis: yAxis * 0.5 + 0.5
  };
  return result;
}
/**
 * Contains the description of how the 3D model should visually respond to a specific user input.
 * This is accomplished by initializing the object with the name of a node in the 3D model and
 * property that need to be modified in response to user input, the name of the nodes representing
 * the allowable range of motion, and the name of the input which triggers the change. In response
 * to the named input changing, this object computes the appropriate weighting to use for
 * interpolating between the range of motion nodes.
 */


class VisualResponse {
  constructor(visualResponseDescription) {
    this.componentProperty = visualResponseDescription.componentProperty;
    this.states = visualResponseDescription.states;
    this.valueNodeName = visualResponseDescription.valueNodeName;
    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;

    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
      this.minNodeName = visualResponseDescription.minNodeName;
      this.maxNodeName = visualResponseDescription.maxNodeName;
    } // Initializes the response's current value based on default data


    this.value = 0;
    this.updateFromComponent(defaultComponentValues);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */


  updateFromComponent(_ref) {
    let {
      xAxis,
      yAxis,
      button,
      state
    } = _ref;
    const {
      normalizedXAxis,
      normalizedYAxis
    } = normalizeAxes(xAxis, yAxis);

    switch (this.componentProperty) {
      case Constants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
        break;

      case Constants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
        break;

      case Constants.ComponentProperty.BUTTON:
        this.value = this.states.includes(state) ? button : 0;
        break;

      case Constants.ComponentProperty.STATE:
        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          this.value = this.states.includes(state);
        } else {
          this.value = this.states.includes(state) ? 1.0 : 0.0;
        }

        break;

      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }

}

class Component {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(componentId, componentDescription) {
    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
      throw new Error('Invalid arguments supplied');
    }

    this.id = componentId;
    this.type = componentDescription.type;
    this.rootNodeName = componentDescription.rootNodeName;
    this.touchPointNodeName = componentDescription.touchPointNodeName; // Build all the visual responses for this component

    this.visualResponses = {};
    Object.keys(componentDescription.visualResponses).forEach(responseName => {
      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
      this.visualResponses[responseName] = visualResponse;
    }); // Set default values

    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
    this.values = {
      state: Constants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== undefined ? 0 : undefined,
      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,
      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined
    };
  }

  get data() {
    const data = _objectSpread2({
      id: this.id
    }, this.values);

    return data;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */


  updateFromGamepad(gamepad) {
    // Set the state to default before processing other data sources
    this.values.state = Constants.ComponentState.DEFAULT; // Get and normalize button

    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {
      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
      this.values.button = gamepadButton.value;
      this.values.button = this.values.button < 0 ? 0 : this.values.button;
      this.values.button = this.values.button > 1 ? 1 : this.values.button; // Set the state based on the button

      if (gamepadButton.pressed || this.values.button === 1) {
        this.values.state = Constants.ComponentState.PRESSED;
      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    } // Get and normalize x axis value


    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {
      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis; // If the state is still default, check if the xAxis makes it touched

      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    } // Get and normalize Y axis value


    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {
      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis; // If the state is still default, check if the yAxis makes it touched

      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    } // Update the visual response weights based on the current component data


    Object.values(this.visualResponses).forEach(visualResponse => {
      visualResponse.updateFromComponent(this.values);
    });
  }

}
/**
  * @description Builds a motion controller with components and visual responses based on the
  * supplied profile description. Data is polled from the xrInputSource's gamepad.
  * @author Nell Waliczek / https://github.com/NellWaliczek
*/


class MotionController {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(xrInputSource, profile, assetUrl) {
    if (!xrInputSource) {
      throw new Error('No xrInputSource supplied');
    }

    if (!profile) {
      throw new Error('No profile supplied');
    }

    this.xrInputSource = xrInputSource;
    this.assetUrl = assetUrl;
    this.id = profile.profileId; // Build child components as described in the profile description

    this.layoutDescription = profile.layouts[xrInputSource.handedness];
    this.components = {};
    Object.keys(this.layoutDescription.components).forEach(componentId => {
      const componentDescription = this.layoutDescription.components[componentId];
      this.components[componentId] = new Component(componentId, componentDescription);
    }); // Initialize components based on current gamepad state

    this.updateFromGamepad();
  }

  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }

  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */


  get data() {
    const data = [];
    Object.values(this.components).forEach(component => {
      data.push(component.data);
    });
    return data;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */


  updateFromGamepad() {
    Object.values(this.components).forEach(component => {
      component.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }

}// import * as THREE from 'three';
const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';
const DEFAULT_PROFILE = 'generic-trigger';

class XRControllerModel extends THREE.Object3D {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
  }

  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }

    this.envMap = envMap;
    this.traverse(child => {
      if (child.isMesh) {
        child.material.envMap = this.envMap;
        child.material.needsUpdate = true;
      }
    });
    return this;
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */


  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);

    if (!this.motionController) {
      return;
    } // Cause the MotionController to poll the Gamepad for data


    this.motionController.updateFromGamepad(); // Update the 3D model to reflect the button, thumbstick, and touchpad state

    Object.values(this.motionController.components).forEach(component => {
      // Update node data based on the visual responses' current states
      Object.values(component.visualResponses).forEach(visualResponse => {
        const {
          valueNode,
          minNode,
          maxNode,
          value,
          valueNodeProperty
        } = visualResponse; // Skip if the visual response node is not found. No error is needed,
        // because it will have been reported at load time.

        if (!valueNode) {
          return;
        } // Calculate the new properties based on the weight supplied


        if (valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          valueNode.visible = value;
        } else if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  }

}
/**
 * Walks the model's tree to find the nodes needed to animate the components and
 * saves them to the motionContoller components for use in the frame loop. When
 * touchpads are found, attaches a touch dot to them.
 */


function findNodes(motionController, scene) {
  // Loop through the components and find the nodes needed for each components' visual responses
  Object.values(motionController.components).forEach(component => {
    const {
      type,
      touchPointNodeName,
      visualResponses
    } = component;

    if (type === Constants.ComponentType.TOUCHPAD) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);

      if (component.touchPointNode) {
        // Attach a touch dot to the touchpad.
        const sphereGeometry = new THREE.SphereGeometry(0.001);
        const material = new THREE.MeshBasicMaterial({
          color: 0x0000FF
        });
        const sphere = new THREE.Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    } // Loop through all the visual responses to be applied to this component


    Object.values(visualResponses).forEach(visualResponse => {
      const {
        valueNodeName,
        minNodeName,
        maxNodeName,
        valueNodeProperty
      } = visualResponse; // If animating a transform, find the two nodes to be interpolated between.

      if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName); // If the extents cannot be found, skip this animation

        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }

        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      } // If the target node cannot be found, skip this animation


      visualResponse.valueNode = scene.getObjectByName(valueNodeName);

      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}

function addAssetSceneToControllerModel(controllerModel, scene) {
  // Find the nodes needed for animation and cache them on the motionController.
  findNodes(controllerModel.motionController, scene); // Apply any environment map that the mesh already has set.

  if (controllerModel.envMap) {
    scene.traverse(child => {
      if (child.isMesh) {
        child.material.envMap = controllerModel.envMap;
        child.material.needsUpdate = true;
      }
    });
  } // Add the glTF scene to the controllerModel.


  controllerModel.add(scene);
}

class XRControllerModelFactory {
  constructor(gltfLoader) {
    if (gltfLoader === void 0) {
      gltfLoader = null;
    }

    this.gltfLoader = gltfLoader;
    this.path = DEFAULT_PROFILES_PATH;
    this._assetCache = {}; // If a GLTFLoader wasn't supplied to the constructor create a new one.

    if (!this.gltfLoader) {
      this.gltfLoader = new GLTFLoader();
    }
  }

  createControllerModel(controller) {
    const controllerModel = new XRControllerModel();
    let scene = null;
    controller.addEventListener('connected', event => {
      const xrInputSource = event.data;

      if (xrInputSource.targetRayMode !== 'tracked-pointer' || !xrInputSource.gamepad) {
        return;
      }

      fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(_ref => {
        let {
          profile,
          assetPath
        } = _ref;
        controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);
        const cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];

        if (cachedAsset) {
          scene = cachedAsset.scene.clone();
          addAssetSceneToControllerModel(controllerModel, scene);
        } else {
          if (!this.gltfLoader) {
            throw new Error('GLTFLoader not set.');
          }

          this.gltfLoader.setPath('');
          this.gltfLoader.load(controllerModel.motionController.assetUrl, asset => {
            this._assetCache[controllerModel.motionController.assetUrl] = asset;
            scene = asset.scene.clone();
            addAssetSceneToControllerModel(controllerModel, scene);
          }, null, () => {
            throw new Error(`Asset ${controllerModel.motionController.assetUrl} missing or malformed.`);
          });
        }
      }).catch(err => {
        console.warn(err);
      });
    });
    controller.addEventListener('disconnected', () => {
      controllerModel.motionController = null;
      controllerModel.remove(scene);
      scene = null;
    });
    return controllerModel;
  }

}const ZERO = new THREE.Vector3();
const DOWN = new THREE.Vector3(0, -1, 0);
const CONTROL_INFO = {
  type: MessageType.ControlInfo,
  orientation: {
    latitude: 0,
    longitude: 0
  },
  zoom: 1,
  cameraGroup: {
    position: [0, 0, 0],
    rotation: [0, 0, 0]
  },
  pointer: [0, 0, 0]
};
class WorldComponent extends rxcomp.Component {
  get error() {
    return this.error_;
  }

  set error(error) {
    if (this.error_ !== error) {
      this.error_ = error;
      this.pushChanges();
    }
  }

  get view() {
    return this.view_;
  }

  set view(view) {
    if (this.view_ !== view) {
      this.view_ = view;
      this.setView();
    }
  }

  get debugging() {
    // return STATIC || DEBUG;
    return DEBUG;
  }

  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }

  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }

  get silencing() {
    return StateService.state.silencing;
  }

  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }

  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }

  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }

  get locked() {
    return this.controlled || this.spying;
  }

  get lockedOrXR() {
    return this.locked || this.renderer.xr.isPresenting;
  }

  get showMenu() {
    return StateService.state.hosted && StateService.state.navigable && (StateService.state.mode !== 'embed' || environment.flags.menuEmbed);
  }

  get showPointer() {
    return this.pointer.mesh.parent != null;
  }

  set showPointer(showPointer) {
    if (this.showPointer !== showPointer) {
      showPointer ? this.scene.add(this.pointer.mesh) : this.scene.remove(this.pointer.mesh); // console.log('showPointer', showPointer);
    }
  }

  set menu(menu) {
    if (this.menu_ !== menu) {
      this.menu_ = menu;
      this.scene.traverse(object => {
        if (object instanceof MediaMesh || object instanceof MediaPlayMesh) {
          object.freezed = menu != null;
        }
      });
    }
  }

  get menu() {
    return this.menu_;
  }

  onInit() {
    // console.log('WorldComponent.onInit');
    Host.host = this;
    this.defaultTexture = Texture.gridTexture;
    this.index = 0;
    this.error_ = null;
    this.loading = null;
    this.waiting = null;
    this.avatars = {};
    this.createScene(); // this.setView();

    this.addListeners();
    this.animate(); // !!!

    KeyboardService.keys$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(keys => {
      this.keys = keys; // console.log(keys);
    });
    LanguageService.lang$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(_ => {
      this.setView();
    });
  }
  /*
  onChanges() {
  	if (this.view) {
  		const selected = this.view.items.find(item => item.selected);
  		if (selected && selected.mesh) {
  			if (this.view.type.name !== 'model') {
  				this.orbitService.lookAt(selected.mesh);
  			}
  		}
  	}
  }
  */


  onDestroy() {
    this.removeListeners();
    const renderer = this.renderer;
    renderer.setAnimationLoop(() => {});
  }

  createScene() {
    const {
      node
    } = rxcomp.getContext(this);
    this.size = {
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      aspect: 0
    };
    this.mouse = new THREE.Vector2();
    this.controllerMatrix_ = new THREE.Matrix4();
    this.controllerWorldPosition_ = new THREE.Vector3();
    this.controllerWorldDirection_ = new THREE.Vector3();
    const container = this.container = node;
    this.info = node.querySelector('.world__info');
    this.worldRect = Rect.fromNode(container);
    this.cameraRect = new Rect();
    const cameraGroup = this.cameraGroup = new THREE.Group(); // new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, ROOM_RADIUS * 2);
    // const camera = this.camera = new THREE.PerspectiveCamera(70, container.offsetWidth / container.offsetHeight, 0.01, 1000);

    const camera = this.camera = new THREE.PerspectiveCamera(70, container.offsetWidth / container.offsetHeight, 0.01, 1000);
    camera.target = new THREE.Vector3();
    cameraGroup.add(camera); // cameraGroup.target = new THREE.Vector3();

    this.orbitService = new OrbitService(camera);
    const renderer = this.renderer = new THREE.WebGLRenderer({
      antialias: environment.flags.antialias || false,
      alpha: environment.flags.alpha || false,
      premultipliedAlpha: environment.flags.premultipliedAlpha || false,
      logarithmicDepthBuffer: true,
      // physicallyCorrectLights: true,
      powerPreference: 'high-performance'
    });
    renderer.setClearColor(0x000000, 1);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.xr.enabled = true;
    renderer.outputEncoding = THREE.LinearEncoding; // renderer.toneMapping = THREE.NoToneMapping;

    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = environment.toneMappingExposure || 1; // 2;

    if (container.childElementCount > 0) {
      container.insertBefore(renderer.domElement, container.children[0]);
    } else {
      container.appendChild(renderer.domElement);
    }

    const raycaster = this.raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(this.mouse, camera);
    const scene = this.scene = new THREE.Scene();
    scene.add(cameraGroup);

    if (environment.flags.useTextureEnvironment) {
      this.addEnvironment();
    }

    const objects = this.objects = new THREE.Group();
    objects.name = '[objects]';
    scene.add(objects);
    const panorama = this.panorama = new Panorama(renderer);
    this.panoramaIntersectObjects = [panorama.mesh];
    this.intersectObjects = this.panoramaIntersectObjects;
    objects.add(panorama.mesh);
    this.indicator = new PointerElement();
    this.pointer = new PointerElement('#ff4332');
    const light1 = new THREE.PointLight(0xffffff, 0.8);
    light1.position.set(-50, 0, 0);
    objects.add(light1);
    const light2 = new THREE.PointLight(0xffffff, 0.3);
    light2.position.set(50, 0, 0);
    objects.add(light2);
    const light3 = new THREE.PointLight(0xffffff, 0.5);
    light3.position.set(0, 50, 0);
    objects.add(light3);
    const light4 = new THREE.PointLight(0xffffff, 0.1);
    light4.position.set(0, -50, 0);
    objects.add(light4);
    const ambient = this.ambient = new THREE.AmbientLight(0xffffff, 0.25);
    objects.add(ambient);
    /*
    const direct = this.direct = new THREE.DirectionalLight(0xffffff, 1);
    direct.position.set(-40, -40, -40);
    direct.target.position.set(0, 0, 0);
    objects.add(direct);
    */

    this.addControllers();
    this.resize(); // show hide items

    LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
      const complete = progress.count === 0;
      const view = this.view_; // this.panorama.mesh.visible = complete;

      if (view.items) {
        view.items.forEach(item => {
          item.visible = complete;
        });
      } // console.log(view, complete, progress);

    }); // console.log('WorldComponent.createScene', this);
  }

  toggleLights(enabled) {
    if (this.ambient) {
      this.ambient.visible = enabled;
    }

    if (this.direct) {
      this.direct.visible = enabled;
    }
  }

  addEnvironment() {
    const segments = environment.textures.envMap.split('/');
    const filename = segments.pop();
    const folder = segments.join('/') + '/';
    const isHdr = filename.indexOf('.hdr') !== -1; // const loader = isHdr ? new RGBELoader().setDataType(THREE.UnsignedByteType) : new THREE.TextureLoader();

    let loader;

    if (isHdr) {
      loader = new RGBELoader();
      loader.setDataType(THREE.HalfFloatType);
    } else {
      loader = new THREE.TextureLoader();
    }

    loader.setPath(environment.getPath(folder)).load(filename, texture => {
      if (isHdr && texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        this.scene.background = texture;
        this.scene.environment = texture;
      } else {
        this.setBackground(texture);
      }
    });
  }

  addOffCanvasScene(message) {
    const avatar = new AvatarElement(message);
    this.avatars[message.clientId] = avatar; // avatar.container.appendChild(avatar.element);
  }

  removeOffCanvasScene(message) {
    this.avatars[message.clientId];
    /*
    if (avatar && avatar.element.parentNode) {
    	avatar.element.parentNode.removeChild(avatar.element);
    }
    */

    delete this.avatars[message.clientId];
  }

  updateOffCanvasScene(message) {
    const avatar = this.avatars[message.clientId];

    if (avatar) {
      avatar.update(message);
    }
  }

  setBackground(texture) {
    let background = texture || this.defaultTexture;
    background.mapping = THREE.EquirectangularReflectionMapping; // background.encoding = THREE.LinearEncoding;

    background.encoding = THREE.sRGBEncoding; // background.encoding = THREE.GammaEncoding;
    // background.encoding = THREE.RGBEEncoding;
    // background.encoding = THREE.LogLuvEncoding;
    // background.encoding = THREE.RGBM7Encoding;
    // background.encoding = THREE.RGBM16Encoding;
    // background.encoding = THREE.RGBDEncoding;
    // background.encoding = THREE.BasicDepthPacking;
    // background.encoding = THREE.RGBADepthPacking;
    // this.scene.background = background;

    this.scene.environment = background;
  }

  setView() {
    if (!this.renderer) {
      return;
    }

    if (!this.panorama) {
      return;
    }

    const view = this.view_;

    if (view) {
      if (StateService.state.zoomedId != null) {
        StateService.patchState({
          zoomedId: null
        });
      }

      if (this.views) {
        this.views.forEach(view => delete view.onUpdateAsset);
      }

      const message = this.requestInfoResult;

      if (message) {
        if (view instanceof PanoramaGridView && message.gridIndex !== undefined) {
          view.index_ = message.gridIndex;
        }
      }

      view.ready = false;
      this.cameraGroup.position.set(0, 0, 0);
      this.cameraGroup.rotation.set(0, 0, 0);

      if (view.type.name === ViewType.Room3d.name) {
        this.renderer.setClearColor(0x000000, 1);
        this.objects.remove(this.panorama.mesh);
        this.toggleLights(false);
      } else {
        this.renderer.setClearColor(0x000000, 1);
        this.objects.add(this.panorama.mesh);
        this.toggleLights(true);
      } // this.waiting = null;


      this.pushChanges();
      PrefetchService.cancel();
      this.panorama.change(view, this.renderer, texture => {
        // console.log('panorama.change', texture);
        if (!environment.flags.useTextureEnvironment) {
          this.setBackground(texture);
        }

        view.ready = true;

        view.onUpdateAsset = () => {
          this.onViewAssetDidChange();
        };

        const context = rxcomp.getContext(this); // console.log('WorldCompoent.setView.context', context);

        if (context) {
          this.pushChanges();
        }
      }, view => {
        this.setViewOrientation(view);
        PrefetchService.prefetch(view.prefetchAssets); // this.loading = null;
        // this.pushChanges();
      });
    }
  }

  onViewAssetDidChange() {
    if (this.panorama) {
      this.panorama.crossfade(this.view, this.renderer, texture => {
        if (!environment.flags.useTextureEnvironment) {
          this.setBackground(texture);
        }
      });
    }
  }

  setViewOrientation(view) {
    const message = this.requestInfoResult;
    this.requestInfoResult = null;

    if (this.orbitService) {
      this.orbitService.mode = view.type.name;

      if (!this.renderer.xr.isPresenting) {
        let orientation;

        if (message) {
          orientation = message.orientation;
          this.orbitService.setOrientation(orientation);
          this.orbitService.zoom = message.zoom;
          this.camera.updateProjectionMatrix();
        } else if (!view.keepOrientation) {
          // console.log('WorldComponent.setViewOrientation', view.useLastOrientation, view.lastOrientation);
          orientation = view.useLastOrientation ? view.lastOrientation : view.orientation;
          this.orbitService.setOrientation(orientation);
          this.orbitService.zoom = view.zoom;
          this.camera.updateProjectionMatrix();
        }
      }
    }
  }

  addControllers() {
    const controllerGroup = this.controllerGroup = new THREE.Group();
    this.teleport = new TeleportElement();
    this.controllers = [];
    this.controllerModelFactory = new XRControllerModelFactory();
    this.addController(0);
    this.addController(1);
    this.cameraGroup.add(controllerGroup);
  }

  addController(index) {
    const showPhone = StateService.state.live;
    const renderer = this.renderer;
    const controllerGroup = this.controllerGroup;
    const controller = renderer.xr.getController(index);
    const controllerModelFactory = this.controllerModelFactory;
    const teleport = this.teleport;
    const scene = this.scene;
    const camera = this.camera;
    const cameraGroup = this.cameraGroup;
    controller.name = `[controller${index + 1}]`;
    controllerGroup.add(controller);

    const setController = controller => {
      // console.log('setController', this);
      this.controller = controller;
    };

    const onSelectStart = event => {
      controller.userData.isSelecting = true;
      setController(controller);
    };

    const onSelectEnd = event => {
      controller.userData.isSelecting = false;
    };

    const onSqueezeStart = event => {
      if (this.view && this.view.type.name === ViewType.Room3d.name) {
        teleport.addToController(controller, scene); // this.scene.remove(this.indicator.mesh);

        this.indicator.mesh.visible = false;
        controller.children[0].visible = false;
      }
    };

    const onSqueezeEnd = event => {
      // if (this.view && this.view.type.name === ViewType.Room3d.name) {
      teleport.removeFromController(controller, scene, renderer, camera, cameraGroup); // this.scene.add(this.indicator.mesh);

      this.indicator.mesh.visible = true;
      controller.children[0].visible = true; // }
    }; // const debugService = DebugService.getService();
    // debugService.setMessage('DebugService 1001');


    const onPress = event => {
      // console.log('Gamepad.onPress', event, controller);
      // debugService.setMessage('Gamepad.onPress ' + event.index);
      // 0: select
      // 1: squeeze
      // 4: x / a
      // 5: y / b
      switch (event.index) {
        case 0:
          // select
          break;

        case 1:
          // squeeze
          break;

        case 4:
          // x / a
          MessageService.send({
            type: MessageType.MenuToggle
          });
          break;
      }
    };

    const onRelease = event => {
      this.onModelUp();
    };

    const onLeft = event => {
      // console.log('Gamepad.onLeft', event, controller);
      // debugService.setMessage('Gamepad.onLeft');
      this.cameraGroup.rotation.y += Math.PI / 180 * 45;
    };

    const onRight = event => {
      // console.log('Gamepad.onRight', event, controller);
      // debugService.setMessage('Gamepad.onRight');
      this.cameraGroup.rotation.y -= Math.PI / 180 * 45;
    };
    /*
    const onAxis = (event) => {
    	// console.log('Gamepad.onAxis', event, controller);
    	// debugService.setMessage('Gamepad.onAxis');
    	this.cameraGroup.rotation.y += (Math.PI / 180 * event.x);
    };
    */


    const onAxis = event => {
      // console.log('Gamepad.onAxis', event, controller);
      // debugService.setMessage('Gamepad.onAxis');
      this.onModelDistance(event.y);
    };
    /*
    const onUp = (event) => {
    	// console.log('Gamepad.onUp', event, controller);
    	// debugService.setMessage('Gamepad.onUp');
    	this.cameraGroup.position.y += 1;
    };
    const onDown = (event) => {
    	// console.log('Gamepad.onDown', event, controller);
    	// debugService.setMessage('Gamepad.onDown');
    	this.cameraGroup.position.y -= 1;
    };
    */

    /*
    const onUp = (event) => {
    	this.onModelDistance(1);
    };
    const onDown = (event) => {
    	this.onModelDistance(-1);
    };
    */


    const onConnected = event => {
      controller.add(this.buildController(event.data));

      if (showPhone && event.data.handedness === 'left') {
        const phone = this.phone = new PhoneElement();
        controller.add(phone.mesh);
      }

      if (!showPhone || event.data.handedness === 'right') {
        const controllerGrip = renderer.xr.getControllerGrip(index);
        controllerGrip.name = `[controller-grip${index + 1}]`;
        const controllerModel = controllerModelFactory.createControllerModel(controllerGrip);
        controller.userData.model = controllerModel;
        controllerGrip.add(controllerModel);
        controllerGroup.add(controllerGrip);
      }

      const gamepad = new Gamepad(event.data.gamepad);
      gamepad.on('press', onPress);
      gamepad.on('release', onRelease);
      gamepad.on('left', onLeft);
      gamepad.on('right', onRight);
      gamepad.on('axis', onAxis); // gamepad.on('up', onUp);
      // gamepad.on('down', onDown);

      controller.userData.gamepad = gamepad;

      controller.userData.update = () => {
        gamepad.update();
      };
    };

    const onDisconnected = event => {
      while (controller.children.length) {
        controller.remove(controller.children[0]);
      }

      const controllerGrip = renderer.xr.getControllerGrip(index);

      while (controllerGrip.children.length) {
        controllerGrip.remove(controllerGrip.children[0]);
      }

      controllerGroup.remove(controllerGrip);

      controller.userData.update = () => {};

      const gamepad = controller.userData.gamepad;

      if (gamepad) {
        gamepad.off('press', onPress);
        gamepad.off('release', onRelease);
        gamepad.off('left', onLeft);
        gamepad.off('right', onRight);
        gamepad.off('axis', onAxis); // gamepad.off('up', onUp);
        // gamepad.off('down', onDown);

        delete controller.userData.gamepad;
      }

      teleport.removeFromController(controller, scene, renderer, camera, cameraGroup);
    };

    controller.userData.update = () => {};

    controller.addEventListener('selectstart', onSelectStart);
    controller.addEventListener('selectend', onSelectEnd);
    controller.addEventListener('connected', onConnected);
    controller.addEventListener('disconnected', onDisconnected);
    controller.addEventListener('squeezestart', onSqueezeStart);
    controller.addEventListener('squeezeend', onSqueezeEnd);
    const controllers = this.controllers;
    controllers.push(controller);
  }

  buildController(data) {
    // console.log('buildController', data);
    let geometry, material;

    switch (data.targetRayMode) {
      case 'tracked-pointer':
        geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));
        material = new THREE.LineBasicMaterial({
          vertexColors: true,
          blending: THREE.AdditiveBlending
        });
        return new THREE.Line(geometry, material);

      case 'gaze':
        geometry = new THREE.RingBufferGeometry(0.02, 0.04, 32).translate(0, 0, -1);
        material = new THREE.MeshBasicMaterial({
          opacity: 0.5,
          transparent: true
        });
        return new THREE.Mesh(geometry, material);
    }
  }

  updateRaycasterXR(controller, raycaster) {
    if (controller) {
      this.controllerMatrix_.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.controllerMatrix_); // raycaster.camera = this.host.renderer.xr.getCamera(this.camera);

      return raycaster;
    }
  }

  repos(object, rect) {
    const worldRect = this.worldRect;
    const sx = 0.8; // const sx = rect.width / worldRect.width;
    // const sy = rect.height / worldRect.height;

    object.scale.set(sx, sx, sx); // const tx = ((rect.x + rect.width / 2) - worldRect.width / 2) / worldRect.width * 2.0 * this.camera.aspect; // * cameraRect.width / worldRect.width - cameraRect.width / 2;
    // const ty = ((rect.y + rect.height / 2) - worldRect.height / 2) / worldRect.height * 2.0 * this.camera.aspect; // * cameraRect.height / worldRect.height - cameraRect.height / 2;

    const tx = (rect.x + rect.width / 2 - worldRect.width / 2) / worldRect.width * 2.0 * this.camera.aspect;
    const ty = (rect.y + rect.height / 2 - worldRect.height / 2) / worldRect.height * 2.0 * this.camera.aspect; // console.log(tx);
    // const position = new THREE.Vector3(tx, ty, 0).unproject(this.camera);

    object.position.set(tx, -ty, 0); // console.log(tx, -ty, 0);
  }

  render(delta) {
    try {
      const renderer = this.renderer,
            scene = this.scene,
            camera = this.camera,
            avatars = this.avatars;
      const isPresenting = renderer.xr.isPresenting;

      if (!isPresenting && StateService.state.mode === UIMode.LiveMeeting) {
        // !!! || (StateService.state.remoteScreen !== null)
        return;
      }

      if (isPresenting) {
        gsap.ticker.tick();
        this.controllers.forEach(controller => controller.userData.update());
        this.teleport.update();
      } else {
        this.navWithKeys();
      }

      this.orbitService.render();
      const time = performance.now();
      const tick = this.tick_ ? ++this.tick_ : this.tick_ = 1;
      scene.traverse(child => {
        const render = child.userData.render;

        if (typeof render === 'function') {
          render(time, tick, renderer, scene, camera);
        }
      });
      Object.keys(avatars).forEach(key => {
        avatars[key].render();
      });
      this.vrService.updateState(this);
      this.raycasterXRHitTest();
      renderer.render(scene, camera);
    } catch (error) {
      this.error = error; // throw (error);
    }
  }

  navWithKeys() {
    if (this.view && this.view.type.name === ViewType.Room3d.name && this.view.mesh && !this.locked && !ModalService.hasModal) {
      this.intersectObjects = this.view.intersectObjects;
      const velocity = this.velocity || (this.velocity = new THREE.Vector3());
      const direction = this.direction || (this.direction = new THREE.Vector3());
      const camera = this.camera;
      const speed = 0.1;

      if (this.keys.w || this.keys.ArrowUp) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(speed);
        velocity.copy(direction);
      } else if (this.keys.s || this.keys.ArrowDown) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(-speed);
        velocity.copy(direction);
      } else if (this.keys.d || this.keys.ArrowRight) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(speed);
        const axisY = this.axisY || (this.direction = new THREE.Vector3(0, 1, 0));
        const angle = -Math.PI / 2;
        direction.applyAxisAngle(axisY, angle);
        velocity.copy(direction);
      } else if (this.keys.a || this.keys.ArrowLeft) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(-speed);
        const axisY = this.axisY || (this.direction = new THREE.Vector3(0, 1, 0));
        const angle = -Math.PI / 2;
        direction.applyAxisAngle(axisY, angle);
        velocity.copy(direction);
      }

      const manhattanLength = velocity.manhattanLength();

      if (manhattanLength > 0.00001) {
        // console.log(velocity.x, velocity.y, velocity.z);
        direction.copy(this.cameraGroup.position);
        direction.add(velocity);
        direction.y = 0;
        const raycaster = this.raycaster;
        raycaster.set(direction, DOWN);
        const intersects = raycaster.intersectObjects(this.view.navIntersectObjects);

        if (intersects.length) {
          // console.log(manhattanLength, intersects);
          this.cameraGroup.position.add(velocity);
          this.cameraGroup.position.y = 0;
          this.orbitService.markAsDirty(); // this.orbitService.events$.next(OrbitService.orbitMoveEvent);
          // camera.updateProjectionMatrix();
        }

        velocity.lerp(ZERO, 0.1);
      } else {
        velocity.set(0, 0, 0);
      }
    } else {
      this.intersectObjects = this.panoramaIntersectObjects;
    }
  }

  animate() {
    const renderer = this.renderer;
    renderer.setAnimationLoop(this.render);
  }

  resize() {
    try {
      const container = this.container,
            renderer = this.renderer,
            camera = this.camera;
      const size = this.size;
      const rect = container.getBoundingClientRect();
      size.left = Math.floor(rect.left);
      size.top = Math.floor(rect.top);
      size.width = Math.ceil(rect.width);
      size.height = Math.ceil(rect.height);
      size.aspect = size.width / size.height;
      const worldRect = this.worldRect;
      worldRect.setSize(size.width, size.height);

      if (!renderer.xr.isPresenting) {
        renderer.setSize(size.width, size.height);

        if (camera) {
          camera.aspect = size.width / size.height;
          const angle = camera.fov * Math.PI / 180;
          const height = Math.abs(camera.position.z * Math.tan(angle / 2) * 2);
          const cameraRect = this.cameraRect;
          cameraRect.width = height * camera.aspect;
          cameraRect.height = height; // console.log('position', camera.position.z, 'angle', angle, 'height', height, 'aspect', camera.aspect, cameraRect);

          camera.updateProjectionMatrix();
        }
      } // this.render();

    } catch (error) {
      this.error = error; // throw (error);
    }
  }

  updateRaycasterMouse(event) {
    const w2 = this.size.width / 2;
    const h2 = this.size.height / 2;
    this.mouse.x = (event.clientX - this.size.left - w2) / w2;
    this.mouse.y = -(event.clientY - this.size.top - h2) / h2;
    const raycaster = this.raycaster;
    raycaster.setFromCamera(this.mouse, this.camera);
    return raycaster;
  }

  raycasterXRHitTest() {
    if (this.renderer.xr.isPresenting && !this.locked) {
      const raycaster = this.updateRaycasterXR(this.controller, this.raycaster);

      if (raycaster) {
        Interactive.hittest(raycaster, this.controller.userData.isSelecting);
        this.indicator.update(this.renderer.xr.getCamera(this.camera));
        /*
        if (hit && hit !== this.panorama.mesh) {
        	// controllers.feedback();
        }
        */
      }
    }
  }

  raycasterDesktopHitTest(event) {
    const raycaster = this.updateRaycasterMouse(event);

    if (this.lockedOrXR) {
      return;
    }

    if (this.dragItem) {
      if (typeof this.dragItem.onDragMove === 'function') {
        const intersections = raycaster.intersectObjects(this.intersectObjects);

        if (intersections.length) {
          const intersection = intersections[0]; // this.panorama.mesh.intersection = intersection;

          const intersectionPoint = this.intersectionPoint || (this.intersectionPoint = new THREE.Vector3());
          const intersectionNormal = this.intersectionNormal || (this.intersectionNormal = new THREE.Vector3());
          const position = intersectionPoint.copy(intersection.point);
          const normal = intersectionNormal.copy(intersection.face.normal);
          this.dragItem.onDragMove(position, normal, this.intersectObjects === this.panoramaIntersectObjects);
        }
      }
    } else if (this.resizeItem) ; else {
      Interactive.hittest(raycaster);
      this.controlEvent$.next(CONTROL_INFO);
    }
  }

  onMouseDown(event) {
    try {
      if (this.locked) {
        return;
      }

      if (event.button !== 0) {
        return;
      }

      const raycaster = this.updateRaycasterMouse(event);
      const hit = Interactive.hittest(raycaster, true);

      if (this.editor || DEBUG) {
        if (this.keys.Shift || this.keys.Control) {} else {
          this.select.next({
            item: null
          });
          const intersections = raycaster.intersectObjects(this.intersectObjects);

          if (intersections.length) {
            const intersection = intersections[0];
            const intersectionPoint = this.intersectionPoint || (this.intersectionPoint = new THREE.Vector3());
            const intersectionNormal = this.intersectionNormal || (this.intersectionNormal = new THREE.Vector3());
            const position = intersectionPoint.copy(intersection.point);
            const normal = intersectionNormal.copy(intersection.face.normal);
            this.viewHit.next({
              position,
              normal,
              spherical: this.intersectObjects === this.panoramaIntersectObjects
            });
          }
          /*
          if (this.panorama.mesh.intersection) {
          	const position = new THREE.Vector3().copy(this.panorama.mesh.intersection.point).normalize();
          	// console.log(JSON.stringify({ position: position.toArray() }));
          	this.viewHit.next(position);
          }
          */

        }
      } else if (this.isTouchDevice() && hit && hit.name === '[panorama]') {
        const item = this.view.items.find(item => item.showPanel);

        if (item) {
          item.showPanel = false;
          this.pushChanges(); // console.log(item, hit, this.view.items);
        }
      }
    } catch (error) {
      this.error = error; // throw (error);
    }
  }

  onMouseMove(event) {
    try {
      this.raycasterDesktopHitTest(event);
    } catch (error) {
      this.error = error; // throw (error);
    }
  }

  onMouseUp(event) {
    try {
      if (this.lockedOrXR) {
        return;
      }

      if (this.dragItem) {
        if (typeof this.dragItem.onDragEnd === 'function') {
          this.dragItem.onDragEnd();
          this.dragEnd.next(this.dragItem);
        }
      }

      this.dragItem = null;

      if (this.resizeItem) {
        if (typeof this.resizeItem.onResizeEnd === 'function') {
          this.resizeItem.onResizeEnd();
          this.resizeEnd.next(this.resizeItem);
        }
      }

      this.resizeItem = null;
      const raycaster = this.updateRaycasterMouse(event);
      const hit = Interactive.hittest(raycaster, false);
      this.checkSelectedItem();
    } catch (error) {
      this.error = error; // throw (error);
    }
  }

  onMouseWheel(event) {
    try {
      if (this.lockedOrXR) {
        return;
      }

      const deltaY = event.deltaY * (event.wheelDeltaY !== undefined ? 1 : 37);
      const orbitService = this.orbitService;
      gsap.to(orbitService, {
        duration: 0.5,
        zoom: orbitService.zoom + deltaY * 0.1,
        ease: Power4.easeOut,
        overwrite: true
      });
    } catch (error) {
      this.error = error; // throw (error);
    }
  }

  onOrientationDidChange() {
    this.controlEvent$.next(CONTROL_INFO);
  }

  checkSelectedItem() {
    if (this.view) {
      const selected = this.view.items.find(item => item.selected);

      if (selected && selected.mesh) {
        if (this.view.type.name !== 'model') {
          this.orbitService.lookAt(selected.mesh);
        }
      }
    }
  }

  onVRStarted() {
    // this.objects.rotation.y = - Math.PI / 2;
    this.objects.position.y = 1.3;
    this.scene.add(this.indicator.mesh);
    MessageService.send({
      type: MessageType.VRStarted
    });
  }

  onVREnded() {
    // this.objects.rotation.y = 0;
    this.objects.position.y = 0;
    this.cameraGroup.rotation.y = 0;
    this.cameraGroup.position.y = 0;
    this.scene.remove(this.indicator.mesh);
    this.orbitService.markAsDirty();
    MessageService.send({
      type: MessageType.VREnded
    });
  }

  onVRStateDidChange(state) {
    MessageService.send({
      type: MessageType.VRState,
      camera: state.camera.array
    });
  }

  onMenuNav(event) {
    // console.log('WorldComponent.onMenuNav', event.id, event);
    this.menu = undefined;
    this.navTo.next({
      viewId: event.id
    });
  }

  onMenuToggle(event) {
    // console.log('WorldComponent.onMenuToggle', event.id, event);
    if (this.locked) {
      return;
    }

    this.menu = event;
    this.view.items.forEach(item => item.showPanel = false);
    this.pushChanges();
  }

  onNavOver(nav) {
    if (this.menu) {
      return; // this.menu.removeMenu();
    }

    this.view.items.forEach(item => item.showPanel = false);

    if (nav.item.to) {
      clearTimeout(nav.item.to);
    }

    nav.item.showPanel = nav.shouldShowPanel(); // console.log('WorldComponent.onNavOver', nav, nav.item.showPanel);

    this.pushChanges();
    MessageService.send({
      type: MessageType.ShowPanel,
      itemId: nav.item.showPanel ? nav.item.id : null
    });
  }

  onNavOut(nav) {
    // console.log('WorldComponent.onNavOut', nav);
    if (this.isTouchDevice()) {
      return;
    } // nav.item.showPanel = false;


    nav.item.to = setTimeout(() => {
      nav.item.showPanel = false;
      this.pushChanges();
    }, 6000);
    this.pushChanges();
  }

  onNavDown(event) {
    if (!this.isTouchDevice()) {
      event.item.showPanel = false;
    } // console.log('WorldComponent.onNavDown', this.keys);


    if (this.locked) {
      return;
    }

    if (this.editor && this.keys.Shift) {
      this.dragItem = event;
      this.select.next(event);
    } else if (this.editor && this.keys.Control) {
      this.resizeItem = event;
      this.select.next(event);
    } else {
      this.navTo.next(event.item);
    }
  }

  onNavLink(event) {
    // console.log('WorldComponent.onNavLink', event.link.href);
    if (this.locked || this.editor) {
      return;
    }

    if (environment.flags.useIframe) {
      MessageService.send({
        type: MessageType.NavLink,
        itemId: event.item.id,
        linkIndex: event.linkIndex
      });
      this.navLink.next(event);
    } else {
      window.open(event.link.href, '_blank');
    }
  }

  isTouchDevice() {
    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  }

  onModelDown(event) {
    if (this.editor) {
      return this.onObjectDown(event);
    } // vr controller model grab


    const controller = this.controller;

    if (controller && this.renderer.xr.isPresenting) {
      const target = this.tempTarget = event.mesh; // console.log('WorldComponent.onModelDown', target);
      // DebugService.getService().setMessage('onModelDown ', target.name);

      this.tempParent = target.parent;
      const position = new THREE.Vector3();
      target.localToWorld(position);
      controller.worldToLocal(position);
      controller.add(target);
      target.position.copy(position);
    }
  }

  onModelDistance(direction) {
    // vr controller model distance
    const controller = this.controller;
    const target = this.tempTarget;

    if (controller && target && this.renderer.xr.isPresenting) {
      let position = new THREE.Vector3();
      position = position.copy(target.position);
      const distance = Math.max(1, Math.min(8, position.distanceTo(ZERO) + 0.02 * direction));
      position.normalize();
      position = position.multiplyScalar(distance); // DebugService.getService().setMessage('onModelDistance ' + distance);

      target.position.copy(position);
    }
  }

  onModelUp() {
    // vr controller model release
    const target = this.tempTarget;
    const parent = this.tempParent;

    if (target && parent) {
      // console.log('WorldComponent.onModelUp', target, parent);
      const position = new THREE.Vector3();
      target.localToWorld(position);
      parent.worldToLocal(position);
      parent.add(target);
      target.position.copy(position);
      this.tempTarget = null;
      this.tempParent = null;
    }
  }

  onObjectDown(event) {
    // console.log('WorldComponent.onObjectDown', this.keys);
    if (this.lockedOrXR) {
      return;
    }

    if (this.editor && this.keys.Shift) {
      this.dragItem = event;
      this.select.next(event);
    } else if (this.editor && this.keys.Control) {
      this.resizeItem = event;
      this.select.next(event);
    }
  }

  onPanelDown(event) {
    // console.log('WorldComponent.onPanelDown', event.link.href);
    if (this.locked) {
      return;
    }

    if (environment.flags.useIframe) {
      MessageService.send({
        type: MessageType.NavLink,
        itemId: event.item.id,
        linkIndex: event.linkIndex
      });
      this.navLink.next(event);
    } else {
      window.open(event.link.href, '_blank');
      /*
      const href = event.getAttribute('href');
      const target = event.getAttribute('target') || '_self';
      if (href) {
      	window.open(href, '_blank');
      }
      */
    }
  }

  onPlayMedia(event) {
    if (this.editor) {
      return;
    }

    MessageService.send({
      type: MessageType.PlayMedia,
      itemId: event.itemId,
      playing: event.playing
    });
  }

  onZoomMedia(event) {
    if (event.zoomed) {
      this.view.items.forEach(item => {
        if (item.mesh instanceof MediaMesh) {
          // console.log(item.id, event.itemId, item.id !== event.itemId);
          if (item.id !== event.itemId) {
            item.mesh.setZoomedState(false);
          }
        }
      });
    }

    this.view.items.forEach(item => item.showPanel = false);
    StateService.patchState({
      zoomedId: event.zoomed ? event.itemId : null
    });
    MessageService.send({
      type: MessageType.ZoomMedia,
      itemId: event.itemId,
      zoomed: event.zoomed
    });
  }

  onCurrentTimeMedia(event) {
    if (this.editor) {
      return;
    }

    MessageService.send({
      type: MessageType.CurrentTimeMedia,
      itemId: event.itemId,
      currentTime: event.currentTime
    });
  }

  onPlayModel(event) {
    if (this.editor) {
      return;
    }

    MessageService.send({
      type: MessageType.PlayModel,
      itemId: event.itemId,
      actionIndex: event.actionIndex
    });
  }

  onGridMove(event) {
    // console.log('WorldComponent.onGridMove', event, this.view);
    this.view.items = [];
    this.pushChanges();
    this.orbitService.walk(event.position, (headingLongitude, headingLatitude) => {
      const tile = this.view.getTile(event.indices.x, event.indices.y);

      if (tile) {
        this.panorama.crossfade(tile, this.renderer, texture => {
          if (!environment.flags.useTextureEnvironment) {
            this.setBackground(texture);
          }

          this.orbitService.walkComplete(headingLongitude, headingLatitude);
          this.view.updateCurrentItems(); // this.loading = null;

          this.pushChanges(); // this.render();
          // this.pushChanges();
        });
      }
    });
  }

  onGridNav(event) {
    // console.log('WorldComponent.onGridNav', event);
    if (this.locked) {
      return;
    }

    MessageService.send({
      type: MessageType.NavToGrid,
      viewId: this.view.id,
      gridIndex: event
    });
    this.pushChanges();
  }

  control$() {
    return this.controlEvent$.pipe(operators.filter(() => this.controlling || this.spyed || this.editor), operators.auditTime(40), operators.tap(control => {
      control.orientation.latitude = this.orbitService.latitude;
      control.orientation.longitude = this.orbitService.longitude;
      control.zoom = this.orbitService.zoom;
      control.cameraGroup = {
        position: this.cameraGroup.position.toArray(),
        rotation: this.cameraGroup.rotation.toArray()
      };
      const intersections = this.raycaster.intersectObjects(this.intersectObjects);
      const point = intersections.length ? intersections[0].point.normalize() : null;

      if (point) {
        control.pointer[0] = point.x;
        control.pointer[1] = point.y;
        control.pointer[2] = point.z;
      }

      MessageService.send(control);
    }));
  }

  addListeners() {
    this.controlEvent$ = new rxjs.ReplaySubject(1);
    this.control$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => {
      this.renderer.xr.setSession(session);

      if (session) {
        this.onVRStarted();
      } else {
        this.onVREnded();
      }
    });
    vrService.state$.pipe(operators.takeUntil(this.unsubscribe$), operators.auditTime(Math.floor(1000 / 15))).subscribe(state => {
      this.onVRStateDidChange(state);
    });
    const orbit$ = this.orbitService.observe$(this.container).pipe(operators.shareReplay(1));
    /*
    const drag$ = orbit$.pipe(
    	filter(event => event instanceof OrbitDragEvent),
    );
    */

    const orientation$ = orbit$.pipe(operators.filter(event => event instanceof OrbitMoveEvent), operators.auditTime(Math.floor(1000 / 15)));
    orientation$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // this.render();
      this.onOrientationDidChange();
    });
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      switch (message.type) {
        case MessageType.RequestInfo:
          message.type = MessageType.RequestInfoResult;
          message.viewId = this.view.id;
          message.orientation = this.orbitService.getOrientation();
          message.zoom = this.orbitService.zoom;
          message.cameraGroup = {
            position: this.cameraGroup.position.toArray(),
            rotation: this.cameraGroup.rotation.toArray()
          };

          if (this.view instanceof PanoramaGridView) {
            message.gridIndex = this.view.index;
          } // console.log('WorldComponent', 'MessageType.RequestInfo', 'from', message.clientId, 'to', StateService.state.uid, message.orientation);


          MessageService.sendBack(message);

          if (StateService.state.role !== RoleType.Publisher) {
            StateService.patchState({
              spying: message.remoteId
            }); // console.log('WorldComponent.MessageService.out$.RequestInfo', StateService.state.spying, message.remoteId);
          }

          break;

        case MessageType.RequestInfoResult:
          // console.log('WorldComponent', 'MessageType.RequestInfoResult', 'from', message.clientId, 'to', StateService.state.uid, message.orientation);
          if (ViewService.viewId !== message.viewId) {
            ViewService.viewId = message.viewId;
            this.requestInfoResult = message;
          } else {
            if (!this.renderer.xr.isPresenting) {
              this.orbitService.setOrientation(message.orientation);
              this.orbitService.zoom = message.zoom;
              this.cameraGroup.position.set(message.cameraGroup.position[0], message.cameraGroup.position[1], message.cameraGroup.position[2]);
              this.cameraGroup.rotation.set(message.cameraGroup.rotation[0], message.cameraGroup.rotation[1], message.cameraGroup.rotation[2]); // this.camera.updateProjectionMatrix();
            }

            if (this.view instanceof PanoramaGridView && message.gridIndex) {
              this.view.index = message.gridIndex;
            }

            if (!this.view || !this.view.ready) {
              this.requestInfoResult = message;
            }
          }

          break;

        case MessageType.ShowPanel:
          if (this.menu) {
            this.menu.removeMenu();
          }

          this.view.items.forEach(item => item.showPanel = item.id === message.itemId);
          this.pushChanges();
          break;

        case MessageType.NavLink:
          const item = this.view.items.find(item => item.id === message.itemId);

          if (item) {
            const link = item.links[message.linkIndex];
            this.navLink.next({
              item,
              link,
              linkIndex: message.linkIndex
            });
          }

          break;

        case MessageType.NavLinkClose:
          const closeItem = this.view.items.find(item => item.id === message.itemId);

          if (closeItem) {
            ModalService.resolve();
          }

          break;

        case MessageType.PlayMedia:
          {
            // !!! uniformare a PlayModel
            const item = this.view.items.find(item => item.id === message.itemId);

            if (item && item.mesh instanceof MediaMesh) {
              item.mesh.setPlayingState(message.playing);
            }

            break;
          }

        case MessageType.ZoomMedia:
          {
            this.view.items.forEach(item => {
              if (item.mesh instanceof MediaMesh) {
                if (item.id === message.itemId) {
                  item.mesh.setZoomedState(message.zoomed);
                } else {
                  item.mesh.setZoomedState(false);
                }
              }
            });
            StateService.patchState({
              zoomedId: message.zoomed ? message.itemId : null
            });
            break;
          }

        case MessageType.CurrentTimeMedia:
          {
            const item = this.view.items.find(item => item.id === message.itemId);

            if (item && item.mesh instanceof MediaMesh) {
              item.mesh.setCurrentTime(message.currentTime);
            }

            break;
          }

        case MessageType.PlayModel:
          {
            const item = this.view.items.find(item => item.id === message.itemId);

            if (item) {
              item.onMessage(message);
            }

            break;
          }

        case MessageType.NavToGrid:
          // console.log('WorldComponent.NavToGrid', this.view.id, message);
          if (this.view.id === message.viewId) {
            this.view.index = message.gridIndex;
          }

          break;

        case MessageType.VRStarted:
          this.addOffCanvasScene(message);
          break;

        case MessageType.VREnded:
          this.removeOffCanvasScene(message);
          break;

        case MessageType.VRState:
          this.updateOffCanvasScene(message);

          if (StateService.state.spying === message.clientId || StateService.state.controlling === message.clientId) {
            this.orbitService.setVRCamera(message.camera);
          }

          break;

        case MessageType.ControlInfo:
          if (!this.renderer.xr.isPresenting) {
            this.orbitService.setOrientation(message.orientation);
            this.orbitService.zoom = message.zoom;
            this.cameraGroup.position.set(message.cameraGroup.position[0], message.cameraGroup.position[1], message.cameraGroup.position[2]);
            this.cameraGroup.rotation.set(message.cameraGroup.rotation[0], message.cameraGroup.rotation[1], message.cameraGroup.rotation[2]); // this.camera.updateProjectionMatrix();
          }

          this.pointer.setPosition(message.pointer[0], message.pointer[1], message.pointer[2], this.camera);
          break;
      }
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      switch (message.type) {
        case MessageType.SelectItem:
          this.checkSelectedItem();
          break;
      }
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.showPointer = this.locked; // console.log(state);
      // this.pushChanges();
    });
    this.resize = this.resize.bind(this);
    this.render = this.render.bind(this);
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);
    this.onMouseWheel = this.onMouseWheel.bind(this); // this.controls.addEventListener('change', this.render); // use if there is no animation loop

    window.addEventListener('resize', this.resize, false);
    this.container.addEventListener('wheel', this.onMouseWheel, false);
    this.container.addEventListener('mousedown', this.onMouseDown, false);
    this.container.addEventListener('mouseup', this.onMouseUp, false);
    document.addEventListener('mousemove', this.onMouseMove, false);
  }

  removeListeners() {
    window.removeEventListener('resize', this.resize, false);
    window.removeEventListener('resize', this.resize, false);
    document.removeEventListener('mousemove', this.onMouseMove, false);
    document.removeEventListener('wheel', this.onMouseWheel, false);
    this.container.removeEventListener('mousedown', this.onMouseDown, false);
    this.container.removeEventListener('mouseup', this.onMouseUp, false);
  }

}
WorldComponent.meta = {
  selector: '[world]',
  inputs: ['view', 'views', 'editor'],
  outputs: ['navTo', 'navLink', 'viewHit', 'dragEnd', 'resizeEnd', 'select'],
  template:
  /* html */
  `
	<div class="world__view" *if="view">
		<div class="grid" model-grid *if="view.type.name === 'panorama-grid'" [view]="view" (move)="onGridMove($event)" (nav)="onGridNav($event)"></div>
		<div *if="view.ready">
			<div model-room [view]="view" *if="view.type.name === 'room-3d'"></div>
			<div class="world__item" *for="let item of view.pathItems; let index = index;">
				<div model-nav [item]="item" [view]="view" (over)="onNavOver($event)" (out)="onNavOut($event)" (down)="onNavDown($event)" (link)="onNavLink($event)" *if="item.type.name == 'nav'"></div>
				<div model-plane [item]="item" [view]="view" (play)="onPlayMedia($event)" (zoom)="onZoomMedia($event)" (down)="onObjectDown($event)" (currentTime)="onCurrentTimeMedia($event)" *if="item.type.name == 'plane'"></div>
				<div model-curved-plane [item]="item" [view]="view" (play)="onPlayMedia($event)" (zoom)="onZoomMedia($event)" (down)="onObjectDown($event)" (currentTime)="onCurrentTimeMedia($event)" *if="item.type.name == 'curved-plane'"></div>
				<div class="model-viewer__item" model-model [item]="item" [view]="view" (down)="onModelDown($event)" (play)="onPlayModel($event)" *if="item.type.name == 'model'"></div>
				<div class="panel" [class]="{ 'panel--lg': item.asset != null }" model-panel [item]="item" (down)="onPanelDown($event)" *if="item.showPanel"></div>
			</div>
		</div>
	</div>
	<div class="progress-indicator" model-progress [view]="view">
		<div class="inner"></div>
	</div>
	<div model-menu [views]="views" (nav)="onMenuNav($event)" (toggle)="onMenuToggle($event)" *if="showMenu"></div>
	<div model-debug *if="debugging"></div>
	<div class="world__info" *if="error" [innerHTML]="error"></div>
	`
};class ModelComponent extends rxcomp.Component {
  set renderOrder(renderOrder) {
    this.group.renderOrder = renderOrder;
  }

  onInit() {
    // console.log('ModelComponent.onInit');
    // console.log('item', this.item, 'host', this.host);
    if (!this.host) {
      throw 'ModelComponent host is undefined';
    }

    this.scale = new THREE.Vector3(1.0, 1.0, 1.0);
    this.position = new THREE.Vector3();
    const group = this.group = new THREE.Group();
    group.name = this.getName();

    group.userData.render = (time, tick) => {
      // if (this.intersection) {
      this.render(this, time, tick); // }
    };

    this.getContainer().add(group);
    this.onCreate((mesh, item) => this.onMount(mesh, item), (mesh, item) => this.onDismount(mesh, item));
  }

  onDestroy() {
    // console.log('ModelComponent', this);
    const group = this.group;
    this.getContainer().remove(group);
    delete group.userData.render;
    this.disposeObject(group);
    this.group = null;
  }

  getContainer() {
    return this.host.objects;
  }

  getName(name) {
    return `${this.constructor.meta.selector}-${this.rxcompId}${name ? `-${name}` : ''}`;
  }

  onCreate(mounth, dismount) {
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color('#ffcc00'),
      roughness: 0.4,
      metalness: 0.01,
      flatShading: true,
      transparent: true,
      opacity: 0.9
    });
    const mesh = new THREE.Mesh(Geometry.defaultGeometry, material);

    if (typeof mounth === 'function') {
      mounth(mesh);
    }

    return mesh;
  }

  onMount(mesh, item) {
    if (this.mesh) {
      // console.log('ModelComponent.dismount.mesh');
      this.onDismount(this.mesh);
    }

    mesh.name = this.getName('mesh');
    this.mesh = mesh;

    if (item) {
      item.mesh = mesh;
      Object.defineProperty(item, 'visible', {
        get: () => {
          return mesh.visible;
        },
        set: visible => {
          this.setVisible(visible);
        },
        configurable: true
      });

      item.onUpdate = () => {
        this.onUpdate(item, mesh);
      };

      item.onUpdateAsset = () => {
        this.onUpdateAsset(item, mesh);
      };

      item.onMessage = message => {
        this.onMessage(message);
      };
    }

    if (this.group) {
      this.group.add(mesh);
    } // this.host.render(); !!!

    /*
    const node = this.node;
    DomService.scrollIntersection$(node).subscribe(event => {
    	this.scroll = event.scroll;
    	this.intersection = event.intersection;
    	this.calculateScaleAndPosition();
    });
    */
    // console.log('Model.loaded', mesh);

  }

  onDismount(mesh, item) {
    this.group.remove(mesh);

    if (typeof mesh.dispose === 'function') {
      mesh.dispose();
    }

    this.disposeObject(mesh);
    this.mesh = null;

    if (item) {
      delete item.mesh;
      delete item.onUpdate;
      delete item.onUpdateAsset;
      delete item.onMessage;
    }
  }

  disposeObject(object) {
    object.traverse(child => {
      if (child.isInteractiveMesh || child.isInteractiveSprite) {
        Interactive.dispose(child);
      }

      if (child.isMesh) {
        if (child.material.map && child.material.map.disposable !== false) {
          child.material.map.dispose();
        }

        child.material.dispose();
        child.geometry.dispose();
      } else if (child.isSprite) {
        if (child.material.map && child.material.map.disposable !== false) {
          child.material.map.dispose();
        }

        child.material.dispose();
      }
    }); // console.log('ModelComponent.disposeObject', object);
  }

  calculateScaleAndPosition() {
    const {
      node
    } = rxcomp.getContext(this);
    this.host.repos(this, node.getBoundingClientRect());
  }

  render(time, tick) {
    /*
    this.calculateScaleAndPosition();
    const group = this.group;
    const scale = this.scale;
    // group.scale.set(scale.x, scale.y, scale.z);
    const position = this.position;
    group.position.set(position.x, 0, 0);
    // const tween = this.tween();
    // group.rotation.x = THREE.Math.degToRad(180) * tween;
    // group.rotation.y = THREE.Math.degToRad(360) * tween;
    */
  }

  setVisible(visible) {
    if (this.mesh) {
      this.mesh.visible = visible;
    }
  }

  getScroll(offset) {
    const scroll = this.intersection.scroll(offset); // console.log(scroll);

    return scroll;
  }

  getTween(offset) {
    let tween = Math.min(0.0, this.intersection.offset(offset)) + 1;
    tween = Math.max(0.0, tween); // tween = Ease.Sine.InOut(tween);

    tween -= 1;
    return tween;
  } // called by UpdateViewItemComponent


  onUpdate(item, mesh) {} // called by UpdateViewItemComponent


  onUpdateAsset(item, mesh) {} // called by remote events


  onMessage(message) {}

}
ModelComponent.meta = {
  selector: '[model]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};// import * as THREE from 'three';
class ModelEditableComponent extends ModelComponent {
  get editing() {
    return this.editing_;
  }

  set editing(editing) {
    if (this.editing_ !== editing) {
      this.editing_ = editing;
      this.setHelper(editing);
    }
  }

  onInit() {
    super.onInit();
    this.RADIUS = 100;
  }

  onDestroy() {
    // console.log('ModelEditableComponent', this);
    this.editing = false;
    super.onDestroy();
  }

  setHelper(showHelper) {
    if (showHelper) {
      if (!this.helper) {
        this.helper = new THREE.BoxHelper(this.mesh, 0x00ff00);
      }

      this.host.scene.add(this.helper);
    } else if (this.helper) {
      this.host.scene.remove(this.helper);
    }
  }

  updateHelper() {
    if (this.helper) {
      this.helper.setFromObject(this.mesh); // this.helper.update();
    }
  }

}
ModelEditableComponent.meta = {
  selector: '[model-editable]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};// import * as THREE from 'three';
const NavModeType = {
  None: 'none',
  Move: 'move',
  Info: 'info',
  Point: 'point',
  Title: 'title',
  Transparent: 'transparent',
  Wishlist: 'wishlist'
};
class ModelNavComponent extends ModelEditableComponent {
  constructor() {
    super(...arguments);
    this.hidden_ = false;
    this.isMobile_ = void 0;
  }

  static getLoader() {
    return ModelNavComponent.loader || (ModelNavComponent.loader = new THREE.TextureLoader());
  }

  static getTexturePoint() {
    return ModelNavComponent.texturePoint || (ModelNavComponent.texturePoint = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-point.png')));
  }

  static getTexturePointImportant() {
    return ModelNavComponent.texturePointImportant || (ModelNavComponent.texturePointImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-point-important.png')));
  }

  static getTextureMove() {
    return ModelNavComponent.textureMove || (ModelNavComponent.textureMove = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-more.png')));
  }

  static getTextureMoveImportant() {
    return ModelNavComponent.textureMoveImportant || (ModelNavComponent.textureMoveImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-more-important.png')));
  }

  static getTextureInfo() {
    return ModelNavComponent.textureInfo || (ModelNavComponent.textureInfo = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-info.png')));
  }

  static getTextureInfoImportant() {
    return ModelNavComponent.textureInfoImportant || (ModelNavComponent.textureInfoImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-info-important.png')));
  }

  static getTextureWishlist() {
    return ModelNavComponent.textureWishlist || (ModelNavComponent.textureWishlist = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-wishlist-off.png')));
  }

  static getTextureWishlistAdded() {
    return ModelNavComponent.textureWishlistAdded || (ModelNavComponent.textureWishlistAdded = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-wishlist-on.png')));
  }

  static getTexture(mode, item) {
    let texture;

    switch (mode) {
      case NavModeType.Move:
        texture = item.important ? this.getTextureMoveImportant() : this.getTextureMove();
        break;

      case NavModeType.Info:
        texture = item.important ? this.getTextureInfoImportant() : this.getTextureInfo();
        break;

      case NavModeType.Point:
      case NavModeType.Title:
        texture = item.important ? this.getTexturePointImportant() : this.getTexturePoint();
        break;

      case NavModeType.Wishlist:
        texture = item.added ? this.getTextureWishlistAdded() : this.getTextureWishlist();
        break;
    }

    texture.disposable = false;
    texture.encoding = THREE.sRGBEncoding;
    return texture;
  }

  static getTitleTexture(item, mode) {
    let texture;

    if (mode === NavModeType.Title) {
      const text = item.title;
      const canvas = document.createElement('canvas'); // document.querySelector('body').appendChild(canvas);

      canvas.width = 512;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `24px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      let w = metrics.width + 8;
      w = Math.pow(2, Math.ceil(Math.log(w) / Math.log(2)));
      const x = w / 2;
      const y = 16;
      canvas.width = w;
      ctx.font = `24px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.lineWidth = 6;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!

      ctx.miterLimit = 2;
      ctx.strokeText(text, x, y);
      ctx.fillStyle = 'white';
      ctx.fillText(text, x, y);
      texture = new THREE.CanvasTexture(canvas);
    }

    return texture;
  }

  static getNavMode(item, view) {
    let mode = NavModeType.None;

    if (item.hook && item.hook === 'ToggleWishlist') {
      mode = NavModeType.Wishlist;
    } else if (item.transparent) {
      mode = NavModeType.Transparent;
    } else if (item.viewId !== view.id) {
      mode = NavModeType.Move;

      if (this.isValidText(item.title)) {
        mode = NavModeType.Title;
      }

      if (this.isValidText(item.abstract) || item.asset && item.asset.id || item.link && item.link.href) {
        mode = NavModeType.Point;
      }
    } else if (this.isValidText(item.title) || this.isValidText(item.abstract) || item.asset && item.asset.id || item.link && item.link.href) {
      mode = NavModeType.Info;
    }

    return mode;
  }

  static hasNavInfo(view) {
    const item = view.items.find(x => this.getNavMode(x, view) === NavModeType.Info); // console.log('ModelNavComponent.hasNavInfo', item);

    return item != null;
  }

  static isValidText(text) {
    return text && text.length > 0;
  }

  get hidden() {
    return this.hidden_;
  }

  set hidden(hidden) {
    if (this.hidden_ !== hidden) {
      this.hidden_ = hidden;
      this.updateVisibility(!hidden);
    }
  }

  get isHidden() {
    return StateService.state.zoomedId != null || environment.flags.hideNavInfo && !this.host.editor && !StateService.state.showNavInfo && !(this.host.renderer.xr.isPresenting || StateService.state.role === RoleType.SelfService || StateService.state.role === RoleType.Embed) && this.mode === NavModeType.Info;
  }

  get isAnimated() {
    let isAnimated = false;
    const mode = this.mode;
    const important = this.item.important;

    switch (mode) {
      case NavModeType.Info:
        isAnimated = important ? environment.flags.navInfoImportantAnimated : environment.flags.navInfoAnimated;
        break;

      case NavModeType.Move:
        isAnimated = important ? environment.flags.navMoveImportantAnimated : environment.flags.navMoveAnimated;
        break;

      case NavModeType.Point:
        isAnimated = important ? environment.flags.navPointImportantAnimated : environment.flags.navPointAnimated;
        break;

      case NavModeType.Title:
        isAnimated = important ? environment.flags.navTitleImportantAnimated : environment.flags.navTitleAnimated;
        break;

      case NavModeType.Transparent:
        isAnimated = important ? environment.flags.navTransparentImportantAnimated : environment.flags.navTransparentAnimated;
        break;
    }

    return isAnimated;
  }

  get iconMinScale() {
    return (environment.navs.iconMinScale || 1) * 0.03 * (this.isMobile ? 1.6 : 1);
  }

  get iconMaxScale() {
    return (environment.navs.iconMaxScale || 1.5) * 0.03 * (this.isMobile ? 1.6 : 1);
  }

  get isMobile() {
    return this.isMobile_;
  }

  set isMobile(isMobile) {
    if (this.isMobile_ !== isMobile) {
      this.isMobile_ = isMobile;
      this.setScale();
    }
  }

  render(time, tick) {
    // console.log('render', this.host.worldRect.width);
    this.isMobile = this.host.worldRect.width < 768;
  }

  setScale(pow) {
    if (pow === void 0) {
      pow = 0;
    }

    const icon = this.icon;

    if (icon) {
      const scale = this.iconMinScale + pow * (this.iconMaxScale - this.iconMinScale);
      icon.scale.set(scale, scale, scale);
    }
  }

  shouldShowPanel() {
    return !this.editing && this.mode !== NavModeType.Move && this.mode !== NavModeType.Title && this.mode !== NavModeType.Wishlist && (this.mode !== NavModeType.Transparent || ModelNavComponent.isValidText(this.item.title));
  }

  updateVisibility(visible) {
    if (this.mesh) {
      this.mesh.visible = visible;
    }

    if (this.sphere) {
      this.sphere.freezed = !visible;
    }

    if (!visible && this.item) {
      this.item.showPanel = false;
    }
  }

  setVisible(visible) {
    if (this.mesh) {
      this.mesh.visible = visible && !this.hidden_;
    }
  }

  onInit() {
    super.onInit();
  }

  onChanges() {
    const view = this.view;
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);

    if (mode === NavModeType.Wishlist) {
      item.added = WishlistService.has({
        viewId: view.id,
        itemId: item.id
      });
      this.onCreateSprites(this.mesh, 1);
    }

    this.editing = item.selected;
    this.hidden = this.isHidden;
  }

  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.nav;
    const view = this.view;
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);

    if (mode === NavModeType.None) {
      return;
    }

    if (mode === NavModeType.Wishlist) {
      item.added = WishlistService.has({
        viewId: view.id,
        itemId: item.id
      });
    }

    const isAnimated = this.isAnimated;
    const nav = new THREE.Group();

    if (mode === NavModeType.Transparent) {
      const opacityIdle = this.host.editor ? 0.1 : 0.0;
      const opacityOver = 0.2;
      const opacityDown = 0.3;
      nav.position.fromArray(item.position);
      nav.rotation.fromArray(item.rotation);
      nav.scale.fromArray(item.scale);
      const geometry = Geometry.planeGeometry;
      const plane = this.plane = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        opacity: opacityIdle,
        color: new THREE.Color(environment.colors.menuOverBackground),
        toneMapped: false
      }));
      plane.name = `[nav] ${item.id}`;
      plane.depthTest = false;
      nav.add(plane);

      if (isAnimated) {
        const from = {
          pow: 0
        };
        gsap.to(from, {
          pow: 1,
          duration: 0.6,
          delay: 0.5 + 0.1 * item.index,
          ease: Power2.easeOut,
          repeat: -1,
          yoyo: true,
          onUpdate: () => {
            plane.material.opacity = from.pow * opacityDown;
          }
        });
      }

      plane.on('over', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityOver;
        }

        this.over.next(this);
      });
      plane.on('out', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityIdle;
        }

        this.out.next(this);
      });
      plane.on('down', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityDown;
        }

        this.down.next(this); // opening nav link

        const item = this.item;
        const link = item.firstLink;

        if (!this.host.editor && !this.shouldShowPanel() && link && link.href) {
          this.shouldNavToLink = link.href;
        }

        console.log('ModelNavComponent.down');
      });
      plane.on('up', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityIdle;
        } // opening nav link


        if (this.shouldNavToLink != null) {
          /*
          const link = this.shouldNavToLink;
          window.open(link, '_blank');
          */
          this.shouldNavToLink = null;
          const item = this.item;
          const link = item.firstLink;
          this.link.next({
            item,
            link
          });
        }
      });
    } else {
      // !! fixing normalized positions;
      const position = new THREE.Vector3(item.position[0], item.position[1], item.position[2]);
      const normalizedPosition = new THREE.Vector3(item.position[0], item.position[1], item.position[2]).normalize();

      if (position.distanceToSquared(normalizedPosition) < 0.0001) {
        position.multiplyScalar(ModelNavComponent.RADIUS);
      } // console.log('!!! fixing normalized positions', 'position', position, 'normalizedPosition', normalizedPosition, 'distanceToSquared', position.distanceToSquared(normalizedPosition));


      nav.position.copy(position);
      this.onCreateSprites(nav);
      const geometry = Geometry.sphereGeometry;
      const sphere = this.sphere = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        opacity: 0.0,
        color: 0x00ffff,
        toneMapped: false
      }));
      sphere.name = `[nav] ${item.id}`; // sphere.lookAt(Host.origin); ??

      sphere.depthTest = false; // sphere.renderOrder = 0;

      nav.add(sphere);
      const from = {
        pow: 0
      };
      gsap.to(from, {
        pow: 1,
        duration: 0.7,
        delay: 0.5 + 0.1 * item.index,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          this.materials.forEach(material => {
            material.opacity = from.pow; // material.needsUpdate = true;
          });
        },
        onComplete: () => {
          if (isAnimated) {
            const icon = this.icon;
            from.pow = 0;
            gsap.to(from, {
              pow: 1,
              duration: 0.6,
              delay: 0.5 + 0.1 * item.index,
              ease: Power2.easeOut,
              repeat: -1,
              yoyo: true,
              onUpdate: () => {
                this.setScale(from.pow);
                icon.material.opacity = from.pow;
              }
            });
          }
        }
      });
      sphere.on('over', () => {
        this.over.next(this);

        if (!isAnimated) {
          const icon = this.icon;
          const from = {
            scale: icon.scale.x
          };
          gsap.to(from, {
            duration: 0.35,
            scale: this.iconMaxScale,
            delay: 0,
            ease: Power2.easeOut,
            overwrite: true,
            onUpdate: () => {
              icon.scale.set(from.scale, from.scale, from.scale);
            }
          });
        }
      });
      sphere.on('out', () => {
        this.out.next(this);

        if (!isAnimated) {
          const icon = this.icon;
          const from = {
            scale: icon.scale.x
          };
          gsap.to(from, {
            duration: 0.35,
            scale: this.iconMinScale,
            delay: 0,
            ease: Power2.easeOut,
            overwrite: true,
            onUpdate: () => {
              icon.scale.set(from.scale, from.scale, from.scale);
            }
          });
        }
      });
      sphere.on('down', () => {
        this.down.next(this);
      });
    }

    if (typeof mount === 'function') {
      mount(nav, item);
    }
  }

  onCreateSprites(mesh, opacity) {
    if (opacity === void 0) {
      opacity = 0;
    }

    this.onRemoveSprite(this.icon);
    this.onRemoveSprite(this.title);
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);

    if (mode === NavModeType.None) {
      return;
    }

    if (mode === NavModeType.Transparent) {
      this.materials = [];
    } else {
      const map = ModelNavComponent.getTexture(mode, item);
      const material = new THREE.SpriteMaterial({
        map: map,
        depthTest: false,
        depthWrite: false,
        transparent: true,
        sizeAttenuation: false,
        opacity: opacity,
        toneMapped: false // color: 0xff0000,

      });
      const materials = [material];
      const icon = this.icon = new THREE.Sprite(material);
      icon.renderOrder = environment.renderOrder.nav;
      this.setScale();
      mesh.add(icon);
      let titleMaterial;
      const titleTexture = ModelNavComponent.getTitleTexture(item, mode);

      if (titleTexture) {
        titleMaterial = new THREE.SpriteMaterial({
          depthTest: false,
          depthWrite: false,
          transparent: true,
          map: titleTexture,
          sizeAttenuation: false,
          opacity: opacity,
          toneMapped: false // color: 0xff0000,

        }); // console.log(titleTexture);

        const image = titleTexture.image;
        const title = this.title = new THREE.Sprite(titleMaterial);
        const scale = this.iconMinScale;
        title.scale.set(scale * image.width / image.height, scale, scale);
        title.position.set(0, -3.5, 0);
        mesh.add(title);
        materials.push(titleMaterial);
      }

      this.materials = materials;
    }
  }

  onRemoveSprite(sprite) {
    if (sprite) {
      if (sprite.parent) {
        sprite.parent.remove(sprite);
      }

      if (sprite.material.map && sprite.material.map.disposable !== false) {
        sprite.material.map.dispose();
      }

      sprite.material.dispose();
    }
  }

  onDestroy() {
    Interactive.dispose(this.sphere);
    super.onDestroy();
  } // called by UpdateViewItemComponent


  onUpdate(item, mesh) {
    this.item = item;
    this.onCreateSprites(mesh, 1);

    if (this.mode === NavModeType.Transparent) {
      if (item.position) {
        mesh.position.fromArray(item.position);
      }

      if (item.rotation) {
        mesh.rotation.fromArray(item.rotation);
      }

      if (item.scale) {
        mesh.scale.fromArray(item.scale);
      }
    } else {
      // const position = new THREE.Vector3().set(...item.position).normalize().multiplyScalar(ModelNavComponent.RADIUS);
      // mesh.position.set(position.x, position.y, position.z);
      mesh.position.fromArray(item.position);
      mesh.rotation.set(0, 0, 0);
      mesh.scale.set(1, 1, 1);
    } // console.log('onUpdate', item, mesh.position);


    this.updateHelper();
    /*
    this.onCreate(
    	(mesh, item) => this.onMount(mesh, item),
    	(mesh, item) => this.onDismount(mesh, item)
    );
    */
  } // called by WorldComponent


  onDragMove(position, normal, spherical) {
    // console.log('ModelNavComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    this.editing = true;
    item.showPanel = false;

    if (this.mode === NavModeType.Transparent) {
      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        mesh.position.set(position.x, position.y, position.z);
        mesh.lookAt(Host.origin);
      } else {
        mesh.position.set(0, 0, 0);
        mesh.lookAt(normal);
        mesh.position.set(position.x, position.y, position.z);
        mesh.position.add(normal.multiplyScalar(0.01));
      }
    } else {
      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        mesh.position.set(position.x, position.y, position.z);
      } else {
        mesh.position.set(position.x, position.y, position.z);
        mesh.position.add(normal.multiplyScalar(0.01));
      }
    }

    this.updateHelper();
  } // called by WorldComponent


  onDragEnd() {
    const item = this.item;
    const mesh = this.mesh;

    if (this.mode === NavModeType.Transparent) {
      item.position = mesh.position.toArray();
      item.rotation = mesh.rotation.toArray();
      item.scale = mesh.scale.toArray();
    } else {
      item.position = mesh.position.toArray(); // new THREE.Vector3().copy(mesh.position).normalize().toArray();
    }

    this.editing = false;
  }

}
ModelNavComponent.RADIUS = 100;
ModelNavComponent.meta = {
  selector: '[model-nav]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['over', 'out', 'down', 'link'],
  inputs: ['item', 'view']
};class AgoraComponent extends rxcomp.Component {
  get meetingUrl() {
    if (!this.meetingUrl_) {
      this.meetingUrl_ = new MeetingUrl();
    }

    return this.meetingUrl_;
  }

  get isVirtualTourUser() {
    return [RoleType.Publisher, RoleType.Attendee, RoleType.Streamer, RoleType.Viewer].indexOf(StateService.state.role) !== -1;
  }

  get isEmbed() {
    if (this.route) {
      return this.route.params.mode === 'embed';
    }
  }

  get isSelfServiceTour() {
    if (this.route) {
      return this.route.params.mode === 'selfServiceTour';
    }
  }

  get isNavigable() {
    const embedViewId = this.meetingUrl.embedViewId;
    const navigable = embedViewId == null;
    return navigable;
  }

  get isBackButtonVisible() {
    return this.view && (this.view.type.name === ViewType.Media.name || this.view.type.name === ViewType.Model.name);
  }

  get isSelfServiceProposition() {
    return StateService.state.role === RoleType.SelfService && environment.flags.selfServiceProposition;
  }

  get isSelfServiceSupport() {
    return StateService.state.role === RoleType.Publisher && environment.flags.selfServiceProposition && this.meetingUrl.support;
  }

  get showNavInfoToggler() {
    return environment.flags.hideNavInfo && this.state.mode !== UIMode.LiveMeeting && this.view && ModelNavComponent.hasNavInfo(this.view);
  }

  get uiClass() {
    const uiClass = {};
    uiClass[this.state.role] = true; // uiClass[this.state.mode] = true;

    uiClass.chat = this.state.chat;
    uiClass.remotes = this.state.mode === UIMode.LiveMeeting;
    uiClass.remoteScreen = this.remoteScreen != null && !this.hasScreenViewItem;
    uiClass.locked = this.locked; // uiClass.media = !uiClass.remotes && this.media;

    return uiClass;
  }

  get remoteClass() {
    return `group--remote--${Math.min(9, this.remotes.length)}`;
  }

  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }

  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }

  get silencing() {
    return StateService.state.silencing;
  }

  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }

  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }

  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }

  get locked() {
    return this.controlled || this.spying;
  }

  get remoteScreen() {
    return this.remoteScreen_;
  }

  set remoteScreen(remoteScreen) {
    if (this.remoteScreen_ !== remoteScreen) {
      this.remoteScreen_ = remoteScreen;
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 1);
    }
  }

  get pathViews() {
    return ViewService.pathViews;
  }

  onInit() {
    // console.log('AgoraComponent.onInit', this.host);
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
    this.platform = DeviceService.platform;
    this.route = this.host ? this.host.route : null;
    this.state = {};
    this.hosted = null;
    this.view = null;
    this.previousView = null;
    this.form = null;
    this.local = null;
    this.screen = null;
    this.remoteScreen_ = null;
    this.navmaps = [];
    this.navmap = null; // this.media = null;

    this.hasScreenViewItem = false;
    this.remotes = [];
    const vrService = this.vrService = VRService.getService();
    vrService.status$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(status => this.pushChanges());
    this.resolveUser();
  }

  getName(user) {
    return StateService.state.name || MeetingUrl.getName(user);
  }

  getLinkRole() {
    let linkRole = null;

    if (this.isSelfServiceTour) {
      linkRole = RoleType.SelfService;
      return linkRole;
    }

    const meetingUrl = new MeetingUrl();
    const match = (meetingUrl.link || '').match(/\d{9}-(\d{4})-\d{13}/);

    if (match) {
      const index = parseInt(match[1]);
      linkRole = Object.keys(RoleType).reduce((p, c, i) => {
        return i === index ? RoleType[c] : p;
      }, null);
    }

    return linkRole;
  }

  resolveUser() {
    if (this.isEmbed) {
      UserService.temporaryUser$(RoleType.Embed).pipe(operators.first()).subscribe(user => {
        this.initWithUser(user);
      });
    } else if (this.isSelfServiceTour) {
      UserService.overrideUser$(RoleType.SelfService).pipe(operators.first()).subscribe(user => {
        this.initWithUser(user);
      });
    } else {
      UserService.me$().pipe(operators.first()).subscribe(user => {
        this.initWithUser(user); // this.userGuard(user);
      });
    }
  }

  userGuard(user) {
    // console.log('AgoraComponent.userGuard', user);
    const linkRole = this.getLinkRole();

    if (user && (!linkRole || user.type === linkRole)) {
      this.initWithUser(user);
    } else {
      this.initWithUser({
        type: linkRole
      });
    }
  }

  userGuardRedirect(user) {
    // console.log('AgoraComponent.userGuardRedirect', user);
    const linkRole = this.getLinkRole();

    if (user && (!linkRole || linkRole === user.type)) {
      this.initWithUser(user);
    } else if (linkRole === RoleType.Publisher || linkRole === RoleType.Attendee) {
      RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
    } else {
      this.initWithUser({
        type: linkRole
      });
    }
  }

  setNextStatus() {
    let status = AgoraStatus.Idle;
    const state = StateService.state;

    if (state.role === RoleType.SmartDevice) {
      state.name = state.name || 'Smart Device';
    }

    if (!state.checklist) {
      status = AgoraStatus.Checklist;
    } else if (!state.link) {
      status = AgoraStatus.Link;
    } else if (!state.user.id && (state.role === RoleType.Publisher || state.role === RoleType.Attendee)) {
      status = AgoraStatus.Login;
    } else if (!state.name) {
      status = AgoraStatus.Name;
    } else if (state.role !== RoleType.Viewer && state.role !== RoleType.SmartDevice) {
      status = AgoraStatus.Device;
    } else {
      status = AgoraStatus.ShouldConnect;
    }

    StateService.patchState({
      status
    });
    return status;
  }

  getPathId() {
    const meetingUrl = new MeetingUrl();
    let pathId = meetingUrl.pathId;

    if (pathId) {
      // console.log('AgoraComponent.getPathId', pathId);
      return parseInt(pathId);
    }

    const link = meetingUrl.link;

    if (link) {
      const meetingId = new MeetingId(link);
      pathId = meetingId.pathId;
    } // console.log('AgoraComponent.getPathId', pathId);


    return pathId;
  }

  initWithUser(user) {
    // console.log('AgoraComponent.initWithUser', user);
    const meetingUrl = new MeetingUrl();
    const link = meetingUrl.link;
    const pathId = this.getPathId();
    const role = this.getLinkRole() || (user ? user.type : null);

    switch (role) {
      case RoleType.SelfService:
        if (!user || user.type !== RoleType.SelfService && user.type !== RoleType.Publisher) {
          RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
          return;
        } else {
          // forcing role type to RoleType.SelfService
          user = Object.assign({}, user, {
            type: RoleType.SelfService
          });
        }

        break;

      default:
        user = user || {
          type: role
        };

        if (role !== user.type) {
          user = {
            type: role
          };
        }

    } // console.log('initWithUser', role, user);


    const mode = UserService.getMode(role);
    const name = this.getMeetingName(user); // const name = meetingUrl.name || this.getName(user);

    const checklist = null;
    const hosted = role === RoleType.Publisher ? true : false;
    const live = role === RoleType.SelfService || role === RoleType.Embed || DEBUG ? false : true;
    const navigable = this.isNavigable;
    const state = {
      user: user,
      role: role,
      mode: mode,
      name: name,
      checklist: checklist,
      pathId: pathId,
      link: link,
      channelName: environment.channelName,
      uid: null,
      status: AgoraStatus.Idle,
      connecting: false,
      connected: false,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: hosted,
      live: live,
      navigable: navigable,
      cameraMuted: false,
      audioMuted: false,
      showNavInfo: true
    };
    StateService.state = state;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.hosted = state.hosted;
      this.pushChanges(); // console.log(state);

      this.locked ? document.body.classList.add('locked') : document.body.classList.remove('locked');
    });
    this.initAgora();
  }

  getMeetingName(user) {
    const meetingUrl = new MeetingUrl();
    let name = null;

    if (environment.flags.useExtendedUserInfo) {
      name = meetingUrl.firstName && meetingUrl.lastName ? `${meetingUrl.firstName} ${meetingUrl.lastName}` : null;
    } else {
      name = meetingUrl.name ? meetingUrl.name : null;
    }

    if (!name && user.firstName && user.lastName) {
      name = `${user.firstName} ${user.lastName}`;
    }

    return name;
  }

  viewObserver$() {
    return ViewService.data$().pipe(operators.switchMap(data => {
      // console.log('AgoraComponent.viewObserver$', 'pathId', StateService.state.pathId);
      return PathService.getCurrentPath$(StateService.state.pathId).pipe(operators.switchMap(path => {
        return ViewService.hostedView$(data, path);
      }));
    }),
    /*
    tap(view => {
    	this.view = null;
    	this.pushChanges();
    }),
    delay(1),
    */
    operators.map(view => {
      // console.log('AgoraComponent.viewObserver$', view);
      // !!! move navToView to user action?
      if (this.agora) {
        this.agora.navToView(view.id, view.keepOrientation, view.useLastOrientation);
      }

      this.previousView = this.view;
      this.view = view;
      this.setNavmap(view);
      this.hasScreenViewItem = view.items.find(x => MediaLoader.isPublisherScreen(x) || MediaLoader.isAttendeeScreen(x)) != null;
      this.pushChanges();
      const state = this.state;
      GtmService.push({
        action: 'b-here-view',
        viewId: view.id,
        userType: state.role // aggiunto

      });
      return view;
    }));
  }

  load(callback) {
    this.loadNavmaps();
    this.viewObserver$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(view => {
      // console.log('AgoraComponent.viewObserver$', view);
      if (typeof callback === 'function') {
        callback();
        callback = null;
      }
    });
  }

  loadNavmaps() {
    if (environment.flags.navmaps) {
      NavmapService.navmapGet$().pipe(operators.first()).subscribe(navmaps => {
        this.navmaps = navmaps;
      });
    }
  }

  setNavmap(view) {
    const navmaps = this.navmaps;
    const navmap = (navmaps || []).find(x => (x.items || []).find(i => i.viewId === view.id) != null) || null; // console.log('AgoraComponent.setNavmap', navmap);

    this.navmap = navmap;
  }

  toggleNavmap() {
    StateService.patchState({
      showNavmap: !StateService.state.showNavmap
    });
  }

  onNavmapItem(item) {
    StateService.patchState({
      showNavmap: false
    });
    this.onNavTo(item);
  }

  loadAndConnect(preferences) {
    this.load(() => {
      this.connect(preferences);
    });
  }

  initAgora() {

    if (this.state.role === RoleType.SelfService || this.state.role === RoleType.Embed || DEBUG) {
      this.load(() => {
        StateService.patchState({
          status: AgoraStatus.Connected,
          hosted: true
        });
      });
      this.checkSelfServiceProposition();
      this.checkSelfServiceAudio();
    } else {
      AgoraChecklistService.isChecked$().pipe(operators.first()).subscribe(checked => {
        StateService.patchState({
          checklist: checked
        });
        this.agora = AgoraService.getSingleton();
        this.getLinkRole();
        this.setNextStatus(); // console.log('initAgora', status, role);
      });
    }

    StreamService.local$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(local => {
      // console.log('AgoraComponent.local', local);
      this.local = local;
      this.pushChanges();
    });
    StreamService.screen$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(screen => {
      // console.log('AgoraComponent.screen', screen);
      if (this.screen === this.remoteScreen) {
        this.remoteScreen = null;
      }

      this.screen = screen;
      this.remoteScreen = screen || this.remoteScreen;
      this.pushChanges();
    });
    StreamService.orderedRemotes$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(remotes => {
      this.remotes = [];
      this.remoteScreen = this.screen;
      remotes.forEach(x => {
        if (x.clientInfo && x.clientInfo.screenUid === x.getId()) {
          this.remoteScreen = x;
        } else {
          this.remotes.push(x);
        }
      }); // console.log('AgoraComponent.remotes', this.remotes, this.remoteScreen, remotes.map(x => `${x.clientInfo ? x.clientInfo.uid : 'null'}-${x.clientInfo ? x.clientInfo.screenUid : 'null'}`).join(','));

      this.pushChanges();
    });
    /*
    MediaLoader.events$.pipe(
    	tap(event => {
    		if (event instanceof MediaLoaderPlayEvent) {
    			this.media = event.loader;
    			// this.pushChanges();
    		} else if (event instanceof MediaLoaderDisposeEvent) {
    			if (this.media === event.loader) {
    				this.media = null;
    				// this.pushChanges();
    			}
    		}
    		// console.log('AgoraComponent.MediaLoader.events$', event);
    	}),
    	takeUntil(this.unsubscribe$)
    ).subscribe();
    */

    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // console.log('AgoraComponent.message', message);
      switch (message.type) {
        case MessageType.ChannelMembers:
          if (this.isSelfServiceSupport) {
            const members = message.members; // console.log('AgoraComponent.MessageService.out$.ChannelMembers', members, members.length);

            if (members.length > 0) {
              ToastService.open$({
                message: LabelPipe.transform('bhere_support_request_sent'),
                type: ToastType.Alert,
                position: ToastPosition.BottomRight
              });
              MessageService.send({
                type: MessageType.SupportRequest
              });
            } else {
              ToastService.open$({
                message: LabelPipe.transform('bhere_support_request_leaved'),
                type: ToastType.Alert,
                position: ToastPosition.BottomRight
              });
            }
          }

          break;

        case MessageType.SupportRequest:
          if (this.isSelfServiceProposition) {
            this.openSupportRequestDialog(message.clientInfo);
          }

          break;

        case MessageType.RequestPeerInfo:
          // console.log('AgoraComponent.MessageService.out$.RequestPeerInfo', message);
          message.type = MessageType.RequestPeerInfoResult;
          message.clientInfo = {
            role: StateService.state.role,
            name: StateService.state.name,
            uid: StateService.state.uid,
            screenUid: StateService.state.screenUid,
            controllingId: StateService.state.controlling,
            mode: StateService.state.mode
          };
          MessageService.sendBack(message);
          /*
          if (this.isSelfServiceSupport) {
          	this.meetingUrl.support = false; // !!! spostare su ChannelMembers
          	ToastService.open$({
          		message: LabelPipe.transform('bhere_support_request_sent'),
          		type: ToastType.Alert, position: ToastPosition.BottomRight
          	});
          }
          */

          break;

        /*
        case MessageType.RequestPeerInfoResult:
        if (this.isSelfServiceProposition && message.clientInfo.role === RoleType.Publisher) {
        	this.openSupportRequestDialog(message.clientInfo);
        }
        break;
        */

        case MessageType.SupportRequestAccepted:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_accepted'),
            type: ToastType.Alert,
            position: ToastPosition.BottomRight
          });
          break;

        case MessageType.SupportRequestRejected:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_rejected'),
            type: ToastType.Alert,
            position: ToastPosition.BottomRight
          });
          break;

        case MessageType.RequestControl:
          // console.log('AgoraComponent', 'MessageType.RequestControlAccepted');
          message.type = MessageType.RequestControlAccepted;
          MessageService.sendBack(message);
          StateService.patchState({
            controlling: message.controllingId
          });

          if (this.agora) {
            this.agora.sendControlRemoteRequestInfo(message.controllingId);
          }

          break;

        case MessageType.RemoteSilencing:
          StateService.patchState({
            silencing: message.silencing
          });
          this.setAudio(message.silencing);
          break;

        case MessageType.NavToView:
          this.onRemoteNavTo(message);
          break;

        case MessageType.Mode:
          StateService.patchState({
            mode: message.mode
          });
          window.dispatchEvent(new Event('resize'));
          break;

        case MessageType.NavInfo:
          this.hidePanels();
          StateService.patchState({
            showNavInfo: message.showNavInfo
          });
          break;

        case MessageType.AddLike:
          ViewService.setViewLike$(message).pipe(operators.first()).subscribe(view => this.showLove(view));
          break;

        case MessageType.ChatMessage:
          if (!StateService.state.chat) {
            StateService.patchState({
              chatDirty: true
            });
          }

          break;
      }
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      if (this.agora) {
        this.agora.sendMessage(message);
      }
    });
    this.fullscreen$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();

    if (this.agora && StateService.state.status === AgoraStatus.ShouldConnect) {
      this.loadAndConnect();
    }
  }

  onChecked(checklist) {
    // console.log('AgoraComponent.onChecked', checklist);
    StateService.patchState({
      checklist: true
    });
    this.setNextStatus();
  }

  onLink(link) {
    const meetingId = new MeetingId(link); // console.log('onLink', meetingId);

    const pathId = meetingId.pathId;
    const role = this.getLinkRole();
    const mode = UserService.getMode(role);
    const user = StateService.state.user;

    if ((role === RoleType.Publisher || role === RoleType.Attendee) && (!user.id || user.type !== role)) {
      StateService.patchState({
        link,
        pathId,
        role,
        mode,
        status: AgoraStatus.Login
      });
    } else if (StateService.state.name) {
      if (role === RoleType.Viewer || role === RoleType.SmartDevice) {
        StateService.patchState({
          link,
          pathId,
          role,
          mode
        });
        this.loadAndConnect();
      } else {
        StateService.patchState({
          link,
          pathId,
          role,
          mode,
          status: AgoraStatus.Device
        });
      }
    } else {
      StateService.patchState({
        link,
        pathId,
        role,
        mode,
        status: AgoraStatus.Name
      });
    }
  }

  onLogin(user) {
    const name = this.getName(user);

    if (name) {
      StateService.patchState({
        user,
        name,
        status: AgoraStatus.Device
      });
    } else {
      StateService.patchState({
        user,
        status: AgoraStatus.Name
      });
    }
  }

  onName(name) {
    if (StateService.state.role === RoleType.Viewer || StateService.state.role === RoleType.SmartDevice) {
      StateService.patchState({
        name
      });
      this.loadAndConnect();
    } else {
      StateService.patchState({
        name,
        status: AgoraStatus.Device
      });
    }
  }

  onEnter(preferences) {
    this.loadAndConnect(preferences);
  }

  connect(preferences) {
    // console.log('AgoraComponent.connect', preferences);
    this.agora.connect$(preferences).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    const state = this.state; // console.log('AgoraComponent.connect', this.state.role);

    if (state.role === RoleType.SelfService) {
      GtmService.push({
        action: 'b-here-tour',
        userType: state.role
      });
    } else if (state.role === RoleType.Embed) {
      GtmService.push({
        action: 'b-here-embed',
        userType: state.role
      });
    } else {
      const meetingUrl = new MeetingUrl();
      const sharedMeetingId = state.link.replace(/-\d+-/, '-');
      const log = {
        meetingId: state.link,
        sharedMeetingId: sharedMeetingId,
        userType: state.role
      };

      if (environment.flags.useExtendedUserInfo) {
        // !!! update server side logic to use extended user info
        log.firstName = meetingUrl.firstName;
        log.lastName = meetingUrl.lastName;
        log.email = meetingUrl.email;
      } else {
        log.fullName = state.name;
      } // console.log('AgoraComponent.connect', log);


      UserService.log$(log).pipe(operators.first()).subscribe(); // do not share user data in gtm

      GtmService.push({
        action: 'b-here-meeting',
        meetingId: state.link,
        sharedMeetingId: sharedMeetingId,
        userType: state.role
      });
    }
  }

  disconnect() {
    if (this.agora) {
      this.agora.leaveChannel().then(() => {
        // StateService.patchState({ status: AgoraStatus.Disconnected, connected: false });
        // window.location.href = window.location.href;
        // window.location.replace(window.location.href);
        window.location.reload();
      }, console.log);
    } else {
      this.patchState({
        connecting: false,
        connected: false
      });
    }
  }

  onNavTo(item) {
    const viewId = item.viewId;
    const view = this.pathViews.find(x => x.id === viewId);

    if (view) {
      // console.log('AgoraComponent.onNavTo', item, view);
      ViewService.action = {
        viewId,
        keepOrientation: item.keepOrientation,
        useLastOrientation: item.useLastOrientation
      };
      this.onHandleHook(view, item);
    }
  }

  onNavLink(event) {
    // console.log('AgoraComponent.onNavLink', event.link.href);
    ModalService.open$({
      iframe: event.link.href
    }).pipe(operators.first()).subscribe(_ => {
      MessageService.send({
        type: MessageType.NavLinkClose,
        itemId: event.item.id
      });
    });
  }

  onRemoteNavTo(message) {
    const viewId = message.viewId;
    const gridIndex = message.gridIndex;

    if (viewId && ViewService.viewId !== viewId) {
      const view = this.pathViews.find(x => x.id === viewId);

      if (view) {
        // console.log('AgoraComponent.onRemoteNavTo', message, view);
        ViewService.action = {
          viewId,
          keepOrientation: message.keepOrientation,
          useLastOrientation: message.useLastOrientation
        };

        if (gridIndex != null && view instanceof PanoramaGridView) {
          view.index = gridIndex;
        }
      } // console.log('AgoraComponent.onRemoteNavTo', viewId, gridIndex);

    }
  }

  onHandleHook(view, item) {
    switch (item.hook) {
      case 'ToggleWishlist':
        const payload = {
          viewId: view.id,
          itemId: item.id
        };
        WishlistService.toggle$(payload).pipe(operators.switchMap(items => {
          payload.added = WishlistService.has(payload);
          return WebhookService.send$(item.hook, payload, item.extra);
        }), operators.first()).subscribe(response => {
          console.log('AgoraComponent.onHandleHook', response);
          item.added = payload.added;
          this.pushChanges();
        });
        break;
    }
  } // !!! why locally?


  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.pushChanges(); // console.log(this.state);
  }

  toggleCamera() {
    if (this.agora) {
      this.agora.toggleCamera();
    } else {
      this.patchState({
        cameraMuted: !this.state.cameraMuted
      });
    }
  }

  toggleAudio() {
    if (this.agora) {
      this.agora.toggleAudio();
    } else {
      this.patchState({
        audioMuted: !this.state.audioMuted
      });
    }
  }

  setAudio(audioMuted) {
    if (this.agora) {
      this.agora.setAudio(audioMuted);
    } else {
      this.patchState({
        audioMuted
      });
    }
  }

  toggleScreen() {
    if (this.agora) {
      this.agora.toggleScreen();
    } else {
      this.patchState({
        screen: !this.state.screen
      });
    }

    window.dispatchEvent(new Event('resize'));
  }

  toggleVolume() {
    const volumeMuted = !this.state.volumeMuted;
    StateService.patchState({
      volumeMuted
    });
    const selfServiceAudio = this.selfServiceAudio;

    if (selfServiceAudio) {
      selfServiceAudio.volume = volumeMuted ? 0 : 0.5;
    }
  }

  toggleMode() {
    if (this.agora && StateService.state.role === RoleType.Publisher) {
      this.agora.toggleMode();
    } else {
      const mode = this.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
      StateService.patchState({
        mode
      }); // this.patchState({ mode });
    }

    window.dispatchEvent(new Event('resize'));
  }

  toggleFullScreen() {
    const {
      node
    } = rxcomp.getContext(this);
    const fullScreen = !this.state.fullScreen;

    if (fullScreen) {
      if (node.requestFullscreen) {
        node.requestFullscreen();
      } else if (node.webkitRequestFullscreen) {
        node.webkitRequestFullscreen();
      } else if (node.msRequestFullscreen) {
        node.msRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    } // StateService.patchState({ fullScreen });

  }

  fullscreen$() {
    return rxjs.fromEvent(document, 'fullscreenchange').pipe(operators.tap(_ => {
      const fullScreen = document.fullscreenElement != null; // console.log('fullscreen$', fullScreen);

      StateService.patchState({
        fullScreen
      });
    }));
  }

  toggleChat() {
    StateService.patchState({
      chat: !StateService.state.chat,
      chatDirty: false
    });
    window.dispatchEvent(new Event('resize'));
  }

  onChatClose() {
    StateService.patchState({
      chat: false
    });
    window.dispatchEvent(new Event('resize'));
  }

  toggleNavInfo() {
    this.hidePanels();

    if (this.agora) {
      this.agora.toggleNavInfo();
    } else {
      this.patchState({
        showNavInfo: !this.state.showNavInfo
      });
    }
  }

  onBack() {
    // console.log('AgoraCompoent.onBack');
    if (this.previousView && this.view && this.previousView.id !== this.view.id) {
      ViewService.action = {
        viewId: this.previousView.id,
        useLastOrientation: true
      };
    }
  }

  hidePanels() {
    this.view.items.forEach(item => item.showPanel = false);
  }

  onToggleControl(remoteId) {
    if (this.agora) {
      this.agora.toggleControl(remoteId);
    } else {
      const controlling = this.state.controlling === remoteId ? null : remoteId;
      this.patchState({
        controlling,
        spying: false
      });
    }
  }

  onToggleSilence() {
    if (this.agora) {
      this.agora.toggleSilence();
    } else {
      this.patchState({
        silencing: !this.state.silencing
      });
    }
  }

  onToggleSpy(remoteId) {
    if (this.agora) {
      this.agora.toggleSpy(remoteId);
    } else {
      const spying = this.state.spying === remoteId ? null : remoteId;
      this.patchState({
        spying,
        controlling: false
      });
    }
  }

  addLike() {
    ViewService.viewLike$(this.view).pipe(operators.first()).subscribe(view => {
      if (view) {
        this.view.liked = true; // view.liked;

        this.showLove(view); // this.view.likes = view.likes;
        // this.pushChanges();

        MessageService.send({
          type: MessageType.AddLike,
          viewId: this.view.id,
          likes: this.view.likes
        });
      }
    });
  }

  showLove(view) {
    if (view && this.view.id === view.id) {
      const skipTimeout = this.view.showLove;
      this.view.likes = view.likes;
      this.view.showLove = true;
      this.pushChanges();

      if (!skipTimeout) {
        setTimeout(() => {
          this.view.showLove = false;
          this.pushChanges();
        }, 3100);
      }
    }
  }

  tryInAr() {
    if (this.platform === DevicePlatform.IOS || this.platform === DevicePlatform.Android) {
      TryInARModalComponent.openInAR(this.view);
    } else {
      ModalService.open$({
        template: TryInARModalComponent.chunk(),
        data: this.view
      }).pipe(operators.first()).subscribe(event => {// this.pushChanges();
      });
    }
  }

  checkSelfServiceProposition() {
    // self service proposition
    const isSelfServiceProposition = this.isSelfServiceProposition; // console.log('AgoraComponent.initAgora', isSelfServiceProposition);

    if (isSelfServiceProposition) {
      AgoraChecklistService.check$().pipe(operators.first()).subscribe(event => {
        const meetingId = new MeetingId({
          pathId: StateService.state.pathId
        });
        const meetingIdRoles = meetingId.toRoles();
        const meetingUrl = new MeetingUrl({
          link: meetingIdRoles.id,
          support: true
        });
        const href = window.location.origin + meetingUrl.toGuidedTourUrl();
        console.log('AgoraComponent.initAgora.isSelfServiceProposition', href);
        UserService.selfServiceSupportRequest$(StateService.state.user, meetingIdRoles.id, href).pipe(operators.first()).subscribe(_ => {
          const name = this.getName(StateService.state.user);
          StateService.patchState({
            checklist: true,
            link: meetingIdRoles.idSelfService,
            name
          });
          this.agora = AgoraService.getSingleton();
          this.connect();
        });
      }, error => {
        console.log('AgoraComponent.initAgora.isSelfServiceProposition.error', error, name);
        /*
        UserService.selfServiceTourSupportFailedRequest$(StateService.state.user).pipe(
        	first(),
        ).subscribe();
        */
      });
    }
  }

  checkSelfServiceAudio() {
    if (StateService.state.role === RoleType.SelfService && environment.selfServiceAudio) {
      const selfServiceAudio = document.createElement('audio');
      selfServiceAudio.setAttribute('playsinline', 'true');
      selfServiceAudio.setAttribute('autoplay', 'true');
      selfServiceAudio.setAttribute('loop', 'true');
      selfServiceAudio.volume = 0.5;
      selfServiceAudio.src = environment.getPath(environment.selfServiceAudio);
      const {
        node
      } = rxcomp.getContext(this);
      node.parentNode.appendChild(selfServiceAudio);
      this.selfServiceAudio = selfServiceAudio;
      MediaLoader.events$.pipe(operators.tap(event => {
        // console.log('AgoraComponent.checkSelfServiceAudio MediaLoader.event$', event);
        if (event instanceof MediaLoaderPlayEvent) {
          selfServiceAudio.pause(); // selfServiceAudio.volume = 0;
        } else if (event instanceof MediaLoaderPauseEvent || event instanceof MediaLoaderDisposeEvent) {
          selfServiceAudio.play(); // selfServiceAudio.volume = 0.5;
        }
      }), operators.takeUntil(this.unsubscribe$)).subscribe();
    }
  }

  openSupportRequestDialog(clientInfo) {
    ToastService.open$({
      message: LabelPipe.transform('bhere_support_request_dialog'),
      acceptMessage: LabelPipe.transform('bhere_support_request_dialog_accept'),
      rejectMessage: LabelPipe.transform('bhere_support_request_dialog_reject'),
      type: ToastType.Dialog,
      position: ToastPosition.BottomRight
    }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      if (event instanceof ToastResolveEvent) {
        MessageService.send({
          type: MessageType.SupportRequestAccepted
        });
        const name = StateService.state.name;
        const meetingId = new MeetingId(StateService.state.link);
        meetingId.role = RoleType.Streamer;
        const options = {
          link: meetingId.toString()
        };

        if (environment.flags.useExtendedUserInfo) {
          const user = StateService.state.user;
          options.firstName = user.firstName;
          options.lastName = user.lastName;
          options.email = user.email;
        } else {
          options.name = name;
        }

        const meetingUrl = new MeetingUrl(options);
        const href = meetingUrl.toGuidedTourUrl();
        setTimeout(() => {
          window.location.href = href;
        }, 1000);
      } else {
        MessageService.send({
          type: MessageType.SupportRequestRejected
        });
      }
    });
    /*
    ModalService.open$({ template: SupportRequestModalComponent.chunk(), data: clientInfo }).pipe(
    	first(),
    ).subscribe(event => {
    	if (event instanceof ModalResolveEvent) {
    		MessageService.send({ type: MessageType.SupportRequestAccepted });
    		const name = StateService.state.name;
    		const meetingId = new MeetingId(StateService.state.link);
    		meetingId.role = RoleType.Streamer;
    		const meetingUrl = new MeetingUrl({ link: meetingId.toString(), name });
    		const href = meetingUrl.toGuidedTourUrl();
    		setTimeout(() => {
    			window.location.href = href;
    		}, 1000);
    	} else {
    		MessageService.send({ type: MessageType.SupportRequestRejected });
    	}
    });
    */
  }
  /*
  onPrevent(event) {
  	event.preventDefault();
  	event.stopImmediatePropagation();
  }
  */


}
AgoraComponent.meta = {
  selector: '[agora-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template:
  /* html */
  `
	<div class="page page--agora">
		${CHUNK_BACKGROUND}
		<!-- Status Checklist -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'checklist'" [agora-checklist] (checked)="onChecked($event)"></div>
		<!-- Status Link -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'link'" [agora-link] (link)="onLink($event)"></div>
		<!-- Status Login -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'login'" [agora-login] (login)="onLogin($event)"></div>
		<!-- Status Name -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'name' || (state.status == 'disconnected' && state.role === 'viewer')" [agora-name] (name)="onName($event)"></div>
		<!-- Status Device -->
		<div class="ui ui--info" *if="state.status == 'device' || (state.status == 'disconnected' && state.role !== 'viewer')" [agora-device] (enter)="onEnter($event)"></div>
		${CHUNK_VIRTUAL_TOUR}
		${CHUNK_SMART_DEVICE}
		${CHUNK_SELF_SERVICE_TOUR}
		${CHUNK_EMBED}
		<header>
			${CHUNK_LOGO}
			${CHUNK_LANGUAGE}
		</header>
		<footer *if="state.status != 'connected'">
			<span class="group--colophon">
				${CHUNK_CREDITS}
				${CHUNK_COPYRIGHT}
			</span>
			<a [routerLink]="':lang.editor' | route" class="btn--absolute" *if="('editor' | flag) && !('deployed' | flag) && state.role == 'publisher' && (state.status == 'checklist' || state.status == 'link')">
				<span [innerHTML]="'bhere_editor' | label"></span> <svg class="edit" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#edit"></use></svg>
			</a>
		</footer>
	</div>
	`
};class AssetService {
  static assetCreate$(asset) {
    return HttpService.post$(`/api/asset`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }

  static assetUpdate$(asset) {
    return HttpService.put$(`/api/asset/${asset.id}`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }

  static assetDelete$(asset) {
    if (asset && asset.id) {
      return HttpService.delete$(`/api/asset/${asset.id}`).pipe(operators.map(() => null));
    } else {
      return rxjs.of(null);
    }
  }

  static localizedAssetCreate$(lg, asset) {
    return HttpService.post$(`/api/${lg}/asset`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }

  static localizedAssetUpdate$(lg, asset) {
    return HttpService.put$(`/api/${lg}/asset/${asset.id}`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }

  static upload$(files) {
    const formData = new FormData();
    files.forEach(file => formData.append('file', file, file.name));
    const xhr = new XMLHttpRequest();
    const events$ = rxjs.merge(rxjs.fromEvent(xhr.upload, 'loadstart'), rxjs.fromEvent(xhr.upload, 'progress'), rxjs.fromEvent(xhr.upload, 'load'), rxjs.fromEvent(xhr, 'readystatechange')).pipe(operators.map(event => {
      switch (event.type) {
        case 'readystatechange':
          if (xhr.readyState === 4) {
            return JSON.parse(xhr.responseText);
          } else {
            return null;
          }

        default:
          return null;
      }
    }), operators.filter(event => event !== null));
    xhr.open('POST', `/api/upload/`, true);
    xhr.send(formData);
    return events$;
  }

  static createOrUpdateAsset$(uploads, control) {
    const upload = uploads[0];
    const asset = Asset.fromUrl(upload.url);

    if (control.value && control.value.id) {
      // !!! must check for id
      asset.id = control.value.id;
      return AssetService.assetUpdate$(asset);
    } else {
      return AssetService.assetCreate$(asset);
    }
  }

  static createOrUpdateLocalizedAsset$(uploads, control, lg) {
    const upload = uploads[0];
    const asset = Asset.fromUrl(upload.url);

    if (control.value && control.value.id) {
      // !!! must check for id
      asset.id = control.value.id;
      return AssetService.localizedAssetUpdate$(lg, asset);
    } else {
      return AssetService.localizedAssetCreate$(lg, asset);
    }
  }

  static assetDidChange(previous, current) {
    let previousId = null;
    let previousFile = null;
    let currentId = null;
    let currentFile = null;

    if (previous) {
      previousId = previous.id;
      previousFile = previous.file;
    }

    if (current) {
      currentId = current.id;
      currentFile = current.file;
    }

    return previousId !== currentId || previousFile !== currentFile;
  }

}class EditorService {
  static data$() {
    if (!this.data$_) {
      this.data$_ = HttpService.get$(`/api/view`).pipe(operators.map(data => {
        data.views = data.views.map(view => mapView(view));
        return data;
      }), operators.shareReplay(1));
    }

    return this.data$_;
  }

  static viewIdOptions$() {
    return this.data$().pipe(operators.map(data => {
      const options = data.views.filter(x => x.type.name !== ViewType.WaitingRoom.name).map(view => ({
        id: view.id,
        name: view.name
      }));
      options.unshift({
        id: null,
        name: 'select'
      }); // LabelPipe.transform('select')

      return options;
    }));
  }

  static viewCreate$(view) {
    return HttpService.post$(`/api/view`, view).pipe(operators.map(view => mapView(view)));
  }

  static viewUpdate$(view) {
    return HttpService.put$(`/api/view/${view.id}`, view.payload).pipe(operators.map(view => mapView(view)));
  }

  static viewDelete$(view) {
    return HttpService.delete$(`/api/view/${view.id}`);
  }

  static getTile(view) {
    let tile;

    if (view.type.name === ViewType.PanoramaGrid.name) {
      tile = view.tiles[view.index];
    }

    return tile;
  }

  static inferItemCreate$(view, item) {
    const tile = this.getTile(view);

    if (tile) {
      return this.tileItemCreate$(view, tile, item);
    } else {
      return this.itemCreate$(view, item);
    }
  }

  static inferItemUpdate$(view, item) {
    const tile = this.getTile(view);

    if (tile) {
      return this.tileItemUpdate$(view, tile, item);
    } else {
      return this.itemUpdate$(view, item);
    }
  }

  static inferItemDelete$(view, item) {
    const tile = this.getTile(view);

    if (tile) {
      return this.tileItemDelete$(view, tile, item);
    } else {
      return this.itemDelete$(view, item);
    }
  }

  static inferItemUpdateResult$(view, item) {
    const tile = this.getTile(view);
    let currentItem;

    if (tile) {
      currentItem = tile.navs.find(i => i.id === item.id);
    } else {
      currentItem = view.items.find(i => i.id === item.id);
    }

    if (currentItem) {
      Object.assign(currentItem, item);
    }
  }

  static inferItemDeleteResult$(view, item) {
    const tile = this.getTile(view);
    let items;

    if (tile) {
      items = tile.navs;
    } else {
      items = view.items;
    }

    if (items) {
      const index = items.indexOf(item);

      if (index !== -1) {
        items.splice(index, 1);
      }

      if (tile) {
        view.updateCurrentItems();
      }
    }
  }

  static itemCreate$(view, item) {
    return HttpService.post$(`/api/view/${view.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }

  static itemUpdate$(view, item) {
    return HttpService.put$(`/api/view/${view.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }

  static itemDelete$(view, item) {
    return HttpService.delete$(`/api/view/${view.id}/item/${item.id}`);
  }

  static tileItemCreate$(view, tile, item) {
    return HttpService.post$(`/api/view/${view.id}/tile/${tile.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }

  static tileItemUpdate$(view, tile, item) {
    return HttpService.put$(`/api/view/${view.id}/tile/${tile.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }

  static tileItemDelete$(view, tile, item) {
    return HttpService.delete$(`/api/view/${view.id}/tile/${tile.id}/item/${item.id}`);
  }

}class CurvedPlaneModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }

    return data;
  }

  get view() {
    let view = null;
    const data = this.data;

    if (data) {
      view = data.view;
    }

    return view;
  }

  get object() {
    const object = new THREE.Object3D();
    const data = this.data;

    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;

      if (spherical) {
        position.normalize().multiplyScalar(20);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }

    return object;
  }

  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.CurvedPlane,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      scale: new rxcompForm.FormControl([1, 1, 1], rxcompForm.RequiredValidator()),
      radius: new rxcompForm.FormControl(35, rxcompForm.RequiredValidator()),
      height: new rxcompForm.FormControl(20, rxcompForm.RequiredValidator()),
      arc: new rxcompForm.FormControl(90, rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('CurvedPlaneModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value); // item.viewId = parseInt(item.viewId);
      // console.log('CurvedPlaneModalComponent.onSubmit', this.view, item);

      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('CurvedPlaneModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('CurvedPlaneModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
CurvedPlaneModalComponent.meta = {
  selector: '[curved-plane-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Curved Plane.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<!-- <div control-text [control]="controls.title" label="Title"></div> -->
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<!--
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.radius" label="Radius" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.height" label="Height" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.arc" label="Arc" [precision]="0" [disabled]="true"></div>
						-->
						<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

CurvedPlaneModalComponent.chunk = () =>
/* html */
`<div class="curved-plane-modal" curved-plane-modal></div>`;class ItemModelModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }

    return data;
  }

  get view() {
    let view = null;
    const data = this.data;

    if (data) {
      view = data.view;
    }

    return view;
  }

  get object() {
    const object = new THREE.Object3D();
    const data = this.data;

    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;

      if (spherical) {
        position.normalize().multiplyScalar(4);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }

    return object;
  }

  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Model,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl([0, 0, 0], rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      // rotation: new FormControl(object.rotation.toArray(), RequiredValidator()), // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([1, 1, 1], rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('ItemModelModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value); // item.viewId = parseInt(item.viewId);
      // console.log('ItemModelModalComponent.onSubmit', this.view, item);

      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('ItemModelModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('ItemModelModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
ItemModelModalComponent.meta = {
  selector: '[item-model-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Model Item.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

ItemModelModalComponent.chunk = () =>
/* html */
`<div class="item-model-modal" item-model-modal></div>`;class MediaModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Media,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('MediaModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      }; // console.log('MediaModalComponent.onSubmit.view', view);

      return EditorService.viewCreate$(view).pipe(operators.switchMap(view => {
        const item = {
          type: ViewItemType.Plane,
          position: [20, 0, 0],
          rotation: [0, -Math.PI / 2, 0],
          scale: [12, 6.75, 1],
          asset: values.asset
        };
        return EditorService.itemCreate$(view, item).pipe(operators.map(item => {
          view.items = [item];
          return view;
        }));
      }), operators.first()).subscribe(response => {
        // console.log('MediaModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('MediaModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
MediaModalComponent.meta = {
  selector: '[media-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Media.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

MediaModalComponent.chunk = () =>
/* html */
`<div class="media-modal" media-modal></div>`;class ModelModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Model,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      model: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('ModelModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      }; // console.log('ModelModalComponent.onSubmit.view', view);

      return EditorService.viewCreate$(view).pipe(operators.switchMap(view => {
        const item = {
          type: ViewItemType.Model,
          asset: values.model
        };
        return EditorService.itemCreate$(view, item).pipe(operators.map(item => {
          view.items = [item];
          return view;
        }));
      }), operators.first()).subscribe(response => {
        // console.log('ModelModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('ModelModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
ModelModalComponent.meta = {
  selector: '[model-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Model View.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
						<div control-model [control]="controls.model" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

ModelModalComponent.chunk = () =>
/* html */
`<div class="model-modal" model-modal></div>`;class NavModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }

    return data;
  }

  get view() {
    let view = null;
    const data = this.data;

    if (data) {
      view = data.view;
    }

    return view;
  }

  get position() {
    let position = null;
    const data = this.data;

    if (data) {
      position = data.hit.position;
    }

    return position;
  }

  get object() {
    const object = new THREE.Object3D();
    const data = this.data;

    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;

      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }

    return object;
  }

  onInit() {
    const object = this.object;
    this.error = null;
    this.useHooks = WebhookService.enabled;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Nav,
      title: null,
      abstract: null,
      viewId: null,
      // new FormControl(null, RequiredValidator()),
      hook: null,
      hookExtra: null,
      keepOrientation: false,
      important: false,
      transparent: false,
      //
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([20, 5, 1], rxcompForm.RequiredValidator()),
      //
      asset: null,
      link: new rxcompForm.FormGroup({
        title: new rxcompForm.FormControl(null),
        href: new rxcompForm.FormControl(null),
        target: '_blank'
      }) // upload: new FormControl(null, RequiredValidator()),
      // items: new FormArray([null, null, null], RequiredValidator()),

    });
    this.controls = form.controls;

    if (WebhookService.enabled) {
      const options = environment.webhook.methods.nav.map(x => ({
        id: x,
        name: x
      }));
      options.unshift({
        id: null,
        name: 'select'
      });
      this.controls.hook.options = options;
    } // !!! mode validator
    // form.addValidators(NavModalValidator(form, this.view));

    /*
    this.controls.viewId.options = [{
    	name: 'Name',
    	id: 2,
    }];
    */


    form.changes$.subscribe(changes => {
      // console.log('NavModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const item = Object.assign({}, this.form.value);
      item.viewId = item.viewId ? parseInt(item.viewId) : this.view.id;

      if (item.link && (!item.link.title || !item.link.href)) {
        item.link = null;
      } // console.log('NavModalComponent.onSubmit', this.view, item);


      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('NavModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.submitted = false; // this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onViewIdDidChange(viewId) {
    // console.log('NavModalComponent.onViewIdDidChange', viewId, this.form.value);
    // const viewId = this.form.value.viewId;
    if (viewId != null && environment.flags.navAutoUpdateTitle) {
      const options = this.controls.viewId.options;
      const selectedOption = options.find(x => x.id === viewId); // console.log('NavModalComponent.onViewIdDidChange', selectedOption, options);

      if (selectedOption != null) {
        const title = selectedOption.name;
        const currentTitle = this.form.value.title; // console.log('NavModalComponent.onViewIdDidChange', title, currentTitle);

        if (!currentTitle || options.find(x => x.name === currentTitle)) {
          this.form.patch({
            title
          });
        }
      }
    }
  }

  onClose() {
    ModalService.reject();
  }

}
NavModalComponent.meta = {
  selector: '[nav-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Nav.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.title" label="Title"></div>
						<div control-textarea [control]="controls.abstract" label="Abstract"></div>
						<div control-custom-select [control]="controls.viewId" label="NavToView" (change)="onViewIdDidChange($event)"></div>
						<div control-checkbox [control]="controls.keepOrientation" label="Keep Orientation"></div>
						<div control-checkbox [control]="controls.important" label="Important"></div>
						<div control-checkbox [control]="controls.transparent" label="Transparent"></div>
						<div control-vector [control]="controls.position" label="Position" [precision]="3" [disabled]="true"></div>
						<div *if="controls.transparent.value == true">
							<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
							<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						</div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/png, image/jpeg"></div>
						<div control-text [control]="controls.link.controls.title" label="Link Title"></div>
						<div control-text [control]="controls.link.controls.href" label="Link Url"></div>
						<div control-custom-select [control]="controls.hook" label="Hook" *if="useHooks"></div>
						<div control-text [control]="controls.hookExtra" label="Hook Extra" *if="useHooks"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

NavModalComponent.chunk = () =>
/* html */
`<div class="nav-modal" nav-modal></div>`;class PanoramaGridModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.PanoramaGrid,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      assets: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PanoramaGridModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true; // console.log('PanoramaGridModalComponent.onSubmit', this.form.value);

      const assets = this.form.value.assets;
      const tiles = PanoramaGridView.mapTiles(assets.map(asset => ({
        asset,
        navs: []
      })), false, true);
      tiles.sort((a, b) => {
        const ai = a.indices.x * 10000 + a.indices.y;
        const bi = b.indices.x * 10000 + b.indices.y;
        return ai - bi;
      }); // console.log('PanoramaGridModalComponent.onSubmit', tiles);

      const asset = tiles[0].asset;
      const view = {
        type: this.form.value.type,
        name: this.form.value.name,
        asset,
        tiles: tiles,
        invertAxes: true,
        flipAxes: false,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      EditorService.viewCreate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('PanoramaGridModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PanoramaGridModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
PanoramaGridModalComponent.meta = {
  selector: '[panorama-grid-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Panorama Grid.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-assets [control]="controls.assets" label="Image" accept="image/jpeg"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

PanoramaGridModalComponent.chunk = () =>
/* html */
`<div class="panorama-grid-modal" panorama-grid-modal></div>`;class PanoramaModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Panorama,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()) // upload: new FormControl(null, RequiredValidator()),
      // items: new FormArray([null, null, null], RequiredValidator()),

    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PanoramaModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      }; // console.log('PanoramaModalComponent.onSubmit.view', view);

      return EditorService.viewCreate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('PanoramaModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PanoramaModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
PanoramaModalComponent.meta = {
  selector: '[panorama-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Panorama.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
					<!--
					<div class="group--form group--form--fixed">
						<code [innerHTML]="form.value | json"></code>
						<button type="button" class="btn--test" (click)="test()"><span>test</span></button>
					</div>
					-->
				</form>
			</div>
		</div>
	`
};

PanoramaModalComponent.chunk = () =>
/* html */
`<div class="panorama-modal" panorama-modal></div>`;class PathAddModalComponent extends rxcomp.Component {
  onInit() {
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }

    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PathAddModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const path = {
        name: values.name,
        items: this.data ? this.data.item.items : []
      }; // console.log('PathAddModalComponent.onSubmit.path', path);

      return PathService.pathCreate$(path).pipe(operators.first()).subscribe(response => {
        // console.log('PathAddModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PathAddModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
PathAddModalComponent.meta = {
  selector: '[path-add-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Add Path.</div>
				<div class="description">Aggiungi un percorso</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

PathAddModalComponent.chunk = () =>
/* html */
`<div class="panorama-modal" path-add-modal></div>`;class PathEditModalComponent extends rxcomp.Component {
  onInit() {
    this.item = null;
    this.views = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      const data = parentInstance.modal.data;

      if (data) {
        this.item = data.item ? data.item : null;
        this.views = this.parseViews(data.views, this.item);
      }
    }

    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(this.item ? this.item.name : null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PathEditModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  parseViews(views, item) {
    if (views && item) {
      return views.map(view => {
        return {
          id: view.id,
          name: view.name,
          type: view.type,
          active: item.items.indexOf(view.id) === -1
        };
      });
    } else {
      return [];
    }
  }

  onToggleView(view) {
    view.active = !view.active;
    this.pushChanges();
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const payload = {
        id: this.item.id,
        name: values.name,
        items: this.views.filter(x => !x.active).map(x => x.id)
      }; // console.log('PathEditModalComponent.onSubmit', payload);

      return PathService.pathUpdate$(payload).pipe(operators.first()).subscribe(response => {
        // console.log('PathEditModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PathEditModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onSelectAll() {
    this.views.forEach(view => view.active = true);
    this.pushChanges();
  }

  onSelectNone() {
    this.views.forEach(view => view.active = false);
    this.pushChanges();
  }

  onClose() {
    ModalService.reject();
  }

}
PathEditModalComponent.meta = {
  selector: '[path-edit-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Edit Path <span *if="item">&ldquo;<span [innerHTML]="item.title || item.name"></span>&rdquo;</span>.</div>
				<div class="description">Modifica il percorso</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
					</div>
					<ul class="nav--flag" *if="views">
						<li class="nav__item" *for="let view of views">
							<button type="button" class="btn--flag" [class]="{ active: view.active }" [title]="view.name" (click)="onToggleView(view)">
								<div class="icon">
									<svg-icon [name]="view.type.name"></svg-icon>
								</div>
								<span class="name" [innerHTML]="view.name"></span>
								<span class="flag">
									<svg class="check" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#check"></use></svg>
									<svg class="close" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
								</span>
							</button>
						</li>
					</ul>
					<div class="group--cta">
						<div class="group--options">
							<button type="button" class="btn--link" (click)="onSelectAll()">
								<span>Select all</span>
							</button>
							<button type="button" class="btn--link" (click)="onSelectNone()">
								<span>Select none</span>
							</button>
						</div>
						<button type="submit" class="btn--accept">
							<span>Save</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

PathEditModalComponent.chunk = () =>
/* html */
`<div class="path-edit-modal" path-edit-modal></div>`;class PlaneModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }

    return data;
  }

  get view() {
    let view = null;
    const data = this.data;

    if (data) {
      view = data.view;
    }

    return view;
  }

  get object() {
    const object = new THREE.Object3D();
    const data = this.data;

    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;

      if (spherical) {
        position.normalize().multiplyScalar(20);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }

    return object;
  }

  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Plane,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([12, 6.75, 1], rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PlaneModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value); // item.viewId = parseInt(item.viewId);
      // console.log('PlaneModalComponent.onSubmit', this.view, item);

      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('PlaneModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('PlaneModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
PlaneModalComponent.meta = {
  selector: '[plane-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Plane.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<!-- <div control-text [control]="controls.title" label="Title"></div> -->
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

PlaneModalComponent.chunk = () =>
/* html */
`<div class="plane-modal" plane-modal></div>`;class RemoveModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }

    return data;
  }

  get item() {
    let item = null;
    const data = this.data;

    if (data) {
      item = data.item;
    }

    return item;
  }

  onRemove() {
    ModalService.resolve();
  }

  onCancel() {
    ModalService.reject();
  }

  onClose() {
    ModalService.reject();
  }

}
RemoveModalComponent.meta = {
  selector: '[remove-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Remove <span *if="item">&ldquo;<span [innerHTML]="item.title || item.name"></span>&rdquo;</span>.</div>
				<div class="abstract">are you sure?</div>
				<div class="group--cta">
					<button type="button" class="btn--remove" (click)="onRemove($event)">
						<span>Remove</span>
					</button>
					<button type="button" class="btn--accept" (click)="onCancel($event)">
						<span>Cancel</span>
					</button>
				</div>
			</div>
		</div>
	`
};

RemoveModalComponent.chunk = () =>
/* html */
`<div class="remove-modal" remove-modal></div>`;class Room3DModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Room3d,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()) // model: new FormControl(null, RequiredValidator()),

    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('Room3DModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      }; // console.log('Room3DModalComponent.onSubmit.view', view);

      return EditorService.viewCreate$(view).pipe(
      /*
      switchMap(view => {
      	const item = {
      		type: ViewItemType.Model,
      		asset: values.model,
      	};
      	return EditorService.itemCreate$(view, item).pipe(
      		map(item => {
      			view.items = [item];
      			return view;
      		})
      	);
      }),
      */
      operators.first()).subscribe(response => {
        // console.log('Room3DModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('Room3DModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
Room3DModalComponent.meta = {
  selector: '[room-3d-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Room 3D View.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<!--
						<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
						<div control-model [control]="controls.model" label="Model (.glb)" accept=".glb"></div>
						-->
						<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

Room3DModalComponent.chunk = () =>
/* html */
`<div class="room-3d-modal" room-3d-modal></div>`;const SETTINGS = {
  menu: [{
    id: 'menu',
    title: 'editor_menu',
    active: true
  }, {
    id: 'navmaps',
    title: 'editor_navmaps',
    active: true
  }],
  current: null,
  active: false
};
class EditorComponent extends rxcomp.Component {
  get dataViews() {
    return ViewService.dataViews;
  }

  get pathViews() {
    return ViewService.pathViews;
  }

  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
    this.settings = this.getSettings();
    this.aside = false;
    this.state = {};
    this.view = null;
    this.paths = null;
    this.path = null;
    this.form = null;
    this.local = null;
    this.remotes = [];
    this.viewHit = new rxjs.Subject();
    const vrService = this.vrService = VRService.getService();
    vrService.status$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(status => this.pushChanges());
    this.resolveUser();
  }

  resolveUser() {
    UserService.me$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(user => {
      if (user && user.type === RoleType.Publisher) {
        this.user = user;
        this.initState();
      } else {
        RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
      }
    });
  }

  initState() {
    const user = this.user;
    const role = user.type;
    const name = user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : null;
    const state = {
      user: user,
      role: role,
      name: name,
      mode: UIMode.VirtualTour,
      link: null,
      channelName: environment.channelName,
      uid: null,
      status: AgoraStatus.Connected,
      connecting: false,
      connected: true,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: true,
      live: false,
      navigable: true,
      cameraMuted: false,
      audioMuted: false,
      showNavInfo: true
    };
    StateService.state = state;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.hosted = state.hosted;
      this.pushChanges();
    });
    this.viewObserver$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(view => {// console.log('EditorComponent.viewObserver$', view);
    });
    StreamService.mode = StreamServiceMode.Editor; // this.getUserMedia();
  }

  viewObserver$() {
    return EditorService.data$().pipe(operators.switchMap(data => {
      // console.log('viewObserver$', data);
      const meetingUrl = new MeetingUrl();
      const pathId = meetingUrl.pathId;
      return PathService.getCurrentPath$(pathId).pipe(operators.switchMap(path => {
        this.paths = PathService.paths;
        this.path = path;
        return ViewService.editorView$(data, path);
      }));
    }), operators.tap(view => {
      this.view = null;
      this.pushChanges();
    }), operators.delay(1), operators.tap(view => {
      // console.log('EditorComponent.viewObserver$', view, ViewService.pathViews, ViewService.dataViews);
      this.view = view;
      this.pushChanges();
    }));
  }

  onAddPath() {
    // console.log('EditorComponent.onAddPath');
    ModalService.open$({
      template: PathAddModalComponent.chunk()
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.addPath(event.data);
      }
    });
  }

  onEditPath(item) {
    // console.log('EditorComponent.onEditPath', item);
    ModalService.open$({
      template: PathEditModalComponent.chunk(),
      data: {
        item: item,
        views: ViewService.validViews
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.editPath(event.data);
      }
    });
  }

  onDuplicatePath(item) {
    // console.log('EditorComponent.onDuplicatePath', item);
    ModalService.open$({
      template: PathAddModalComponent.chunk(),
      data: {
        item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.addPath(event.data);
      }
    });
  }

  onDeletePath(item) {
    // console.log('EditorComponent.onDeletePath', item);
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.pathDelete$(item).pipe(operators.first()).subscribe(_ => {
          PathService.deletePath(item);
        });
      }
    });
  }

  onSelectPath(item) {
    // console.log('EditorComponent.onSelectPath', item);
    PathService.path = item;
  }

  isPathSelected(item) {
    // console.log('EditorComponent.isPathSelected', item);
    return PathService.path.id === item.id;
  }

  onNavTo(item) {
    // console.log('EditorComponent.onNavTo', item);
    const viewId = item.viewId;
    const view = ViewService.pathViews.find(x => x.id === viewId);

    if (view) {
      ViewService.action = {
        viewId,
        keepOrientation: item.keepOrientation,
        useLastOrientation: item.useLastOrientation
      };
    }
  }

  onNavLink(event) {
    // console.log('EditorComponent.onNavLink', event);
    ModalService.open$({
      iframe: event.link.href
    }).pipe(operators.first()).subscribe(_ => {
      MessageService.send({
        type: MessageType.NavLinkClose,
        itemId: event.item.id
      });
    });
  }

  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.pushChanges(); // console.log(this.state);
  }

  tryInAr() {
    ModalService.open$({
      template: TryInARModalComponent.chunk(),
      data: this.view
    }).pipe(operators.first()).subscribe(event => {// this.pushChanges();
    });
  }

  onToggleAside() {
    this.aside = !this.aside;
    this.pushChanges();
    window.dispatchEvent(new Event('resize'));
  }

  getSettings() {
    const settings = Object.assign({}, SETTINGS);
    settings.menu = settings.menu.filter(x => environment.flags[x.id]);
    settings.current = settings.menu.length ? settings.menu[0].id : null;
    return settings;
  }

  onToggleSettings() {
    const settings = this.settings;
    settings.active = !settings.active;
    this.pushChanges();
  }

  onSelectSetting(item) {
    this.settings.current = item.id;
    this.pushChanges();
  } // editor


  onViewHit(event) {
    // console.log('onViewHit');
    this.viewHit.next(event);
  }

  onViewHitted(callback) {
    if (this.viewHitSubscription) {
      this.viewHitSubscription.unsubscribe();
      this.viewHitSubscription = null;
    }

    if (typeof callback === 'function') {
      this.viewHitSubscription = this.viewHit.pipe(operators.first()).subscribe(event => callback(event));
    }
  }

  onDragEnd(event) {
    EditorService.inferItemUpdate$(this.view, event.item).pipe(operators.first()).subscribe(response => {
      // console.log('EditorComponent.onDragEnd.inferItemUpdate$.success', response);
      this.pushChanges();
    }, error => console.log('EditorComponent.onDragEnd.inferItemUpdate$.error', error, this.view, event.item, event.item.payload));
  }

  onResizeEnd(event) {// console.log('EditorComponent.onResizeEnd');

    /*
    EditorService.inferItemUpdate$(this.view, event.item).pipe(
    	first(),
    ).subscribe(response => {
    	// console.log('EditorComponent.onResizeEnd.inferItemUpdate$.success', response);
    	this.pushChanges();
    }, error => console.log('EditorComponent.onResizeEnd.inferItemUpdate$.error', error));
    */
  }

  onWorldSelect(event) {
    // console.log('EditorComponent.onWorldSelect', this.view);
    if (this.view) {
      let selectedItem;
      this.view.items.forEach(item => item.showPanel = false);
      this.view.items.forEach(item => {
        item.selected = item === event.item;
        selectedItem = item.selected ? item : selectedItem;
      });
      this.view.selected = !selectedItem;
      this.pushChanges();

      if (selectedItem) {
        this.aside = true;
        this.pushChanges();
        window.dispatchEvent(new Event('resize'));
      }
    }
  }

  onOpenModal(modal, data) {
    let template = null;

    switch (modal.type) {
      case 'view':
        switch (modal.value) {
          case ViewType.Panorama.name:
            template = PanoramaModalComponent.chunk();
            break;

          case ViewType.PanoramaGrid.name:
            template = PanoramaGridModalComponent.chunk();
            break;

          case ViewType.Model.name:
            template = ModelModalComponent.chunk();
            break;

          case ViewType.Room3d.name:
            template = Room3DModalComponent.chunk();
            break;

          case ViewType.Media.name:
            template = MediaModalComponent.chunk();
            break;
        }

        break;

      case 'viewItem':
        switch (modal.value) {
          case ViewItemType.Nav.name:
            template = NavModalComponent.chunk();
            break;

          case ViewItemType.Plane.name:
            template = PlaneModalComponent.chunk();
            break;

          case ViewItemType.CurvedPlane.name:
            template = CurvedPlaneModalComponent.chunk();
            break;

          case ViewItemType.Model.name:
            template = ItemModelModalComponent.chunk();
            break;
        }

        break;
    }

    if (!template) {
      return;
    }

    ModalService.open$({
      template,
      data
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        // console.log('EditorComponent.onOpenModal.resolve', event);
        switch (modal.type) {
          case 'view':
            switch (modal.value) {
              case ViewType.Panorama.name:
              case ViewType.PanoramaGrid.name:
              case ViewType.Model.name:
              case ViewType.Room3d.name:
              case ViewType.Media.name:
                ViewService.addView(event.data);
                break;
            }

            break;

          case 'viewItem':
            switch (modal.value) {
              case ViewItemType.Nav.name:
              case ViewItemType.Plane.name:
              case ViewItemType.CurvedPlane.name:
              case ViewItemType.Model.name:
                const item = event.data; // Object.assign({}, event.data);

                const tile = EditorService.getTile(this.view);

                if (tile) {
                  const navs = tile.navs || [];
                  navs.push(item);
                  tile.navs = navs;
                  this.view.updateCurrentItems();
                } else {
                  item.path = true;
                  const items = this.view.items || [];
                  items.push(item);
                  this.view.items = items;
                }

                this.pushChanges();
                break;
            }

            break;
        }
      }

      this.pushChanges();
    });
  }

  onAsideSelect(event) {
    // console.log('onAsideSelect', event);
    if (event.value) {
      switch (event.value) {
        case ViewItemType.Nav.name:
        case ViewItemType.Plane.name:
        case ViewItemType.CurvedPlane.name:
          this.onViewHitted(hit => {
            this.onOpenModal(event, {
              view: this.view,
              hit
            });
          });
          ToastService.open$({
            message: 'Click a point on the view'
          });
          break;

        case ViewItemType.Model.name:
          if (event.type === 'viewItem') {
            if (this.view.type.name === ViewType.Model.name) {
              return;
            }

            this.onViewHitted(hit => {
              this.onOpenModal(event, {
                view: this.view,
                hit
              });
            });
            ToastService.open$({
              message: 'Click a point on the view'
            });
          } else {
            this.onOpenModal(event, {
              view: this.view
            });
          }

          break;

        default:
          this.onOpenModal(event, {
            view: this.view
          });
      }
    } else if (event.view && (event.item || event.item === null)) {
      event.view.selected = false;
      event.view.items.forEach(item => item.selected = item === event.item);
      MessageService.send({
        type: MessageType.SelectItem
      });
      this.pushChanges();
    } else if (event.view && (event.tile || event.tile === null)) {
      event.view.selected = false;
      event.view.tiles.forEach(tile => tile.selected = tile === event.tile);
      MessageService.send({
        type: MessageType.SelectItem
      });
      /*
      // if tile selected
      // send ChangeTile message to world component
      this.orbitService.walk(event.position, (headingLongitude, headingLatitude) => {
      	const item = this.view.getTile(event.indices.x, event.indices.y);
      	if (item) {
      		this.panorama.crossfade(item, this.renderer, (envMap, texture, rgbe) => {
      			// this.scene.background = envMap;
      			this.scene.environment = envMap;
      			this.orbitService.walkComplete(headingLongitude, headingLatitude);
      			// this.render();
      			// this.pushChanges();
      		});
      	}
      });
      */

      this.pushChanges();
    } else if (event.view || event.view === null) {
      this.view.selected = this.view === event.view;
      this.view.items.forEach(item => item.selected = false);
      const currentTile = EditorService.getTile(this.view);

      if (currentTile) {
        this.view.tiles.forEach(tile => tile.selected = tile === currentTile);
      }

      MessageService.send({
        type: MessageType.SelectItem
      });
      this.pushChanges();
    }
  }

  onAsideUpdate(event) {
    // console.log('onAsideUpdate', event);
    if (event.item && event.view) {
      this.pushChanges();
    } else if (event.tile && event.view) ; else if (event.view) {
      if (ViewService.viewId !== event.view.id) {
        ViewService.viewId = event.view.id;
      } else {
        const assetDidChange = AssetService.assetDidChange(this.view.asset, event.view.asset);
        Object.assign(this.view, event.view);

        if (assetDidChange) {
          if (typeof this.view.onUpdateAsset === 'function') {
            this.view.onUpdateAsset();
          }
        }

        this.pushChanges();
      }
    }
  }

  onAsideDelete(event) {
    // console.log('onAsideDelete', event);
    if (event.item && event.view) {
      EditorService.inferItemDelete$(event.view, event.item).pipe(operators.first()).subscribe(response => {
        // console.log('EditorComponent.onAsideDelete.inferItemDelete$.success', response);
        EditorService.inferItemDeleteResult$(event.view, event.item);
        this.pushChanges();
      }, error => console.log('EditorComponent.onAsideDelete.inferItemDelete$.error', error));
    } else if (event.view) {
      EditorService.viewDelete$(event.view).pipe(operators.first()).subscribe(response => {
        // console.log('EditorComponent.onAsideDelete.viewDelete$.success', response);
        ViewService.deleteView(event.view);
      }, error => console.log('EditorComponent.onAsideDelete.viewDelete$.error', error));
    }
  }

}
EditorComponent.meta = {
  selector: '[editor-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template:
  /* html */
  `
	<div class="page page--editor">
		<div class="ui" [class]="{ open: aside }" *if="dataViews.length">
			<div class="ui__navbar">
				<div class="btn--settings" [class]="{ active: settings.active }" (click)="onToggleSettings($event)" *if="settings.menu.length > 0">
					<svg class="settings" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#settings-full"></use></svg>
				</div>
				<div class="headline" *if="view">
					<div class="headline__id" [innerHTML]="view.id"></div>
					<div class="headline__icon">
						<svg-icon [name]="view.type.name"></svg-icon>
					</div>
					<div class="headline__name" [innerHTML]="view.name"></div>
				</div>
				<div class="group--path" *if="('usePaths' | flag) && path">
					<div class="group--path__select">
						<div class="group--form--select" [dropdown]="'path'">
							<label>Percorso</label>
							<span class="control--custom-select" [innerHTML]="path.name"></span>
							<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
						</div>
						<div class="dropdown dropdown-item" [dropdown-item]="'path'">
							<div class="category">Percorso</div>
							<ul class="nav--dropdown">
								<li [class]="{ active: isPathSelected(item) }" *for="let item of paths">
									<span [innerHTML]="item.name" (click)="onSelectPath(item)"></span>
									<div class="check">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#check"></use></svg>
									</div>
									<div class="btn--flags" (click)="onEditPath(item)" title="Edit" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#flags"></use></svg>
									</div>
									<div class="btn--duplicate" (click)="onDuplicatePath(item)" title="Duplicate" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#duplicate"></use></svg>
									</div>
									<div class="btn--trash" (click)="onDeletePath(item)" title="Delete" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#trash"></use></svg>
									</div>
								</li>
							</ul>
							<div class="btn--mode" (click)="onAddPath()">Aggiungi un percorso</div>
						</div>
					</div>
				</div>
				<div class="btn--edit" [class]="{ active: aside }" (click)="onToggleAside($event)">
					<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#edit"></use></svg>
				</div>
			</div>
			<div class="ui__body">
				<div class="world" world [view]="view" [views]="pathViews" [editor]="true" (navTo)="onNavTo($event)" (viewHit)="onViewHit($event)" (dragEnd)="onDragEnd($event)" (select)="onWorldSelect($event)"></div>
			</div>
			<!-- footer -->
			<div class="group--footer">
				<div class="group--ar-vr">
					<button type="button" class="btn--ar" [href]="view?.ar" (click)="tryInAr()" *if="view?.ar">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#ar"></use></svg> <span>Try in AR</span>
					</button>
					<button type="button" class="btn--vr" [class]="{ disabled: vrService.isDisabled() }" (click)="vrService.toggleVR()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#vr"></use></svg> <span [innerHTML]="vrService.getLabel()"></span>
					</button>
				</div>
			</div>
			<div class="ui__settings" *if="settings.active">
				<!-- settings navs -->
				<div class="group--nav">
					<ul class="nav--menu">
						<li class="nav__item" *for="let item of settings.menu" [class]="{ active: settings.current === item.id }" (click)="onSelectSetting(item)"><span class="title" [innerHTML]="item.title | label"></span></li>
					</ul>
				</div>
				<!-- menu -->
				<div class="group--content" menu-builder [views]="dataViews" *if="settings.current === 'menu'"></div>
				<!-- navmaps -->
				<div class="group--content" navmap-builder [views]="dataViews" *if="settings.current === 'navmaps'"></div>
			</div>
		</div>
		<div class="aside" [class]="{ active: aside }" aside [view]="view" (select)="onAsideSelect($event)" (update)="onAsideUpdate($event)" (delete)="onAsideDelete($event)" *if="view && aside"></div>
	</div>
	`
};class GenericService {
  static currentLanguagePage$(key) {
    return LanguageService.lang$.pipe(operators.switchMap(lang => {
      return this.page$(lang, key);
    }));
  }

  static page$(lang, key) {
    const url = environment.flags.production ? `/api/${lang}/pages/${key}/` : `./api/${lang}/pages/${key}.json`;
    return HttpService.get$(url);
  }

}class GenericComponent extends rxcomp.Component {
  onInit() {
    this.route = this.host ? this.host.route : null;
    this.state = {
      status: 'generic'
    };
    this.page = null;
    GenericService.currentLanguagePage$(this.route.params.mode).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(page => {
      this.page = page;
      this.pushChanges();
    });
  }

}
GenericComponent.meta = {
  selector: '[generic-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template:
  /*html*/
  `
		<div class="page page--generic">
			<!-- generic -->
			<div class="ui ui--generic" *if="page">
				<div class="group--generic">
					<div class="group--generic__content stagger--childs">
						<h1 class="title" [innerHTML]="page.title"></h1>
						<div class="description" [innerHTML]="page.description"></div>
					</div>
				</div>
			</div>
			<header>
				${CHUNK_LOGO}
				${CHUNK_LANGUAGE}
			</header>
			<footer>
				<span class="group--colophon" *if="state.status != 'connected'">
					${CHUNK_CREDITS}
					${CHUNK_COPYRIGHT}
				</span>
			</footer>
		</div>
	`
};class LayoutComponent extends rxcomp.Component {
  get meetingUrl() {
    if (!this.meetingUrl_) {
      this.meetingUrl_ = new MeetingUrl();
    }

    return this.meetingUrl_;
  }

  get isVirtualTourUser() {
    return [RoleType.Publisher, RoleType.Attendee, RoleType.Streamer, RoleType.Viewer].indexOf(this.state.role) !== -1;
  }

  get isEmbed() {
    if (this.route) {
      return this.route.params.mode === 'embed';
    }
  }

  get isSelfServiceTour() {
    if (this.route) {
      return this.route.params.mode === 'selfServiceTour';
    }
  }

  get isNavigable() {
    const embedViewId = this.meetingUrl.embedViewId;
    const navigable = embedViewId == null;
    return navigable;
  }

  get isBackButtonVisible() {
    return this.view && (this.view.type.name === ViewType.Media.name || this.view.type.name === ViewType.Model.name);
  }

  get showNavInfoToggler() {
    return environment.flags.hideNavInfo && this.state.mode !== UIMode.LiveMeeting;
  }

  get uiClass() {
    const uiClass = {};
    uiClass[this.state.role] = true; // uiClass[this.state.mode] = true;

    uiClass.chat = this.state.chat;
    uiClass.remotes = this.state.mode === UIMode.LiveMeeting;
    uiClass.remoteScreen = this.remoteScreen != null && !this.hasScreenViewItem;
    uiClass.media = !uiClass.remotes && this.media;
    uiClass.locked = this.locked;
    return uiClass;
  }

  get remoteClass() {
    return `group--remote--${Math.min(9, this.remotes.length)}`;
  }

  get controlled() {
    return this.state.controlling && this.state.controlling !== this.state.uid;
  }

  get controlling() {
    return this.state.controlling && this.state.controlling === this.state.uid;
  }

  get silencing() {
    return StateService.state.silencing;
  }

  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }

  get spyed() {
    return this.state.spying && this.state.spying === this.state.uid;
  }

  get spying() {
    return this.state.spying && this.state.spying !== this.state.uid;
  }

  get locked() {
    return this.controlled || this.spying;
  }

  get remoteScreen() {
    return this.remoteScreen_;
  }

  set remoteScreen(remoteScreen) {
    if (this.remoteScreen_ !== remoteScreen) {
      this.remoteScreen_ = remoteScreen;
      window.dispatchEvent(new Event('resize'));
    }
  }

  onInit() {
    const meetingUrl = this.meetingUrl;
    const embedViewId = meetingUrl.embedViewId;
    this.state = {
      status: LocationService.get('status') || AgoraStatus.Connected,
      role: LocationService.get('role') || RoleType.Publisher,
      // Publisher, Attendee, Streamer, Viewer, SmartDevice, SelfService, Embed
      membersCount: 3,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: true,
      chat: false,
      chatDirty: true,
      name: 'Jhon Appleseed',
      uid: '7341614597544882',
      showNavInfo: true
    };
    this.state.live = this.state.role === RoleType.SelfService || this.state.role === RoleType.Embed || DEBUG ? false : true;
    this.state.navigable = embedViewId == null;
    this.state.mode = UserService.getMode(this.state.role);
    this.view = {
      likes: 41,
      type: {
        id: 2,
        name: 'panorama'
      }
    };
    this.local = {};
    this.screen = null;
    this.remoteScreen_ = null;
    this.media = null;
    this.hasScreenViewItem = false;
    this.media = true;
    this.remotes = new Array(8).fill(0).map((x, i) => ({
      id: i + 1
    }));
    this.languageService = LanguageService;
    this.showLanguages = false;
    StateService.patchState(this.state);
    this.fullscreen$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    this.vrService = VRService.getService();
    console.log('LayoutComponent', this); // console.log(AgoraService.getUniqueUserId());

    setTimeout(() => {
      const type = ToastType.Dialog;

      switch (type) {
        case ToastType.Info:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_sent')
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            }
          });
          break;

        case ToastType.Alert:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_sent'),
            type: type,
            position: ToastPosition.BottomRight
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            } else if (event instanceof ToastRejectEvent) {
              console.log('ToastRejectEvent', event);
            }
          });
          break;

        case ToastType.Dialog:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_dialog'),
            acceptMessage: LabelPipe.transform('bhere_support_request_dialog_accept'),
            rejectMessage: LabelPipe.transform('bhere_support_request_dialog_reject'),
            type: type,
            position: ToastPosition.BottomRight
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            } else if (event instanceof ToastRejectEvent) {
              console.log('ToastRejectEvent', event);
            }
          });
          break;
      }
    }, 3000);
  }

  setLanguage(language) {
    this.languageService.setLanguage$(language).pipe(first()).subscribe(_ => {
      this.showLanguages = false;
      this.pushChanges();
    });
  }

  toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }

  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.screen = this.state.screen || null;
    this.remoteScreen = this.screen;
    this.pushChanges();
  }

  toggleCamera() {
    this.patchState({
      cameraMuted: !this.state.cameraMuted
    });
  }

  toggleAudio() {
    this.patchState({
      audioMuted: !this.state.audioMuted
    });
  }

  toggleScreen() {
    this.patchState({
      screen: !this.state.screen
    });
    window.dispatchEvent(new Event('resize'));
  }

  toggleVolume() {
    this.patchState({
      volumeMuted: !this.state.volumeMuted
    });
  }

  toggleMode() {
    const mode = this.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
    this.patchState({
      mode: mode
    }); // this.pushChanges();
  }

  toggleFullScreen() {
    const {
      node
    } = rxcomp.getContext(this);
    const fullScreen = !this.state.fullScreen;

    if (fullScreen) {
      if (node.requestFullscreen) {
        node.requestFullscreen();
      } else if (node.webkitRequestFullscreen) {
        node.webkitRequestFullscreen();
      } else if (node.msRequestFullscreen) {
        node.msRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    } // this.patchState({ fullScreen });

  }

  fullscreen$() {
    return rxjs.fromEvent(document, 'fullscreenchange').pipe(operators.tap(_ => {
      const fullScreen = document.fullscreenElement != null; // console.log('fullscreen$', fullScreen);

      this.patchState({
        fullScreen
      });
    }));
  }

  toggleChat() {
    this.patchState({
      chat: !this.state.chat,
      chatDirty: false
    });
    window.dispatchEvent(new Event('resize'));
  }

  toggleNavInfo() {
    this.patchState({
      showNavInfo: !this.state.showNavInfo
    });
  }

  onBack() {
    console.log('LayoutComponent.onBack');
  }

  onChatClose() {
    this.patchState({
      chat: false
    });
    window.dispatchEvent(new Event('resize'));
  }

  onToggleControl(remoteId) {
    const controlling = this.state.controlling === remoteId ? null : remoteId;
    this.patchState({
      controlling,
      spying: false
    });
  }

  onToggleSilence() {
    this.patchState({
      silencing: !this.state.silencing
    });
  }

  onToggleSpy(remoteId) {
    const spying = this.state.spying === remoteId ? null : remoteId;
    this.patchState({
      spying,
      controlling: false
    });
  }

  addLike() {
    this.view.liked = true; // view.liked;

    this.showLove(this.view);
  }

  showLove(view) {
    if (view && this.view.id === view.id) {
      const skipTimeout = this.view.showLove;
      this.view.likes = view.likes;
      this.view.showLove = true;
      this.pushChanges();

      if (!skipTimeout) {
        setTimeout(() => {
          this.view.showLove = false;
          this.pushChanges();
        }, 3100);
      }
    }
  }

  disconnect() {}

}
LayoutComponent.meta = {
  selector: '[layout-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template:
  /* html */
  `
	<div class="page page--agora">
		${CHUNK_BACKGROUND}
		<!-- Status Checklist -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'checklist'" [agora-checklist] (checked)="onChecked($event)"></div>
		<!-- Status Link -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'link'" [agora-link] (link)="onLink($event)"></div>
		<!-- Status Login -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'login'" [agora-login] (login)="onLogin($event)"></div>
		<!-- Status Name -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'name' || (state.status == 'disconnected' && state.role === 'viewer')" [agora-name] (name)="onName($event)"></div>
		<!-- Status Device -->
		<div class="ui ui--info" *if="state.status == 'device' || (state.status == 'disconnected' && state.role !== 'viewer')" [agora-device] (enter)="onEnter($event)"></div>
		<!-- Virtual Tour -->
		<div class="ui virtual-tour" [class]="uiClass" *if="state.status == 'connected' && isVirtualTourUser">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- remote sidebar -->
			<div class="group--remote" [class]="remoteClass" *if="state.live">
				<div class="agora-stream" *for="let remote of remotes">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info" [class]="{ spyed: state.spying == remote.id, controlling: state.controlling == remote.id }">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						<div class="id">name</div>
						<button type="button" class="btn--control" [title]="'title_control' | label" (click)="onToggleControl(remote.id)" *if="state.role === 'publisher'">
							<svg class="control" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
						</button>
						<button type="button" class="btn--spy" [title]="'title_spy' | label" (click)="onToggleSpy(remote.id)" *if="state.role === 'publisher'">
							<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
						</button>
					</div>
				</div>
				<div class="group--members" *if="state.mode == 'virtual-tour'">
					<div class="members">
						<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
						<span class="members__count" [innerHTML]="state.membersCount"></span>
					</div>
					<div class="credits">
						<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
							<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
						</a>
					</div>
				</div>
			</div>
			<!-- remote screen -->
			<div class="group--remote-screen" *if="remoteScreen">
				<div class="agora-stream">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<div class="id">name</div>
					</div>
				</div>
			</div>
			<div class="group--header">
				<!-- service -->
				<div class="group--service">
					<button type="button" class="btn--back" [title]="'title_back' | label" (click)="onBack($event)" *if="isBackButtonVisible">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
					</button>
					<button type="button" class="btn--view-mode" [title]="'title_view_mode' | label" (click)="toggleMode($event)" *if="state.mode != 'embed'">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'virtual-tour'"><use xlink:href="#live-meeting"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'live-meeting'"><use xlink:href="#virtual-tour"></use></svg>
					</button>
					<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
					</button>
					<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
					</button>
					<button type="button" class="btn--navmap" [title]="'title_navmap' | label" [class]="{ active: state.showNavmap }" (click)="toggleNavmap($event)" *if="navmap && state.mode != 'live-meeting'">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navmap"></use></svg>
					</button>
				</div>
				<!-- local streams -->
				<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
					<button type="button" class="btn--silence" [title]="'title_silence' | label" [class]="{ active: state.silencing }" (click)="onToggleSilence()" *if="state.role === 'publisher'">
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
					</button>
					<button type="button" class="btn--control" [title]="'title_control' | label" [class]="{ active: state.controlling == state.uid }" (click)="onToggleControl(state.uid)" *if="state.role == 'publisher'">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
					</button>
					<div class="agora-stream" *if="!local"></div>
					<div class="agora-stream" *if="local">
						<div class="agora-stream__player"></div>
						<div class="agora-stream__info">
							<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
							<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						</div>
					</div>
					<div class="agora-stream agora-stream--screen" *if="screen">
						<div class="agora-stream__player"></div>
					</div>
				</div>
			</div>
			<div class="group--footer">
				${CHUNK_CONTROLS}
				${CHUNK_MEDIA}
				${CHUNK_AR_VR}
				${CHUNK_LIKE}
			</div>
			<!-- members -->
			<div class="group--members" *if="state.mode == 'live-meeting'">
				<div class="members">
					<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
					<span class="members__count" [innerHTML]="state.membersCount"></span>
				</div>
				<div class="credits">
					<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
						<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
					</a>
				</div>
			</div>
			${CHUNK_CHAT}
			${CHUNK_LOCK}
			${CHUNK_NAVMAP}
		</div>
		<!-- Smart Device -->
		<div class="ui remotes" [class]="uiClass" *if="state.status == 'connected' && state.role == 'smart-device'">
			<!-- world -->
			<div class="ui__body">
			</div>
			<!-- remote sidebar -->
			<div class="group--remote" [class]="remoteClass" *if="state.live">
				<div class="agora-stream" *for="let remote of remotes">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						<div class="id">name</div>
						<button type="button" class="btn--spy" [title]="'title_spy' | label" *if="state.role === 'publisher'" (click)="onToggleSpy(remote.id)">
							<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
						</button>
					</div>
				</div>
			</div>
			<!-- remote screen -->
			<div class="group--remote-screen" *if="remoteScreen">
				<div class="agora-stream">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<div class="id">name</div>
					</div>
				</div>
			</div>
			<!-- local streams -->
			<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
				<div class="agora-stream" *if="local">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
					</div>
				</div>
			</div>
			<!-- controls -->
			<div class="group--controls" *if="state.live">
				<div class="group--actions">
					<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
					</button>
					<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
					</button>
					<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
					</button>
					<button type="button" class="btn--screen" [title]="'title_share_screen' | label" [class]="{ active: screen }" (click)="toggleScreen()" *if="('screenShare' | flag) && (state.role == 'publisher' || state.role == 'attendee' || controlling)">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#screen"></use></svg>
					</button>
					<button type="button" class="btn--chat" [title]="'title_chat' | label" [class]="{ active: state.chatDirty }" (click)="toggleChat()" *if="('chat' | flag)">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#chat"></use></svg>
					</button>
					<button type="button" class="btn--navinfo" [title]="'title_navinfo' | label" [class]="{ active: state.showNavInfo }" (click)="toggleNavInfo()" *if="showNavInfoToggler">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navinfo"></use></svg>
					</button>
				</div>
			</div>
			<!-- members -->
			<div class="group--members">
				<div class="members">
					<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
					<span class="members__count" [innerHTML]="state.membersCount"></span>
				</div>
				<div class="credits">
					<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
						<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
					</a>
				</div>
			</div>
		</div>
		<!-- Self Service Tour -->
		<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'self-service-tour'">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- service -->
			<div class="group--service">
				<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
				</button>
				<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
				</button>
			</div>
			${CHUNK_AR_VR}
			${CHUNK_LIKE}
		</div>
		<!-- Embed -->
		<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'embed'">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- service -->
			<div class="group--service">
				<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
				</button>
				<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
				</button>
			</div>
			${CHUNK_AR_VR}
			${CHUNK_LIKE}
		</div>
		<a class="btn--logo" [routerLink]="':lang.access' | route" *if="state.status != 'connected'">
			<img [src]="'logo' | env" *if="'logo' | env" />
			<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
		</a>
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener" *if="state.status != 'connected'">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
		<div class="group--language" language *if="state.status != 'connected'"></div>
	</div>
	`
};class TryInARComponent extends rxcomp.Component {
  get viewId() {
    if (this.route) {
      const viewId = this.route.params.viewId;
      return viewId ? parseInt(viewId) : null;
    }
  }

  onInit() {
    this.platform = DeviceService.platform;
    this.route = this.host ? this.host.route : null;
    this.missingAr = false;
    this.missingUsdz = false;
    this.missingGltf = false;
    const viewId = this.viewId; // console.log('TryInARComponent.viewId', viewId);

    if (viewId) {
      ViewService.viewById$(viewId).pipe(operators.first()).subscribe(view => {
        if (!view.ar) {
          this.missingAr = true;
          this.pushChanges();
          return;
        } // console.log('TryInARComponent.view', view);


        if (this.platform === DevicePlatform.IOS) {
          const usdzSrc = this.getUsdzSrc(view);

          if (usdzSrc) {
            window.location.href = usdzSrc;
          } else {
            this.missingUsdz = true;
            this.pushChanges();
          }
        } else if (this.getGltfSrc(view) !== null) {
          const modelViewerNode = this.getModelViewerNode(view);
          const {
            node
          } = rxcomp.getContext(this);
          node.appendChild(modelViewerNode);
          this.addARScripts();
        } else {
          this.missingGltf = true;
          this.pushChanges();
        }
      });
    }
  }

  addARScripts() {
    let script = document.createElement('script');
    script.setAttribute('type', 'module');
    script.setAttribute('src', 'https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js');
    document.head.appendChild(script);
    script = document.createElement('script');
    script.setAttribute('nomodule', '');
    script.setAttribute('src', 'https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js');
    document.head.appendChild(script);
  }

  getUsdzSrc(view) {
    return view.ar && view.ar.usdz ? environment.getPath(view.ar.usdz.folder + view.ar.usdz.file) : null;
  }

  getGltfSrc(view) {
    return view.ar && view.ar.gltf ? environment.getPath(view.ar.gltf.folder + view.ar.gltf.file) : null;
  }

  getViewId() {
    const meetingUrl = new MeetingUrl();
    let viewId = null;

    if (meetingUrl.viewId) {
      viewId = parseInt(meetingUrl.viewId);
    }

    return viewId;
  }

  getModelViewerNode(view) {
    const environmentImage = environment.getPath(environment.textures.envMap);
    const skyboxImage = environment.getPath(view.asset.folder + view.asset.file);
    const usdzSrc = this.getUsdzSrc(view);
    const gltfSrc = this.getGltfSrc(view);
    const template =
    /* html */
    `
			<model-viewer alt="${view.name}" environment-image="${environmentImage}" skybox-image="${skyboxImage}" ios-src="${usdzSrc}" src="${gltfSrc}" ar ar-modes="webxr scene-viewer quick-look" ar-scale="auto" camera-controls></model-viewer>
		`;
    const div = document.createElement("div");
    div.innerHTML = template;
    const node = div.firstElementChild;
    return node;
  }

}
TryInARComponent.meta = {
  selector: '[try-in-ar]',
  hosts: {
    host: RouterOutletStructure
  },
  template:
  /* html */
  `
		<div class="page page--try-in-ar">
			<!--
			<div *if="platform != 'ios'">
				<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
				<script nomodule src="https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js"></script>
			</div>
			-->
			<div class="ui" *if="!viewId">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Unknown url.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingAr">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing AR in view.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingUsdz">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing .usdz in ar.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingGltf">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing .gltf in ar.</div>
					</div>
				</div>
			</div>
		</div>
	`
};console.log('environment.defaultLanguage', environment.defaultLanguage);
const AppRoutesInit = () => [{
  name: 'index',
  path: '/',
  forwardTo: environment.defaultLanguage || 'it'
}, // it
{
  name: 'it',
  path: '/it',
  defaultParams: {
    lang: 'it',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'it.access',
  path: '/accesso',
  defaultParams: {
    lang: 'it',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'it.accessCode',
  path: '/codice-di-accesso?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'it',
    mode: 'accessCode'
  },
  factory: AccessCodeComponent
}, {
  name: 'it.guidedTour',
  path: '/tour-guidato?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'it',
    mode: 'guidedTour'
  },
  factory: AgoraComponent
}, // { name: 'it.guidedTour', path: '/tour-guidato', defaultParams: { lang: 'it', mode: 'guidedTour' }, factory: AgoraComponent },
{
  name: 'it.selfServiceTour',
  path: '/tour-self-service?:p&:viewId&:pathId',
  defaultParams: {
    lang: 'it',
    mode: 'selfServiceTour'
  },
  factory: AgoraComponent
}, {
  name: 'it.embed',
  path: '/embed',
  defaultParams: {
    lang: 'it',
    mode: 'embed'
  },
  factory: AgoraComponent
}, {
  name: 'it.tryInAr',
  path: '/prova-in-ar?:p&:viewId',
  defaultParams: {
    lang: 'it',
    mode: 'tryInAr'
  },
  factory: TryInARComponent
}, {
  name: 'it.editor',
  path: '/editor?:p&:viewId',
  defaultParams: {
    lang: 'it',
    mode: 'editor'
  },
  factory: EditorComponent
}, {
  name: 'it.layout',
  path: '/layout',
  defaultParams: {
    lang: 'it',
    mode: 'layout'
  },
  factory: LayoutComponent
}, {
  name: 'it.privacy',
  path: '/informativa-sulla-privacy',
  defaultParams: {
    lang: 'it',
    mode: 'privacy_policy'
  },
  factory: GenericComponent
}, {
  name: 'it.terms',
  path: '/termini-di-utilizzo',
  defaultParams: {
    lang: 'it',
    mode: 'terms'
  },
  factory: GenericComponent
}, // en
{
  name: 'en',
  path: '/en',
  defaultParams: {
    lang: 'en',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'en.access',
  path: '/access',
  defaultParams: {
    lang: 'en',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'en.accessCode',
  path: '/accesso-code?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'en',
    mode: 'accessCode'
  },
  factory: AccessCodeComponent
}, {
  name: 'en.guidedTour',
  path: '/guided-tour?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'en',
    mode: 'guidedTour'
  },
  factory: AgoraComponent
}, // { name: 'en.guidedTour', path: '/guided-tour', defaultParams: { lang: 'en', mode: 'guidedTour' }, factory: AgoraComponent },
{
  name: 'en.selfServiceTour',
  path: '/self-service-tour?:p&:viewId&:pathId',
  defaultParams: {
    lang: 'en',
    mode: 'selfServiceTour'
  },
  factory: AgoraComponent
}, {
  name: 'en.embed',
  path: '/embed',
  defaultParams: {
    lang: 'en',
    mode: 'embed'
  },
  factory: AgoraComponent
}, {
  name: 'en.tryInAr',
  path: '/try-in-ar?:p&:viewId',
  defaultParams: {
    lang: 'en',
    mode: 'tryInAr'
  },
  factory: TryInARComponent
}, {
  name: 'en.editor',
  path: '/editor?:p&:viewId',
  defaultParams: {
    lang: 'en',
    mode: 'editor'
  },
  factory: EditorComponent
}, {
  name: 'en.layout',
  path: '/layout',
  defaultParams: {
    lang: 'en',
    mode: 'layout'
  },
  factory: LayoutComponent
}, {
  name: 'en.privacy',
  path: '/privacy-policy',
  defaultParams: {
    lang: 'en',
    mode: 'privacy_policy'
  },
  factory: GenericComponent
}, {
  name: 'en.terms',
  path: '/terms-of-service',
  defaultParams: {
    lang: 'en',
    mode: 'terms'
  },
  factory: GenericComponent
}];const SVG_CHUNK =
/* html */
`
		<svg width="0" height="0" class="hidden" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true">
			<symbol id="arrow-down" viewBox="0 0 24 24">
				<path d="M0 7.33l2.829-2.83 9.175 9.339 9.167-9.339 2.829 2.83-11.996 12.17z"></path>
			</symbol>
			<symbol id="arrow-next" viewBox="0 0 24 24">
				<path d="M7.33 24l-2.83-2.829 9.339-9.175-9.339-9.167 2.83-2.829 12.17 11.996z"></path>
			</symbol>
			<symbol id="arrow-prev" viewBox="0 0 24 24">
				<path d="M16.67 0l2.83 2.829-9.339 9.175 9.339 9.167-2.83 2.829-12.17-11.996z"></path>
			</symbol>
			<symbol id="call" viewBox="0 0 24 24">
				<path d="M20 22.621l-3.521-6.795c-.008.004-1.974.97-2.064 1.011-2.24 1.086-6.799-7.82-4.609-8.994l2.083-1.026-3.493-6.817-2.106 1.039c-7.202 3.755 4.233 25.982 11.6 22.615.121-.055 2.102-1.029 2.11-1.033z"></path>
			</symbol>
			<symbol id="heart" viewBox="0 0 24 24">
				<path d="M12 4.435c-1.989-5.399-12-4.597-12 3.568 0 4.068 3.06 9.481 12 14.997 8.94-5.516 12-10.929 12-14.997 0-8.118-10-8.999-12-3.568z"></path>
			</symbol>
			<symbol id="heart-outline" viewBox="0 0 24 24">
				<path d="M12 9.229c.234-1.12 1.547-6.229 5.382-6.229 2.22 0 4.618 1.551 4.618 5.003 0 3.907-3.627 8.47-10 12.629-6.373-4.159-10-8.722-10-12.629 0-3.484 2.369-5.005 4.577-5.005 3.923 0 5.145 5.126 5.423 6.231zm-12-1.226c0 4.068 3.06 9.481 12 14.997 8.94-5.516 12-10.929 12-14.997 0-7.962-9.648-9.028-12-3.737-2.338-5.262-12-4.27-12 3.737z"/>
			</symbol>
			<symbol id="cam" viewBox="0 0 24 24">
				<path d="M16 18c0 1.104-.896 2-2 2h-12c-1.105 0-2-.896-2-2v-12c0-1.104.895-2 2-2h12c1.104 0 2 .896 2 2v12zm8-14l-6 6.223v3.554l6 6.223v-16z"></path>
			</symbol>
			<symbol id="cam-muted" viewBox="0 0 24 24">
				<path d="M0.7,19.5L15.5,4.7C15.1,4.3,14.6,4,14,4H2C0.9,4,0,4.9,0,6v12C0,18.6,0.3,19.1,0.7,19.5z"></path>
				<path d="M18 13.8L24 20 24 4 18 10.2z"></path>
				<path d="M7.8,20H14c1.1,0,2-0.9,2-2v-6.2L7.8,20z"></path>
				<path d="M-3.4 11.2H27.400000000000002V12.7H-3.4z" transform="rotate(-45.001 12 12)"></path>
			</symbol>
			<symbol id="mic" viewBox="0 0 24 24">
				<path d="M16 11c0 2.209-1.791 4-4 4s-4-1.791-4-4v-7c0-2.209 1.791-4 4-4s4 1.791 4 4v7zm4-2v2c0 4.418-3.582 8-8 8s-8-3.582-8-8v-2h2v2c0 3.309 2.691 6 6 6s6-2.691 6-6v-2h2zm-7 13v-2h-2v2h-4v2h10v-2h-4z"></path>
			</symbol>
			<symbol id="mic-muted" viewBox="0 0 24 24">
				<path d="M16,11.4L12.4,15C14.3,14.8,15.8,13.3,16,11.4z"></path>
				<path d="M16,4.6V4c0-2.2-1.8-4-4-4S8,1.8,8,4v7c0,0.5,0.1,0.9,0.3,1.4L16,4.6z"></path>
				<path d="M13 20L11 20 11 22 7 22 7 24 17 24 17 22 13 22z"></path>
				<path d="M18,11c0,3.3-2.7,6-6,6c-0.5,0-1-0.1-1.4-0.2L9,18.4c0.9,0.4,2,0.6,3,0.6c4.4,0,8-3.6,8-8V9h-2V11z"></path>
				<path d="M6.7,13.9C6.3,13,6,12,6,11V9H4v2c0,1.6,0.5,3.1,1.3,4.3L6.7,13.9z"></path>
				<path d="M-3.4 11.2H27.400000000000002V12.7H-3.4z" transform="rotate(-45.001 12 12)"></path>
			</symbol>
			<symbol id="gamepad" viewBox="0 0 24 24">
				<path d="M17.622 3c-1.913 0-2.558 1.382-5.623 1.382-3.009 0-3.746-1.382-5.623-1.382-5.209 0-6.376 10.375-6.376 14.348 0 2.145.817 3.652 2.469 3.652 3.458 0 2.926-5 6.915-5h5.23c3.989 0 3.457 5 6.915 5 1.652 0 2.471-1.506 2.471-3.651 0-3.973-1.169-14.349-6.378-14.349zm-10.622 10c-1.657 0-3-1.343-3-3s1.343-3 3-3 3 1.343 3 3-1.343 3-3 3zm10-6c.552 0 1 .447 1 1 0 .553-.448 1-1 1s-1-.447-1-1c0-.553.448-1 1-1zm-2 4c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm2 2c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm2-2c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm-10.25-1c0 .965-.785 1.75-1.75 1.75s-1.75-.785-1.75-1.75.785-1.75 1.75-1.75 1.75.785 1.75 1.75z"></path>
			</symbol>
			<symbol id="ar" viewBox="0 0 24 24">
				<path d="M12 0l-11 6v12.131l11 5.869 11-5.869v-12.066l-11-6.065zm7.91 6.646l-7.905 4.218-7.872-4.294 7.862-4.289 7.915 4.365zm-16.91 1.584l8 4.363v8.607l-8-4.268v-8.702zm10 12.97v-8.6l8-4.269v8.6l-8 4.269zm6.678-5.315c.007.332-.256.605-.588.612-.332.007-.604-.256-.611-.588-.006-.331.256-.605.588-.612.331-.007.605.256.611.588zm-2.71-1.677c-.332.006-.595.28-.588.611.006.332.279.595.611.588s.594-.28.588-.612c-.007-.331-.279-.594-.611-.587zm-2.132-1.095c-.332.007-.595.281-.588.612.006.332.279.594.611.588.332-.007.594-.28.588-.612-.007-.331-.279-.594-.611-.588zm-9.902 2.183c.332.007.594.281.588.612-.007.332-.279.595-.611.588-.332-.006-.595-.28-.588-.612.005-.331.279-.594.611-.588zm1.487-.5c-.006.332.256.605.588.612s.605-.257.611-.588c.007-.332-.256-.605-.588-.611-.332-.008-.604.255-.611.587zm2.132-1.094c-.006.332.256.605.588.612.332.006.605-.256.611-.588.007-.332-.256-.605-.588-.612-.332-.007-.604.256-.611.588zm3.447-5.749c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6zm0-2.225c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6zm0-2.031c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6z"></path>
			</symbol>
			<symbol id="close" viewBox="0 0 24 24">
				<path d="M23 20.168l-8.185-8.187 8.185-8.174-2.832-2.807-8.182 8.179-8.176-8.179-2.81 2.81 8.186 8.196-8.186 8.184 2.81 2.81 8.203-8.192 8.18 8.192z"></path>
			</symbol>
			<symbol id="vr" viewBox="0 0 24 24">
				<path d="M22.3,4.3H1.7C0.8,4.3,0,5.1,0,6v12c0,0.9,0.8,1.7,1.7,1.7h5.6c0.7,0,1.4-0.5,1.6-1.2l1.4-4.2c0.5-1.6,2.7-1.6,3.3,0 l1.4,4.2c0.2,0.7,0.9,1.2,1.6,1.2h5.6c0.9,0,1.7-0.8,1.7-1.7V6C24,5.1,23.2,4.3,22.3,4.3z M6,14.6c-1.4,0-2.6-1.2-2.6-2.6 S4.6,9.4,6,9.4s2.6,1.2,2.6,2.6S7.4,14.6,6,14.6z M18,14.6c-1.4,0-2.6-1.2-2.6-2.6s1.2-2.6,2.6-2.6s2.6,1.2,2.6,2.6 S19.4,14.6,18,14.6z"></path>
			</symbol>
			<symbol id="vr-02" viewBox="0 0 24 24">
				<path d="M22.5,8.6c-0.3,0-0.6,0.1-0.8,0.3c-0.3-1.9-1.9-3.4-3.9-3.4H6.2c-2,0-3.6,1.5-3.9,3.4C2,8.7,1.7,8.6,1.4,8.6 C0.6,8.6,0,9.3,0,10.1v3.9c0,0.8,0.6,1.4,1.4,1.4c0.3,0,0.6-0.1,0.8-0.3c0.3,1.9,1.9,3.4,3.9,3.4h11.6c2,0,3.6-1.5,3.9-3.4 c0.2,0.2,0.5,0.3,0.8,0.3c0.8,0,1.4-0.6,1.4-1.4v-3.9C24,9.3,23.3,8.6,22.5,8.6z M20.7,14.6c0,1.6-1.3,2.8-2.8,2.8H6.2 c-1.6,0-2.8-1.3-2.8-2.8V9.4c0-1.6,1.3-2.8,2.8-2.8h11.6c1.6,0,2.8,1.3,2.8,2.8V14.6z"></path><circle cx="5.7" cy="8.7" r=".8"></circle><circle cx="18.3" cy="8.6" r=".8"></circle><circle cx="5.7" cy="15.4" r=".8"></circle><circle cx="18.3" cy="15.3" r=".8"></circle>
			</symbol>
			<symbol id="the-spy" viewBox="0 0 24 24">
				<path d="M17,14c-1.8,0-3.3,1.3-3.7,3h-2.5c-0.5-2.1-2.5-3.4-4.6-2.9c-2.1,0.5-3.4,2.5-2.9,4.6s2.5,3.4,4.6,2.9 c1.4-0.3,2.6-1.5,2.9-2.9h2.5c0.5,2.1,2.5,3.4,4.6,2.9s3.4-2.5,2.9-4.6C20.4,15.3,18.8,14,17,14z"></path>
				<path d="M23.2,11.5h-2.6V6c0-0.7-0.5-1.4-1.2-1.6l-5.5-1.8c-1.2-0.4-2.6-0.4-3.8,0L4.6,4.4C3.9,4.6,3.4,5.3,3.4,6v5.4H0.8 c-0.5,0-0.8,0.4-0.8,0.8s0.4,0.8,0.8,0.8h22.3c0.5,0,0.8-0.4,0.8-0.8S23.6,11.5,23.2,11.5z"></path>
			</symbol>
			<symbol id="spy-eye" viewBox="0 0 24 24">
				<path d="M12,19.6c-4.6,0-8.9-3.5-11.7-6.8c-0.4-0.5-0.4-1.2,0-1.6C3.1,7.9,7.4,4.4,12,4.4s8.9,3.5,11.7,6.8 c0.4,0.5,0.4,1.2,0,1.6C20.9,16.1,16.6,19.6,12,19.6z M12,7.5c2.5,0,4.4,1.9,4.4,4.4s-1.9,4.4-4.4,4.4s-4.4-1.9-4.4-4.4 S9.5,7.5,12,7.5z" clip-rule="evenodd"></path>
				<path d="M12,9.3c1.4,0,2.6,1.2,2.6,2.6s-1.2,2.6-2.6,2.6s-2.6-1.2-2.6-2.6S10.6,9.3,12,9.3z" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="copy" viewBox="0 0 24 24">
				<path d="M7 16h10v1h-10v-1zm0-1h10v-1h-10v1zm15-13v22h-20v-22h3c1.229 0 2.18-1.084 3-2h8c.82.916 1.771 2 3 2h3zm-11 1c0 .552.448 1 1 1s1-.448 1-1-.448-1-1-1-1 .448-1 1zm9 1h-4l-2 2h-3.898l-2.102-2h-4v18h16v-18zm-13 9h10v-1h-10v1zm0-2h10v-1h-10v1z"></path>
			</symbol>
			<symbol id="menu" viewBox="0 0 24 24">
				<path d="M12 18c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3z"></path>
			</symbol>
			<symbol id="menu-light" viewBox="0 0 24 24">
				<path d="M14 19h-14v-1h14v1zm9.247-8.609l-3.247 4.049-3.263-4.062-.737.622 4 5 4-5-.753-.609zm-9.247 2.609h-14v-1h14v1zm0-6h-14v-1h14v1z"/>
			</symbol>
			<symbol id="settings" viewBox="0 0 24 24">
				<path d="M24 14.187v-4.374c-2.148-.766-2.726-.802-3.027-1.529-.303-.729.083-1.169 1.059-3.223l-3.093-3.093c-2.026.963-2.488 1.364-3.224 1.059-.727-.302-.768-.889-1.527-3.027h-4.375c-.764 2.144-.8 2.725-1.529 3.027-.752.313-1.203-.1-3.223-1.059l-3.093 3.093c.977 2.055 1.362 2.493 1.059 3.224-.302.727-.881.764-3.027 1.528v4.375c2.139.76 2.725.8 3.027 1.528.304.734-.081 1.167-1.059 3.223l3.093 3.093c1.999-.95 2.47-1.373 3.223-1.059.728.302.764.88 1.529 3.027h4.374c.758-2.131.799-2.723 1.537-3.031.745-.308 1.186.099 3.215 1.062l3.093-3.093c-.975-2.05-1.362-2.492-1.059-3.223.3-.726.88-.763 3.027-1.528zm-4.875.764c-.577 1.394-.068 2.458.488 3.578l-1.084 1.084c-1.093-.543-2.161-1.076-3.573-.49-1.396.581-1.79 1.693-2.188 2.877h-1.534c-.398-1.185-.791-2.297-2.183-2.875-1.419-.588-2.507-.045-3.579.488l-1.083-1.084c.557-1.118 1.066-2.18.487-3.58-.579-1.391-1.691-1.784-2.876-2.182v-1.533c1.185-.398 2.297-.791 2.875-2.184.578-1.394.068-2.459-.488-3.579l1.084-1.084c1.082.538 2.162 1.077 3.58.488 1.392-.577 1.785-1.69 2.183-2.875h1.534c.398 1.185.792 2.297 2.184 2.875 1.419.588 2.506.045 3.579-.488l1.084 1.084c-.556 1.121-1.065 2.187-.488 3.58.577 1.391 1.689 1.784 2.875 2.183v1.534c-1.188.398-2.302.791-2.877 2.183zm-7.125-5.951c1.654 0 3 1.346 3 3s-1.346 3-3 3-3-1.346-3-3 1.346-3 3-3zm0-2c-2.762 0-5 2.238-5 5s2.238 5 5 5 5-2.238 5-5-2.238-5-5-5z"/>
			</symbol>
			<symbol id="settings-full" viewBox="0 0 24 24">
				<path d="M24 13.616v-3.232l-2.869-1.02c-.198-.687-.472-1.342-.811-1.955l1.308-2.751-2.285-2.285-2.751 1.307c-.613-.339-1.269-.613-1.955-.811l-1.021-2.869h-3.232l-1.021 2.869c-.686.198-1.342.471-1.955.811l-2.751-1.308-2.285 2.285 1.308 2.752c-.339.613-.614 1.268-.811 1.955l-2.869 1.02v3.232l2.869 1.02c.197.687.472 1.342.811 1.955l-1.308 2.751 2.285 2.286 2.751-1.308c.613.339 1.269.613 1.955.811l1.021 2.869h3.232l1.021-2.869c.687-.198 1.342-.472 1.955-.811l2.751 1.308 2.285-2.286-1.308-2.751c.339-.613.613-1.268.811-1.955l2.869-1.02zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z"/>
			</symbol>
			<symbol id="emoji" viewBox="0 0 24 24">
				<path d="M12,2c5.5,0,10,4.5,10,10s-4.5,10-10,10S2,17.5,2,12S6.5,2,12,2z M12,0C5.4,0,0,5.4,0,12s5.4,12,12,12s12-5.4,12-12 S18.6,0,12,0z M18,14H6c0.3,1.5,2.8,4,6,4C15.1,18,17.7,15.5,18,14z M8.5,8C7.7,8,7,8.7,7,9.5S7.7,11,8.5,11S10,10.3,10,9.5 S9.3,8,8.5,8z M15.5,8C14.7,8,14,8.7,14,9.5s0.7,1.5,1.5,1.5c0.8,0,1.5-0.7,1.5-1.5S16.3,8,15.5,8z"/>
			</symbol>
			<symbol id="pencil" viewBox="0 0 24 24">
				<path d="M19.769 9.923l-12.642 12.639-7.127 1.438 1.438-7.128 12.641-12.64 5.69 5.691zm1.414-1.414l2.817-2.82-5.691-5.689-2.816 2.817 5.69 5.692z"/>
			</symbol>
			<symbol id="erase" viewBox="0 0 24 24">
				<path d="M5.662 23l-5.369-5.365c-.195-.195-.293-.45-.293-.707 0-.256.098-.512.293-.707l14.929-14.928c.195-.194.451-.293.707-.293.255 0 .512.099.707.293l7.071 7.073c.196.195.293.451.293.708 0 .256-.097.511-.293.707l-11.216 11.219h5.514v2h-12.343zm3.657-2l-5.486-5.486-1.419 1.414 4.076 4.072h2.829zm.456-11.429l-4.528 4.528 5.658 5.659 4.527-4.53-5.657-5.657z"/>
			</symbol>
			<symbol id="move" viewBox="0 0 24 24">
				<path d="M12 10c1.104 0 2 .896 2 2s-.896 2-2 2-2-.896-2-2 .896-2 2-2zm-3.857 3c-.084-.321-.143-.652-.143-1s.059-.679.143-1h-2.143v-4l-6 5 6 5v-4h2.143zm7.714-2c.084.321.143.652.143 1s-.059.679-.143 1h2.143v4l6-5-6-5v4h-2.143zm-2.857 4.857c-.321.084-.652.143-1 .143s-.679-.059-1-.143v2.143h-4l5 6 5-6h-4v-2.143zm-2-7.714c.321-.084.652-.143 1-.143s.679.059 1 .143v-2.143h4l-5-6-5 6h4v2.143z"/>
			</symbol>
			<symbol id="caret-down" viewBox="0 0 8 5">
				<path d="M0 0h8L4 5 0 0z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="caret-right" viewBox="0 0 8 12">
				<path d="M0 12V0l8 6-8 6z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="websolute" viewBox="0 0 20 20">
				<path d="M20 10c0 5.5-4.5 10-10 10S0 15.5 0 10 4.5 0 10 0s10 4.5 10 10m-10 2.3c.5.5 1.3.8 2.1.8s1.5-.3 2.1-.8c.5-.5.8-1.2.8-2V7.5h-1.7v2.8c0 .3-.1.6-.4.8-.1.1-.3.2-.4.3-.2.1-.3.1-.5.1s-.3 0-.5-.1c-.1-.1-.3-.2-.4-.3-.2-.2-.4-.5-.4-.8V7.6H9.2v2.8c0 .3-.1.6-.4.9-.2.2-.5.4-.8.4-.3 0-.7-.1-.9-.3-.2-.2-.4-.5-.3-.8V7.5H5v2.8c0 .7.3 1.5.8 2 .6.5 1.3.8 2.1.8.8.1 1.6-.2 2.1-.8z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="search" viewBox="0 0 21 23">
				<path d="M20.6 20.3l-4.9-5.2c1.2-1.7 1.8-3.7 1.8-5.7 0-5.2-3.9-9.4-8.7-9.4S0 4.2 0 9.4s3.7 7.8 6.3 8.4c1.8.4 3.9.6 7.1-.7l5.1 5.4c.5.6 1.4.6 2 .1l.1-.1c.5-.6.5-1.6 0-2.2zM15 9.4c-.2 3.5-3.2 6.1-6.7 5.8S2.2 12 2.5 8.5c.2-3.3 3-5.8 6.3-5.8 3.5.1 6.3 3.1 6.2 6.7z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="result-indicator" viewBox="0 0 24 24">
				<path d="M11 21.883l-6.235-7.527-.765.644 7.521 9 7.479-9-.764-.645-6.236 7.529v-21.884h-1v21.883z"></path>
			</symbol>
			<symbol id="bullet" viewBox="0 0 18 18">
				<path d="M9 2c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7m0-2C4 0 0 4 0 9s4 9 9 9 9-4 9-9-4-9-9-9z" opacity=".15" fill="#17265a"></path>
				<circle cx="9" cy="9" r="4" fill="#17265a"></circle>
			</symbol>
			<symbol id="play" viewBox="0 0 16 20">
				<path d="M0,0v19.8l15.4-11L0,0z" fill-rule="evenodd" clip-rule="evenodd" ></path>
			</symbol>
			<symbol id="play-progress" viewBox="0 0 196 196">
				<path d="M195.5,98c0,53.8-43.7,97.5-97.5,97.5S0.5,151.8,0.5,98S44.2,0.5,98,0.5S195.5,44.2,195.5,98z" stroke-width="2px" stroke-linecap="square" ></path>
			</symbol>
			<symbol id="pause" viewBox="0 0 16 20">
				<path d="M0 0.9H4V18.9H0z"></path>
				<path d="M11.4 0.9H15.4V18.9H11.4z"></path>
			</symbol>
			<symbol id="wishlist-add" viewBox="0 0 25 20">
				<path d="M12.5,20.8c-0.3,0-0.5-0.1-0.8-0.3c-0.3-0.2-0.6-0.4-0.9-0.6c-0.7-0.5-1.4-0.9-2.1-1.5 c-1.1-0.8-2.1-1.6-3.1-2.4C4.2,15,3,13.8,1.9,12.4c-0.9-1.1-1.4-2.3-1.7-3.7C0.1,8.5,0.1,8.2,0,7.9l0-0.2l0.1-1.4 c0-0.1,0.1-0.3,0.1-0.4c0.1-0.3,0.1-0.7,0.3-1c0.6-1.7,1.8-3.2,3.4-4c1.5-0.8,3.3-1.1,5-0.8c1.4,0.2,2.6,0.8,3.7,1.7 c2.9-2.4,7.2-2.4,10,0.1c1.1,0.9,1.9,2.2,2.2,3.5c0.1,0.3,0.1,0.6,0.2,0.8L25,6.7l-0.1,1.4c-0.2,1.2-0.6,2.4-1.2,3.4 c-0.5,0.8-1.1,1.6-1.8,2.3c-0.8,0.9-1.7,1.7-2.6,2.5c-0.7,0.6-1.6,1.3-2.6,2c-0.8,0.5-1.5,1.1-2.3,1.6c-0.4,0.3-0.8,0.5-1.2,0.8 C13.1,20.8,12.8,20.8,12.5,20.8z M2.1,7.6c0,0.2,0.1,0.4,0.1,0.6c0.2,1.1,0.7,2,1.4,2.9c1,1.2,2.1,2.3,3.3,3.3c1,0.8,2,1.6,3,2.4 c0.7,0.5,1.4,0.9,2.1,1.4l0.5,0.3c0.2-0.2,0.5-0.3,0.7-0.5c0.8-0.5,1.5-1,2.3-1.6c0.9-0.7,1.8-1.4,2.5-1.9c0.9-0.7,1.7-1.5,2.4-2.3 c0.6-0.6,1.1-1.2,1.5-1.9c0.5-0.8,0.8-1.7,0.9-2.6c0-0.1,0-0.1,0-0.2l0-0.9c0-0.2-0.1-0.4-0.1-0.6c-0.3-1-0.8-1.9-1.6-2.5 c-2.1-1.8-5.2-1.8-7.3,0c-0.1,0.1-0.3,0.2-0.4,0.4l-0.9,1.2l-1-1.3c-0.8-0.8-1.9-1.4-3-1.6C7.2,2,5.9,2.2,4.9,2.8 c-1.1,0.6-2,1.6-2.4,2.8C2.4,5.9,2.3,6.1,2.3,6.4c0,0.1-0.1,0.3-0.1,0.4l0,0L2.1,7.6L2.1,7.6z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="wishlist-added" viewBox="0 0 25 20">
				<path d="M12.5,20.8c-0.3,0-0.5-0.1-0.8-0.3c-0.3-0.2-0.6-0.4-0.9-0.6c-0.7-0.5-1.4-0.9-2.1-1.5 c-1.1-0.8-2.1-1.6-3.1-2.4c-1.4-1-2.6-2.2-3.7-3.6C1,11.3,0.5,10.1,0.2,8.7C0.1,8.5,0.1,8.2,0,7.9V7.7l0.1-1.4 c0-0.1,0.1-0.3,0.1-0.4c0.1-0.3,0.1-0.7,0.3-1c0.6-1.7,1.8-3.2,3.4-4c1.5-0.8,3.3-1.1,5-0.8c1.4,0.2,2.6,0.8,3.7,1.7 c2.9-2.4,7.2-2.4,10,0.1c1.1,0.9,1.9,2.2,2.2,3.5C24.9,5.7,24.9,6,25,6.2v0.5l-0.1,1.4c-0.2,1.2-0.6,2.4-1.2,3.4 c-0.5,0.8-1.1,1.6-1.8,2.3c-0.8,0.9-1.7,1.7-2.6,2.5c-0.7,0.6-1.6,1.3-2.6,2c-0.8,0.5-1.5,1.1-2.3,1.6c-0.4,0.3-0.8,0.5-1.2,0.8 C13.1,20.8,12.8,20.8,12.5,20.8z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="wishlist" viewBox="0 0 16 14">
				<path d="M8,14c-0.2,0-0.3-0.1-0.5-0.2l-0.6-0.4c-0.5-0.3-0.9-0.6-1.4-1c-0.7-0.5-1.4-1.1-2-1.6 c-0.9-0.7-1.6-1.6-2.3-2.5C0.7,7.6,0.3,6.8,0.1,5.9c0-0.2-0.1-0.4-0.1-0.5l0-0.1l0-1c0-0.1,0-0.2,0.1-0.3c0.1-0.2,0.1-0.4,0.2-0.7 c0.4-1.1,1.2-2.1,2.2-2.7c1.8-1,4-0.8,5.5,0.6c1.8-1.6,4.6-1.6,6.4,0.1c0.7,0.6,1.2,1.5,1.4,2.4C15.9,3.8,15.9,4,16,4.2l0,0.3l0,0.9 c-0.1,0.8-0.4,1.6-0.8,2.3c-0.3,0.5-0.7,1-1.1,1.5c-0.5,0.6-1.1,1.1-1.7,1.7c-0.4,0.4-1,0.9-1.7,1.3c-0.5,0.4-1,0.7-1.5,1.1 c-0.2,0.2-0.5,0.3-0.7,0.5C8.4,13.9,8.2,14,8,14z M1.4,5.1c0,0.1,0.1,0.3,0.1,0.4c0.1,0.7,0.4,1.4,0.9,1.9C2.9,8.3,3.6,9,4.4,9.7 c0.6,0.5,1.3,1.1,1.9,1.6c0.4,0.3,0.9,0.6,1.3,0.9c0.1,0.1,0.2,0.2,0.3,0.2c0.2-0.1,0.3-0.2,0.5-0.3c0.5-0.3,1-0.7,1.5-1 c0.6-0.4,1.2-0.9,1.6-1.3c0.5-0.5,1.1-1,1.5-1.5c0.4-0.4,0.7-0.8,1-1.3c0.3-0.5,0.5-1.1,0.6-1.7c0,0,0-0.1,0-0.1l0-0.6 c0-0.1,0-0.3-0.1-0.4c-0.2-0.7-0.5-1.2-1-1.7c-1.3-1.2-3.4-1.2-4.7,0C8.7,2.4,8.6,2.5,8.5,2.6L8,3.4L7.3,2.5 C6.3,1.4,4.5,1.1,3.1,1.9C2.4,2.3,1.8,3,1.6,3.8C1.5,3.9,1.5,4.1,1.4,4.3L1.4,4.6l0,0L1.4,5.1L1.4,5.1z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="expand" viewBox="0 0 29 30">
				<path d="M26 16.3V5.9L2.2 29.7.1 27.6 24 3.3H13v-3h16v16h-3z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="download" viewBox="0 0 9 13">
				<path d="M8.5 7.9c-.3-.4-.8-.4-1.2-.1l-.1.1-2 2V1.2c0-.2-.1-.4-.2-.6-.2-.3-.7-.3-1 0-.2.2-.3.4-.3.6v8.6l-2-2c-.2-.1-.4-.2-.7-.2-.2 0-.4.1-.6.3-.1.2-.1.4-.1.6 0 .2.1.4.2.5l3.4 3.4c.2.2.4.2.6.2.2 0 .4-.1.6-.2L8.4 9c.2-.1.2-.3.3-.6 0-.1-.1-.4-.2-.5z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="upload" viewBox="0 0 24 24">
				<path d="M10 9H4l8-9 8 9h-6v11h-4V9zm11 11v2H3v-2H1v4h22v-4h-2z"></path>
			</symbol>
			<symbol id="user" viewBox="0 0 24 24">
				<path d="M20.822 18.096c-3.439-.794-6.64-1.49-5.09-4.418C20.452 4.766 16.983 0 12 0 6.918 0 3.536 4.949 8.268 13.678c1.597 2.945-1.725 3.641-5.09 4.418C.105 18.806-.01 20.332 0 23l.004 1h23.99l.004-.969c.012-2.688-.092-4.222-3.176-4.935z"></path>
			</symbol>
			<symbol id="back" viewBox="0 0 24 24">
				<path d="M2.117 12l7.527 6.235L9 19l-9-7.521L9 4l.645.764L2.116 11H24v1H2.117z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="add" viewBox="0 0 24 24">
				<path d="M24 10h-10v-10h-4v10h-10v4h10v10h4v-10h10z"></path>
			</symbol>
			<symbol id="remove" viewBox="0 0 24 24">
				<path d="M0 10h24v4h-24z"></path>
			</symbol>
			<symbol id="link" viewBox="0 0 24 24">
				<path d="M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z"></path>
			</symbol>
			<symbol id="up" viewBox="0 0 24 24">
				<path d="M7 11h-6l11-11 11 11h-6v13h-10z"></path>
			</symbol>
			<symbol id="down" viewBox="0 0 24 24">
				<path d="M17,13h6L12,24L1,13h6V0h10V13z"></path>
			</symbol>
			<symbol id="waiting-room" viewBox="0 0 24 24">
				<path d="M2,6c0-2.2,1.8-4,4-4h12c2.2,0,4,1.8,4,4v12c0,2.2-1.8,4-4,4H6c-2.2,0-4-1.8-4-4V6z" opacity=".2"></path>
				<path d="M17.8,10.7c0.7,0,1.3,0.6,1.3,1.3s-0.6,1.3-1.3,1.3H6.2c-0.7,0-1.3-0.6-1.3-1.3s0.6-1.3,1.3-1.3H17.8z M19.7,12 c0-1.1-0.9-1.9-1.9-1.9H6.2c-1.1,0-1.9,0.9-1.9,1.9s0.9,1.9,1.9,1.9h11.6C18.9,13.9,19.7,13.1,19.7,12z M13.9,11.4H6.2 c-0.4,0-0.6,0.3-0.6,0.6s0.3,0.6,0.6,0.6h7.7c0.4,0,0.6-0.3,0.6-0.6S14.3,11.4,13.9,11.4z"></path>
			</symbol>
			<symbol id="panorama" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 9 15 C 9 14.448 9.448 14 10 14 L 14 14 C 14.552 14 15 14.448 15 15 L 15 16 C 15 16.552 14.552 17 14 17 L 10 17 C 9.448 17 9 16.552 9 16 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 7 8 C 7 7.448 7.448 7 8 7 L 16 7 C 16.552 7 17 7.448 17 8 L 17 12 C 17 12.552 16.552 13 16 13 L 8 13 C 7.448 13 7 12.552 7 12 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="panorama-grid" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 10.333 7.333 C 10.886 7.333 11.333 7.781 11.333 8.333 L 11.333 10.333 C 11.333 10.886 10.886 11.333 10.333 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 12.333 8.333 C 12.333 7.781 12.781 7.333 13.333 7.333 L 15.333 7.333 C 15.886 7.333 16.333 7.781 16.333 8.333 L 16.333 10.333 C 16.333 10.886 15.886 11.333 15.333 11.333 L 13.333 11.333 C 12.781 11.333 12.333 10.886 12.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 10.333 12.667 C 10.886 12.667 11.333 13.114 11.333 13.667 L 11.333 15.667 C 11.333 16.219 10.886 16.667 10.333 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path>
				<path d="M 12.333 13.667 C 12.333 13.114 12.781 12.667 13.333 12.667 L 15.333 12.667 C 15.886 12.667 16.333 13.114 16.333 13.667 L 16.333 15.667 C 16.333 16.219 15.886 16.667 15.333 16.667 L 13.333 16.667 C 12.781 16.667 12.333 16.219 12.333 15.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
			</symbol>
			<symbol id="room-3d" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 6.6 9.056 C 6.6 8.533 6.905 8.059 7.381 7.842 L 8.995 7.108 C 9.436 6.907 9.938 7.23 9.938 7.715 L 9.938 16.272 C 9.938 16.757 9.436 17.08 8.995 16.879 L 7.381 16.145 C 6.905 15.928 6.6 15.454 6.6 14.931 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 10.754 7.453 C 10.754 6.795 11.378 6.316 12.014 6.487 L 16.32 7.647 C 17.193 7.882 17.8 8.674 17.8 9.578 L 17.8 14.105 C 17.8 15.009 17.193 15.801 16.32 16.036 L 12.014 17.196 C 11.378 17.367 10.754 16.889 10.754 16.231 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="model" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M 11.298 7.283 C 11.602 6.729 12.398 6.729 12.702 7.283 L 14.009 9.673 C 14.082 9.807 14.193 9.918 14.327 9.991 L 16.717 11.298 C 17.271 11.602 17.271 12.398 16.717 12.702 L 14.327 14.009 C 14.193 14.082 14.082 14.193 14.009 14.327 L 12.702 16.717 C 12.398 17.271 11.602 17.271 11.298 16.717 L 9.991 14.327 C 9.918 14.193 9.807 14.082 9.673 14.009 L 7.283 12.702 C 6.729 12.398 6.729 11.602 7.283 11.298 L 9.673 9.991 C 9.807 9.918 9.918 9.807 9.991 9.673 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="media" viewBox="0 0 24 24">
				<path d="M2,6c0-2.2,1.8-4,4-4h12c2.2,0,4,1.8,4,4v12c0,2.2-1.8,4-4,4H6c-2.2,0-4-1.8-4-4V6z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M12,19c-2.2,0-4.3-1-5.6-2.7L7,15.9c1.2,1.5,3,2.4,5,2.4c1.9,0,3.8-0.9,5-2.4l0.6,0.4C16.3,18,14.2,19,12,19z M5.5,14.7C5.2,13.8,5,12.8,5,12c0-3.5,2.7-6.5,6.2-7v0.6C8,6.1,5.7,8.8,5.7,12c0,0.8,0.1,1.5,0.4,2.4L5.5,14.7z M18,14.4 c0.3-0.8,0.4-1.6,0.4-2.4c0-3.2-2.3-5.9-5.5-6.4c0-0.2,0-0.5,0-0.6c3.5,0.4,6.2,3.4,6.2,7c0,0.8-0.2,1.8-0.5,2.7L18,14.4z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M10.2,15V8.9l5.5,3.1L10.2,15z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="nav" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 6.5 8.667 C 6.5 8.114 6.948 7.667 7.5 7.667 L 16.5 7.667 C 17.052 7.667 17.5 8.114 17.5 8.667 L 17.5 14.495 C 17.5 15.046 17.053 15.494 16.502 15.495 L 14.189 15.499 C 13.959 15.5 13.736 15.58 13.558 15.725 L 12.211 16.827 C 12.088 16.928 11.912 16.928 11.789 16.827 L 10.442 15.725 C 10.264 15.58 10.041 15.5 9.811 15.499 L 7.498 15.495 C 6.947 15.494 6.5 15.046 6.5 14.495 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="plane" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(4.667 11.5) rotate(-90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(17.333 11.5) rotate(90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 8 9 C 8 8.448 8.448 8 9 8 L 15 8 C 15.552 8 16 8.448 16 9 L 16 15 C 16 15.552 15.552 16 15 16 L 9 16 C 8.448 16 8 15.552 8 15 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="curved-plane" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(4.667 11.5) rotate(-90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(17.333 11.5) rotate(90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 8 9 C 8 8.448 8.448 8 9 8 L 15 8 C 15.552 8 16 8.448 16 9 L 16 15 C 16 15.552 15.552 16 15 16 L 9 16 C 8.448 16 8 15.552 8 15 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="texture" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 7.333 8.95 C 7.333 8.274 7.839 7.705 8.511 7.626 L 14.805 6.886 C 15.796 6.769 16.667 7.543 16.667 8.541 L 16.667 15.49 C 16.667 16.477 15.814 17.247 14.833 17.148 L 8.533 16.513 C 7.852 16.444 7.333 15.871 7.333 15.187 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="gltf" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M 11.298 7.283 C 11.602 6.729 12.398 6.729 12.702 7.283 L 14.009 9.673 C 14.082 9.807 14.193 9.918 14.327 9.991 L 16.717 11.298 C 17.271 11.602 17.271 12.398 16.717 12.702 L 14.327 14.009 C 14.193 14.082 14.082 14.193 14.009 14.327 L 12.702 16.717 C 12.398 17.271 11.602 17.271 11.298 16.717 L 9.991 14.327 C 9.918 14.193 9.807 14.082 9.673 14.009 L 7.283 12.702 C 6.729 12.398 6.729 11.602 7.283 11.298 L 9.673 9.991 C 9.807 9.918 9.918 9.807 9.991 9.673 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="tile" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 15.667 13 C 17.139 13 18.333 14.194 18.333 15.667 C 18.333 17.139 17.139 18.333 15.667 18.333 C 14.194 18.333 13 17.139 13 15.667 C 13 14.194 14.194 13 15.667 13 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="image" viewBox="0 0 24 24">
				<path d="M5 8.5c0-.828.672-1.5 1.5-1.5s1.5.672 1.5 1.5c0 .829-.672 1.5-1.5 1.5s-1.5-.671-1.5-1.5zm9 .5l-2.519 4-2.481-1.96-4 5.96h14l-5-8zm8-4v14h-20v-14h20zm2-2h-24v18h24v-18z"></path>
			</symbol>
			<symbol id="video" viewBox="0 0 24 24">
				<path d="M2.184 7.874l-2.184-.918 2.967-2.956.933 2.164-1.716 1.71zm21.816 2.126l-3 2v4l3 2v-8zm-7-2h-7.018l.79.787c.356.355.629.769.831 1.213h4.897c.276 0 .5.224.5.5v7c0 .276-.224.5-.5.5h-11c-.276 0-.5-.224-.5-.5v-2.909l-.018-.014-1.982-1.975v5.398c0 1.104.896 2 2 2h12c1.104 0 2-.896 2-2v-8c0-1.104-.896-2-2-2zm-14.65 1.13l2.967-2.956 4.044 4.029c.819.816.819 2.14 0 2.956-.819.816-2.147.815-2.967 0l-4.044-4.029z"></path>
			</symbol>
			<symbol id="stream" viewBox="0 0 24 24">
				<path d="M6.613 18.581m9.387-9.581c0 2.209-1.791 4-4 4s-4-1.791-4-4 1.791-4 4-4 4 1.791 4 4zm-2 0c0-1.103-.896-2-2-2s-2 .897-2 2 .896 2 2 2 2-.897 2-2zm-9 0c0 3.86 3.141 7 7 7s7-3.14 7-7-3.141-7-7-7-7 3.14-7 7zm16 0c0 4.97-4.029 9-9 9s-9-4.03-9-9 4.029-9 9-9 9 4.03 9 9zm-.404 12.501c1.007 1.142-.014 2.679-1.448 2.481-1.795-.245-3.236-1.702-7.147-1.702-3.91 0-5.352 1.458-7.146 1.702-1.436.198-2.456-1.34-1.449-2.481l2.898-3.289c.559.388 1.156.725 1.79.994l-2.025 2.298c1.295-.524 3.065-1.225 5.933-1.225s4.638.7 5.933 1.224l-2.025-2.298c.634-.27 1.231-.606 1.79-.994l2.896 3.29z"></path>
			</symbol>
			<symbol id="spinner" viewBox="0 0 24 24">
				<path d="M8.175 7.377l-3.042-5.27 1.732-1 3.045 5.273c-.635.238-1.222.573-1.735.997zm-.799.8l-5.27-3.042-1 1.732 5.274 3.045c.237-.635.572-1.223.996-1.735zm-1.376 3.823c0-.341.035-.673.09-.999h-6.09v1.999h6.09c-.055-.326-.09-.659-.09-1zm11.351-2.705l5.208-3.007-.333-.577-5.206 3.007c.121.185.23.379.331.577zm-5.351-3.295c.341 0 .673.035.999.09v-6.09h-1.999v6.09c.326-.055.659-.09 1-.09zm3.14.894l3.004-5.204-.288-.166-3 5.197.284.173zm1.685 8.662l5.234 3.022.666-1.154-5.229-3.019c-.181.41-.408.794-.671 1.151zm-10.444-1.467l-5.274 3.046 1 1.732 5.27-3.042c-.424-.513-.759-1.1-.996-1.736zm11.594-2.589l.025.5-.025.5h6.025v-1h-6.025zm-3.727 6.061l3.03 5.249 1.442-.833-3.031-5.25c-.437.34-.92.623-1.441.834zm-2.248.439c-.341 0-.674-.035-1-.09v6.09h1.999v-6.09c-.326.055-.658.09-.999.09zm-3.824-1.376l-3.042 5.27 1.732 1 3.045-5.274c-.635-.237-1.222-.572-1.735-.996z"></path>
			</symbol>
			<symbol id="update" viewBox="0 0 24 24">
				<path d="M23 12c0 1.042-.154 2.045-.425 3h-2.101c.335-.94.526-1.947.526-3 0-4.962-4.037-9-9-9-1.706 0-3.296.484-4.655 1.314l1.858 2.686h-6.994l2.152-7 1.849 2.673c1.684-1.049 3.659-1.673 5.79-1.673 6.074 0 11 4.925 11 11zm-6.354 7.692c-1.357.826-2.944 1.308-4.646 1.308-4.962 0-9-4.038-9-9 0-1.053.191-2.06.525-3h-2.1c-.271.955-.425 1.958-.425 3 0 6.075 4.925 11 11 11 2.127 0 4.099-.621 5.78-1.667l1.853 2.667 2.152-6.989h-6.994l1.855 2.681z"></path>
			</symbol>
			<symbol id="edit" viewBox="0 0 24 24">
				<path d="M0 1h24v2h-24v-2zm11 7h13v-2h-13v2zm0 5h13v-2h-13v2zm0 5h13v-2h-13v2zm-11 5h24v-2h-24v2zm8-17l-8 6 8 6v-12z"></path>
			</symbol>
			<symbol id="lock" viewBox="0 0 24 24">
				<path d="M18 10v-4c0-3.313-2.687-6-6-6s-6 2.687-6 6v4h-3v14h18v-14h-3zm-10 0v-4c0-2.206 1.794-4 4-4s4 1.794 4 4v4h-8z"></path>
			</symbol>
			<symbol id="volume-off" viewBox="0 0 24 24">
				<path d="M5 17h-5v-10h5v10zm2-10v10l9 5v-20l-9 5zm15.324 4.993l1.646-1.659-1.324-1.324-1.651 1.67-1.665-1.648-1.316 1.318 1.67 1.657-1.65 1.669 1.318 1.317 1.658-1.672 1.666 1.653 1.324-1.325-1.676-1.656z"></path>
			</symbol>
			<symbol id="volume-on" viewBox="0 0 24 24">
				<path d="M5 17h-5v-10h5v10zm2-10v10l9 5v-20l-9 5zm11.008 2.093c.742.743 1.2 1.77 1.198 2.903-.002 1.133-.462 2.158-1.205 2.9l1.219 1.223c1.057-1.053 1.712-2.511 1.715-4.121.002-1.611-.648-3.068-1.702-4.125l-1.225 1.22zm2.142-2.135c1.288 1.292 2.082 3.073 2.079 5.041s-.804 3.75-2.096 5.039l1.25 1.254c1.612-1.608 2.613-3.834 2.616-6.291.005-2.457-.986-4.681-2.595-6.293l-1.254 1.25z"></path>
			</symbol>
			<symbol id="fullscreen-off" viewBox="0 0 24 24">
				<path d="M15 2h2v5h7v2h-9v-7zm9 13v2h-7v5h-2v-7h9zm-15 7h-2v-5h-7v-2h9v7zm-9-13v-2h7v-5h2v7h-9z"></path>
			</symbol>
			<symbol id="fullscreen-on" viewBox="0 0 24 24">
				<path d="M24 9h-2v-7h-7v-2h9v9zm-9 15v-2h7v-7h2v9h-9zm-15-9h2v7h7v2h-9v-9zm9-15v2h-7v7h-2v-9h9z"></path>
			</symbol>
			<symbol id="navmap" viewBox="0 0 24 24">
				<path d="M24 22.586l-2.823-2.823c.526-.792.836-1.74.836-2.763 0-2.762-2.238-5-5-5s-5 2.238-5 5 2.238 5 5 5c1.016 0 1.957-.307 2.746-.827l2.827 2.827 1.414-1.414zm-9.987-5.586c0-1.654 1.346-3 3-3s3 1.346 3 3-1.346 3-3 3-3-1.346-3-3zm-4 0l.002-.034-3.015 2.175v-13.068l4-2.886v10.247c.508-.854 1.189-1.591 2-2.161v-8.086l4 2.886v3.927h.013c.336 0 .664.032.987.078v-4.007l4-2.479v8.504c1.188 1.208 1.936 2.844 2 4.653v-16.749l-6.455 4-5.545-4-5.545 4-6.455-4v18l6.455 4 3.91-2.82c-.226-.687-.352-1.419-.352-2.18zm-4.013 2.365l-4-2.479v-13.294l4 2.479v13.294z"/>
			</symbol>
			<symbol id="screen" viewBox="0 0 24 24">
				<path d="M0 0v19h24v-19h-24zm22 14h-20v-12h20v12zm-6.599 7l2.599 3h-12l2.599-3h6.802z"></path>
			</symbol>
			<symbol id="chat" viewBox="0 0 24 24">
				<path d="M22 3v13h-11.643l-4.357 3.105v-3.105h-4v-13h20zm2-2h-24v16.981h4v5.019l7-5.019h13v-16.981z"></path>
			</symbol>
			<symbol id="send" viewBox="0 0 24 24">
				<path d="M22 12l-20 12 5-12-5-12z"></path>
			</symbol>
			<symbol id="users" viewBox="0 0 24 24">
				<path d="M10.644 17.08c2.866-.662 4.539-1.241 3.246-3.682-3.932-7.427-1.042-11.398 3.111-11.398 4.235 0 7.054 4.124 3.11 11.398-1.332 2.455.437 3.034 3.242 3.682 2.483.574 2.647 1.787 2.647 3.889v1.031h-18c0-2.745-.22-4.258 2.644-4.92zm-12.644 4.92h7.809c-.035-8.177 3.436-5.313 3.436-11.127 0-2.511-1.639-3.873-3.748-3.873-3.115 0-5.282 2.979-2.333 8.549.969 1.83-1.031 2.265-3.181 2.761-1.862.43-1.983 1.34-1.983 2.917v.773z"></path>
			</symbol>
			<symbol id="virtual-tour" viewBox="0 0 24 24">
				<path d="M17 17h-10v-10h10v10zm7 3l-5-3v-10l5-3v16zm-24-16l5 3v10l-5 3v-16z"></path>
			</symbol>
			<symbol id="live-meeting" viewBox="0 0 24 24">
				<path d="M18 18h6v6h-6v-6zm-9 6h6v-6h-6v6zm-9 0h6v-6h-6v6zm0-8h24v-16h-24v16z"></path>
			</symbol>
			<symbol id="control" viewBox="0 0 24 24">
				<circle cx="7" cy="10" r="1"></circle>
				<path d="M17,3H7c-3.9,0-7,3.1-7,7v6c0,2.8,2.2,5,5,5c2.4,0,4.4-1.7,4.9-4h4.2c0.5,2.7,3.2,4.5,5.9,3.9c2.3-0.5,4-2.5,4-4.9v-6 C24,6.1,20.9,3,17,3z M17,7c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S16.4,7,17,7z M7,13c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3 S8.7,13,7,13z M15,11c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S15.6,11,15,11z M17,13c-0.6,0-1-0.4-1-1c0-0.6,0.4-1,1-1s1,0.4,1,1 C18,12.5,17.6,13,17,13z M19,11c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S19.6,11,19,11z"></path>
			</symbol>
			<symbol id="spy" viewBox="0 0 24 24">
				<path fill-rule="evenodd" d="M0.2,11.4c5.2-8.6,18.3-8.5,23.6,0c0.2,0.3,0.2,0.8,0,1.2c-5.3,8.4-18.4,8.6-23.6,0 C-0.1,12.2-0.1,11.7,0.2,11.4z M12,7.8c2.3,0,4.2,1.9,4.2,4.3s-1.9,4.2-4.2,4.2S7.8,14.3,7.8,12S9.7,7.8,12,7.8z" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="joystick" viewBox="0 0 24 24">
				<path d="M10.7,10.5V16H9.3C8.6,16,8,16.6,8,17.3h8c0-0.7-0.6-1.3-1.3-1.3h-1.3v-5.5c2.8-0.7,4.5-3.6,3.8-6.5 c-0.7-2.8-3.6-4.5-6.5-3.8S6.1,3.9,6.9,6.7C7.3,8.6,8.8,10,10.7,10.5z"></path>
				<path d="M1.4,18.6h21.2c0.7,0,1.3,0.6,1.3,1.3v2.7c0,0.7-0.6,1.3-1.3,1.3H1.4c-0.7,0-1.3-0.6-1.3-1.3V20 C0.1,19.2,0.7,18.6,1.4,18.6z"></path>
			</symbol>
			<symbol id="navinfo" viewBox="0 0 24 24">
				<path d="M12,2c5.5,0,10,4.5,10,10s-4.5,10-10,10S2,17.5,2,12S6.5,2,12,2z M12,0C5.4,0,0,5.4,0,12s5.4,12,12,12s12-5.4,12-12 S18.6,0,12,0z"/>
				<path d="M13,18h-2v-8h2V18z M12,5.8c0.7,0,1.2,0.6,1.2,1.2S12.7,8.2,12,8.2S10.8,7.7,10.8,7S11.3,5.8,12,5.8z"/>
			</symbol>
			<symbol id="check" viewBox="0 0 24 24">
				<path d="M9,21l-9-8.6l2.8-2.9l6.2,5.9L21.2,3L24,5.8L9,21z"/>
			</symbol>
			<symbol id="duplicate" viewBox="0 0 24 24">
				<path d="M18,6V0H0v18h6v6h18V6H18z M6,16H2V2h14v4H6V16z M22,22H8V8h14V22z M19,14h-3v-3h-2v3h-3v2h3v3h2v-3h3V14z"/>
			</symbol>
			<symbol id="trash" viewBox="0 0 24 24">
				<path fill-rule="evenodd" d="M19,24H5c-1.1,0-2-0.9-2-2V5H2V3h6V1.5C8,0.7,8.7,0,9.5,0h5C15.3,0,16,0.7,16,1.5V3h6v2h-1v17 C21,23.1,20.1,24,19,24z M19,5H5v16.5C5,21.8,5.2,22,5.5,22h13c0.3,0,0.5-0.2,0.5-0.5V5z M10,9c0-0.6-0.4-1-1-1S8,8.4,8,9v9 c0,0.6,0.4,1,1,1s1-0.4,1-1V9z M16,9c0-0.6-0.4-1-1-1s-1,0.4-1,1v9c0,0.6,0.4,1,1,1s1-0.4,1-1V9z M14,2h-4v1h4V2z" clip-rule="evenodd"/>
			</symbol>
			<symbol id="flags" viewBox="0 0 24 24">
				<path d="M19,18c0,1.1-0.9,2-2,2s-2-0.9-2-2s0.9-2,2-2S19,16.9,19,18z M5,15c-1.7,0-3,1.3-3,3s1.3,3,3,3h14c1.7,0,3-1.3,3-3 s-1.3-3-3-3H5z M24,18c0,2.8-2.2,5-5,5H5c-2.8,0-5-2.2-5-5s2.2-5,5-5h14C21.8,13,24,15.2,24,18z M7,4C5.9,4,5,4.9,5,6s0.9,2,2,2 s2-0.9,2-2S8.1,4,7,4z M5,3C3.3,3,2,4.3,2,6s1.3,3,3,3h14c1.7,0,3-1.3,3-3s-1.3-3-3-3H5z M24,6c0,2.8-2.2,5-5,5H5c-2.8,0-5-2.2-5-5 s2.2-5,5-5h14C21.8,1,24,3.2,24,6z"/>
			</symbol>
			<symbol id="b-here" viewBox="0 0 270 98">
				<path d="M61.5,87.9c0-2.7,0.9-5,2.8-6.9c1.9-1.9,4.2-2.8,7-2.8c1.4,0,2.7,0.2,3.9,0.8c1.2,0.5,2.2,1.2,3.2,2 c0.9,0.9,1.6,1.9,2.1,3.1s0.8,2.5,0.8,3.8s-0.2,2.6-0.8,3.8c-0.5,1.2-1.2,2.2-2.1,3.1s-1.9,1.6-3.2,2.1c-1.2,0.5-2.5,0.8-3.9,0.8 s-2.7-0.2-3.9-0.8c-1.2-0.5-2.2-1.2-3.1-2.1s-1.6-1.9-2.1-3.1S61.5,89.2,61.5,87.9z"></path>
				<path d="M16,70.2H0.7v-70H16V29c0.6-1.1,1.4-2.1,2.4-3.1s2.2-1.9,3.5-2.6s2.8-1.3,4.2-1.8c1.5-0.4,3-0.6,4.6-0.6 c3.5,0,6.7,0.6,9.6,1.9s5.4,3.1,7.4,5.3c2.1,2.2,3.7,4.9,4.8,8s1.7,6.4,1.7,10.1c0,3.6-0.6,6.9-1.7,10c-1.1,3.1-2.7,5.8-4.8,8 c-2.1,2.2-4.5,4-7.4,5.3s-6.1,2-9.6,2c-1.6,0-3.1-0.2-4.6-0.7c-1.5-0.4-2.9-1-4.2-1.7c-1.3-0.7-2.5-1.5-3.5-2.5s-1.8-2-2.4-3.1 C16,63.5,16,70.2,16,70.2z M27.6,58.5c1.7,0,3.2-0.3,4.6-1c1.4-0.7,2.6-1.5,3.6-2.7c1-1.1,1.8-2.4,2.4-3.9c0.6-1.5,0.8-3.1,0.8-4.8 s-0.3-3.2-0.8-4.7c-0.6-1.5-1.4-2.8-2.4-3.9c-1-1.1-2.2-2-3.6-2.7c-1.4-0.7-2.9-1-4.6-1s-3.3,0.3-4.8,1c-1.4,0.7-2.7,1.6-3.7,2.7 c-1,1.1-1.8,2.4-2.3,3.9c-0.6,1.5-0.8,3-0.8,4.7s0.3,3.2,0.8,4.8s1.3,2.8,2.3,3.9c1,1.1,2.2,2,3.7,2.7 C24.3,58.2,25.9,58.5,27.6,58.5z"></path>
				<path d="M64.1,0.2h14.8V29c1.3-2.5,3.3-4.5,6-6s5.9-2.2,9.6-2.2c3.1,0,5.8,0.5,7.9,1.4c2.1,1,3.9,2.3,5.2,4.1 c1.5,1.9,2.6,4,3.1,6.5s0.8,5.4,0.8,8.9v28.5H96.7V45.5c0-3.5-0.6-6.3-1.8-8.5c-1.2-2.2-3.5-3.2-6.7-3.2c-3.1,0-5.5,1.1-7,3.3 s-2.3,5.2-2.3,8.9v24.2H64.1V0.2z"></path>
				<path d="M135.9,49.8c0.1,1.5,0.3,2.9,0.7,4.2s1,2.4,1.8,3.4s1.9,1.7,3.2,2.3s3,0.8,5,0.8c2.7,0,4.7-0.5,6-1.6 c1.4-1.1,2.3-2.4,2.9-3.9h15c-0.3,2.3-1.1,4.4-2.4,6.4c-1.2,2-2.9,3.8-4.9,5.2c-2,1.5-4.4,2.7-7.2,3.5c-2.8,0.9-5.9,1.3-9.3,1.3 c-4.2,0-7.9-0.6-11.2-1.8c-3.2-1.2-6-3-8.2-5.2c-2.2-2.3-3.9-5-5-8c-1.1-3.1-1.7-6.5-1.7-10.2c0-3.5,0.5-6.8,1.6-9.9s2.7-5.8,4.9-8 c2.2-2.3,4.8-4.1,8-5.5c3.2-1.3,6.8-2,11-2c3.8,0,7.2,0.6,10.2,1.8c3,1.2,5.6,2.8,7.8,4.8s3.8,4.3,5,7s1.8,5.5,1.8,8.4 c0,1,0,2.1,0,3.2c0,1.1-0.2,2.4-0.5,3.9h-34.5V49.8z M146.2,31c-3,0-5.5,0.9-7.4,2.6c-1.9,1.7-2.9,4.2-2.9,7.5h20.2 c0-3.1-0.9-5.6-2.8-7.4C151.5,31.9,149.1,31,146.2,31z"></path>
				<path d="M216.1,36c-1.1-0.3-2-0.5-2.7-0.6c-0.7-0.1-1.6-0.1-2.7-0.1c-4.2,0-7.6,1.2-10.1,3.7s-3.8,6.6-3.8,12.5v18.8h-15.3V22h15.3 v7.8c1.1-2.3,3-4.3,5.7-6c2.6-1.7,5.6-2.6,9-2.6c1.8,0,3.3,0.3,4.6,0.8V36z"></path>
				<path d="M234.3,49.8c0.1,1.5,0.3,2.9,0.7,4.2s1,2.4,1.8,3.4s1.9,1.7,3.2,2.3s3,0.8,5,0.8c2.7,0,4.7-0.5,6-1.6 c1.4-1.1,2.3-2.4,2.9-3.9h15c-0.3,2.3-1.1,4.4-2.4,6.4c-1.2,2-2.9,3.8-4.9,5.2c-2,1.5-4.4,2.7-7.2,3.5c-2.8,0.9-5.9,1.3-9.3,1.3 c-4.2,0-7.9-0.6-11.2-1.8c-3.2-1.2-6-3-8.2-5.2c-2.2-2.3-3.9-5-5-8c-1.1-3.1-1.7-6.5-1.7-10.2c0-3.5,0.5-6.8,1.6-9.9s2.7-5.8,4.9-8 c2.2-2.3,4.8-4.1,8-5.5c3.2-1.3,6.8-2,11-2c3.8,0,7.2,0.6,10.2,1.8c3,1.2,5.6,2.8,7.8,4.8c2.2,2,3.8,4.3,5,7s1.8,5.5,1.8,8.4 c0,1,0,2.1,0,3.2c0,1.1-0.2,2.4-0.5,3.9h-34.5V49.8z M244.6,31c-3,0-5.5,0.9-7.4,2.6c-1.9,1.7-2.9,4.2-2.9,7.5h20.2 c0-3.1-0.9-5.6-2.8-7.4C249.9,31.9,247.5,31,244.6,31z"></path>
			</symbol>
		</svg>
	`;class AppComponent extends rxcomp.Component {
  onInit() {
    const routes = AppRoutesInit();
    RouterService.useBrowser(routes);
    AssetGroupTypeInit();
    RouterService.event$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      const route = event.route;

      if (route && route.params.mode === 'embed') {
        environment.flags.like = false;
      }

      LanguageService.setRoute(route, routes);
    });
    LanguageService.lang$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(_ => {
      this.pushChanges();
    });
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
  }

}
AppComponent.meta = {
  selector: '[b-here-component]',
  template:
  /* html */
  `
		<!-- svg -->
		${SVG_CHUNK}
		<!-- header -->
		<router-outlet></router-outlet>
		<!-- footer -->
		<div class="toast-outlet" toast-outlet></div>
		<div class="modal-outlet" modal-outlet></div>
	`
};const MIME_IMAGE = ['bmp', 'gif', 'ico', 'jpeg', 'jpg', 'png', 'svg', 'tif', 'tiff', 'webp', 'hdr'];
const MIME_VIDEO = ['mp4', 'avi', 'mpeg', 'ogv', 'ts', 'webm', '3gp', '3g2'];
const MIME_MODEL = ['fbx', 'gltf', 'glb', 'obj', 'usdz'];
const MIME_STREAM = ['publisherStream', 'nextAttendeeStream', 'publisherScreen', 'attendeeScreen'];
function isImage(path) {
  return new RegExp(`/\.(${MIME_IMAGE.join('|')})$/i`).test(path);
}
function isVideo(path) {
  return new RegExp(`/\.(${MIME_VIDEO.join('|')})$/i`).test(path);
}
function isModel(path) {
  return new RegExp(`/\.(${MIME_MODEL.join('|')})$/i`).test(path);
}
function isStream(path) {
  return MIME_STREAM.indexOf(path) !== -1;
}
class AssetPipe extends rxcomp.Pipe {
  static transform(asset, type) {
    if (type === void 0) {
      type = null;
    }

    if (type != null) {
      // keep loose equality
      asset = asset.type.name === type ? asset : null;
    }

    if (asset) {
      if (typeof asset === 'string') {
        return environment.getPath(asset);
      } // console.log(asset.type.name, AssetType.Image.name);


      switch (asset.type.name) {
        case AssetType.Image.name:
        case AssetType.Video.name:
          asset = asset.folder + asset.file;
          asset = environment.getPath(asset);
          break;

        case AssetType.Model.name:
          asset = asset.folder + asset.file;
          asset = environment.getPath(asset);
          break;

        case AssetType.PublisherStream.name:
        case AssetType.AttendeeStream.name:
        case AssetType.PublisherScreen.name:
        case AssetType.AttendeeScreen.name:
        case AssetType.SmartDeviceStream.name:
          asset = environment.getPath(asset.file);
          break;

        default:
          if (isImage(asset.file) || isVideo(asset.file)) {
            asset = asset.folder + asset.file;
            asset = environment.getPath(asset);
          } else if (isModel(asset.file)) {
            asset = asset.folder + asset.file;
            asset = environment.getPath(asset);
          } else if (isStream(asset.file)) {
            asset = asset.file;
          }

      }

      asset = asset;
    } else {
      asset = null;
    } // console.log('AssetPipe.transform', asset);


    return asset;
  }

}
AssetPipe.meta = {
  name: 'asset'
};class ControlRequestModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }

  onAccept(user) {
    ModalService.resolve();
  }

  onReject(user) {
    ModalService.reject();
  }
  /*
  onDestroy() {
  	// console.log('ControlRequestModalComponent.onDestroy');
  }
  */


  onClose() {
    ModalService.reject();
  }

}
ControlRequestModalComponent.meta = {
  selector: '[control-request-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">L'utente ha richiesto il controllo della navigazione. Accetti?</div>
				<div class="group--cta">
					<button type="button" class="btn--cancel" (click)="onReject()">
						<span>Rifiuta</span>
					</button>
					<button type="button" class="btn--accept" (click)="onAccept()">
						<span>Accetta</span>
					</button>
				</div>
			</div>
		</div>
	`
};

ControlRequestModalComponent.chunk = () =>
/* html */
`<div class="control-request-modal" control-request-modal></div>`;class DropDirective extends rxcomp.Directive {
  onInit() {
    const {
      module,
      node,
      parentInstance,
      selector
    } = rxcomp.getContext(this);
    const event = 'drop';
    const event$ = rxjs.fromEvent(node, event).pipe(operators.shareReplay(1));
    const expression = node.getAttribute(`(${event})`);

    if (expression) {
      const outputFunction = module.makeFunction(expression, ['$event']);
      event$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
        module.resolve(outputFunction, parentInstance, event);
      });
      rxjs.fromEvent(node, 'dragover').pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => event.preventDefault());
    } else {
      parentInstance[`${event}$`] = event$;
    } // console.log('DropDirective.onInit', 'selector', selector, 'event', event);

  }

}
DropDirective.meta = {
  selector: `[(drop)]`
};let DROPDOWN_ID = 1000000;
class DropdownDirective extends rxcomp.Directive {
  get id() {
    return this.dropdown || this.id_ || (this.id_ = DropdownDirective.nextId());
  }

  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    const trigger = node.getAttribute('dropdown-trigger');
    this.trigger = trigger ? node.querySelector(trigger) : node;
    this.opened = null;
    this.onClick = this.onClick.bind(this);
    this.onDocumentClick = this.onDocumentClick.bind(this);
    this.openDropdown = this.openDropdown.bind(this);
    this.closeDropdown = this.closeDropdown.bind(this);
    this.addListeners();
    DropdownDirective.dropdown$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(id => {
      // console.log('DropdownDirective', id, this['dropdown-item']);
      if (this.id === id) {
        node.classList.add('dropped');
      } else {
        node.classList.remove('dropped');
      }
    });
  }

  onClick(event) {
    const {
      node
    } = rxcomp.getContext(this);

    if (this.opened === null) {
      this.openDropdown();
    } else {
      const dropdownItemNode = node.querySelector('[dropdown-item]'); // console.log('dropdownItemNode', dropdownItemNode);

      if (!dropdownItemNode) {
        // if (this.trigger !== node) {
        this.closeDropdown();
      }
    }
  }

  onDocumentClick(event) {
    const {
      node
    } = rxcomp.getContext(this);
    const clickedInside = node === event.target || node.contains(event.target);

    if (!clickedInside) {
      this.closeDropdown();
    }
  }

  openDropdown() {
    if (this.opened === null) {
      this.opened = true;
      this.addDocumentListeners();
      DropdownDirective.dropdown$.next(this.id);
      this.dropped.next(this.id);
    }
  }

  closeDropdown() {
    if (this.opened !== null) {
      this.removeDocumentListeners();
      this.opened = null;

      if (DropdownDirective.dropdown$.getValue() === this.id) {
        DropdownDirective.dropdown$.next(null);
        this.dropped.next(null);
      }
    }
  }

  addListeners() {
    this.trigger.addEventListener('click', this.onClick);
  }

  addDocumentListeners() {
    document.addEventListener('click', this.onDocumentClick);
  }

  removeListeners() {
    this.trigger.removeEventListener('click', this.onClick);
  }

  removeDocumentListeners() {
    document.removeEventListener('click', this.onDocumentClick);
  }

  onDestroy() {
    this.removeListeners();
    this.removeDocumentListeners();
  }

  static nextId() {
    return DROPDOWN_ID++;
  }

}
DropdownDirective.meta = {
  selector: '[dropdown]',
  inputs: ['dropdown', 'dropdown-trigger'],
  outputs: ['dropped']
};
DropdownDirective.dropdown$ = new rxjs.BehaviorSubject(null);class DropdownItemDirective extends rxcomp.Directive {
  get id() {
    return this['dropdown-item'];
  }

  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('dropdown-item');
    DropdownDirective.dropdown$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(id => {
      // console.log('DropdownItemDirective', id, this['dropdown-item']);
      if (this.id === id) {
        node.classList.add('dropped');
      } else {
        node.classList.remove('dropped');
      }
    });
  }

}
DropdownItemDirective.meta = {
  selector: '[dropdown-item], [[dropdown-item]]',
  inputs: ['dropdown-item']
};class ToastOutletComponent extends rxcomp.Component {
  onInit() {
    this.toast = null;
    this.lastToast = null;
    ToastService.toast$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(toast => {
      if (toast) {
        this.lastToast = toast;
      }

      this.toast = toast;
      this.pushChanges();
    }); // console.log('ToastOutletComponent.onInit');
  }

  getClass() {
    const classList = {};

    if (this.toast) {
      classList.active = true;
    }

    if (this.lastToast) {
      classList[this.lastToast.type] = true;
      classList[this.lastToast.position] = true;
    }

    return classList;
  }

  onClose() {
    ToastService.reject(this.toast);
  }

  onAccept() {
    ToastService.resolve(this.toast);
  }

  onReject() {
    ToastService.reject(this.toast);
  }

}
ToastOutletComponent.meta = {
  selector: '[toast-outlet]',
  template:
  /* html */
  `
	<div class="toast-outlet__container" [class]="getClass()">
		<div class="toast-outlet__toast" *if="lastToast">
			<span class="toast-outlet__message" [innerHTML]="lastToast.message"></span>
			<div class="group--cta" *if="lastToast.type != 'info'">
				<button type="button" class="btn--accept" (click)="onAccept()">
					<span [innerHTML]="lastToast.acceptMessage"></span>
				</button>
				<button type="button" class="btn--cancel" (click)="onReject()" *if="lastToast.type == 'dialog'">
					<span [innerHTML]="lastToast.rejectMessage"></span>
				</button>
			</div>
			<button type="button" class="btn--close" (click)="onClose()" *if="lastToast.type != 'info'">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
	</div>
	`
};class AsideComponent extends rxcomp.Component {
  onInit() {
    this.mode = 1;
    this.viewTypes = Object.keys(ViewType).map(key => {
      const type = ViewType[key];
      return {
        type: type,
        name: LabelPipe.getKeys('editor', type.name),
        disabled: environment.editor.disabledViewTypes.indexOf(type.name) !== -1
      };
    });
    this.viewItemTypes = Object.keys(ViewItemType).map(key => {
      const type = ViewItemType[key];
      return {
        type: type,
        name: LabelPipe.getKeys('editor', type.name),
        disabled: environment.editor.disabledViewItemTypes.indexOf(type.name) !== -1
      };
    });
    this.setSupportedViewTypes();
    this.setSupportedViewItemTypes();
  }

  onChanges() {
    this.setSupportedViewTypes();
    this.setSupportedViewItemTypes();
  }

  setSupportedViewTypes() {
    this.supportedViewTypes = this.viewTypes.filter(x => this.supportedViewType(x.type.name)).sort((a, b) => {
      if (a.disabled === b.disabled) {
        return 0; // (a.type.name < b.type.name) ? -1 : (a.type.name > b.type.name) ? 1 : 0;
      } else {
        return a.disabled ? 1 : -1;
      }
    });
  }

  setSupportedViewItemTypes() {
    if (this.view) {
      this.supportedViewItemTypes = this.viewItemTypes.filter(x => this.supportedViewItemType(this.view.type.name, x.type.name)).sort((a, b) => {
        if (a.disabled === b.disabled) {
          return 0; // (a.type.name < b.type.name) ? -1 : (a.type.name > b.type.name) ? 1 : 0;
        } else {
          return a.disabled ? 1 : -1;
        }
      });
    } else {
      this.supportedViewItemTypes = [];
    }
  }

  setMode(mode) {
    if (this.mode !== mode) {
      this.mode = mode;
      this.pushChanges();
    }
  }

  supportedViewType(viewTypeName) {
    let supported = [ViewType.Panorama.name, ViewType.PanoramaGrid.name, ViewType.Room3d.name, ViewType.Model.name, ViewType.Media.name].indexOf(viewTypeName) !== -1; // ViewType.WaitingRoom,
    // console.log('supportedViewType', viewType, supported);

    return supported;
  }

  supportedViewItemType(viewTypeName, viewItemTypeName) {
    let supported;

    switch (viewTypeName) {
      case ViewType.WaitingRoom.name:
        supported = false;
        break;

      case ViewType.Panorama.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;

      case ViewType.PanoramaGrid.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;

      case ViewType.Room3d.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.Texture.name].indexOf(viewItemTypeName) !== -1;
        break;

      case ViewType.Model.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;

      case ViewType.Media.name:
        supported = [].indexOf(viewItemTypeName) !== -1;
        break;
    } // console.log('supportedViewItemType', viewTypeName, viewItemTypeName, supported);


    return supported;
  }

  onSelect(event) {
    this.select.next(event);
  }

  onUpdate(event) {
    this.update.next(event);
  }

  onDelete(event) {
    this.delete.next(event);
  }

}
AsideComponent.meta = {
  selector: '[aside]',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view'],
  template:
  /* html */
  `
	<div class="headline">
		<ul class="nav--tab">
			<li [class]="{ active: mode === 1 }" (click)="setMode(1)" [innerHTML]="'editor_properties' | label"></li>
			<li [class]="{ active: mode === 2 }" (click)="setMode(2)" [innerHTML]="'editor_views' | label"></li>
			<li [class]="{ active: mode === 3 }" (click)="setMode(3)" [innerHTML]="'editor_view_items' | label"></li>
		</ul>
		<!--
		<div class="btn--mode" [class]="{ active: mode === 1 }" (click)="setMode(1)" [innerHTML]="'editor_properties' | label"></div>
		<div class="btn--mode" [class]="{ active: mode === 2 }" (click)="setMode(2)" [innerHTML]="'editor_views' | label"></div>
		<div class="btn--mode" [class]="{ active: mode === 3 }" (click)="setMode(3)" [innerHTML]="'editor_view_items' | label"></div>
		-->
	</div>
	<div class="scrollable">
		<ul class="nav--editor" *if="mode === 1">
			<li>
				<div class="title" [innerHTML]="'editor_properties' | label"></div>
				<update-view [view]="view" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)"></update-view>
			</li>
			<li *if="view.type.name != 'panorama-grid'">
				<div class="title" [innerHTML]="'editor_items' | label"></div>
				<update-view-item [view]="view" [item]="item" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)" *for="let item of view.pathItems"></update-view-item>
				<div class="abstract" *if="view.pathItems.length == 0" [innerHTML]="'editor_no_items' | label"></div>
				<div class="btn--mode" (click)="setMode(3)" [innerHTML]="'editor_add_item' | label"></div>
			</li>
			<li *if="view.type.name == 'panorama-grid'">
				<div class="title" [innerHTML]="'editor_tiles' | label"></div>
				<div *for="let tile of view.tiles">
					<div *if="tile.selected">
						<update-view-tile [view]="view" [tile]="tile" (update)="onUpdate($event)" (delete)="onDelete($event)"></update-view-tile>
						<ul class="nav--editor">
							<li>
								<update-view-item [view]="view" [item]="item" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)" *for="let item of tile.navs"></update-view-item>
								<div class="abstract" *if="tile.navs.length == 0" [innerHTML]="'editor_no_navs' | label"></div>
								<div class="btn--mode" (click)="onSelect({ type:'viewItem', value: 'nav', tile: tile })" [innerHTML]="'editor_add_nav' | label"></div>
							</li>
							<!--
							<li>
								<div class="btn" (click)="onSelect({ type:'viewItem', value: 'nav', tile: tile })">
									<div class="icon">
										<svg-icon name="nav"></svg-icon>
									</div>
									<div class="title" [innerHTML]="'editor_add_nav' | label"></div>
								</div>
							</li>
							-->
						</ul>
					</div>
				</div>
				<div class="abstract" *if="view.tiles.length == 0" [innerHTML]="'editor_no_tiles' | label"></div>
				<!-- <div class="btn--mode" (click)="setMode(3)">Add Tile</div> -->
			</li>
			<!--
			<li *if="false">
				<div class="title">Icons</div>
				<ul class="nav--editor">
					<li>
						<div class="btn" (click)="onSelect('animated-tabs')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 2 8.4 L 12 8.4 L 12 2 L 6 2 C 3.791 2 2 3.791 2 6 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 8.4 L 22 8.4 L 22 6 C 22 3.791 20.209 2 18 2 L 12 2 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Animated Tabs</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('card-list')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 6.8 13.6 C 6.8 13.158 7.158 12.8 7.6 12.8 L 16.8 12.8 C 17.242 12.8 17.6 13.158 17.6 13.6 L 17.6 16.8 C 17.6 17.242 17.242 17.6 16.8 17.6 L 7.6 17.6 C 7.158 17.6 6.8 17.242 6.8 16.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 6.8 7.2 C 6.8 6.758 7.158 6.4 7.6 6.4 L 16.8 6.4 C 17.242 6.4 17.6 6.758 17.6 7.2 L 17.6 10.4 C 17.6 10.842 17.242 11.2 16.8 11.2 L 7.6 11.2 C 7.158 11.2 6.8 10.842 6.8 10.4 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Card List</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('container-transitions')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.667 13 C 17.139 13 18.333 14.194 18.333 15.667 C 18.333 17.139 17.139 18.333 15.667 18.333 C 14.194 18.333 13 17.139 13 15.667 C 13 14.194 14.194 13 15.667 13 Z" fill="var(--svg-icon-tint)"></path></svg></svg></div>
							<div class="title">Container Transitions</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('dynamic-grid')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><g transform="translate(6.6 6.6)"><path d="M 6.048 0.8 C 6.048 0.358 6.406 0 6.848 0 L 10 0 C 10.442 0 10.8 0.358 10.8 0.8 L 10.8 3.952 C 10.8 4.394 10.442 4.752 10 4.752 L 6.848 4.752 C 6.406 4.752 6.048 4.394 6.048 3.952 Z" fill="var(--svg-icon-tint)" opacity="0.5"></path><path d="M 6.048 6.848 C 6.048 6.406 6.406 6.048 6.848 6.048 L 10 6.048 C 10.442 6.048 10.8 6.406 10.8 6.848 L 10.8 10 C 10.8 10.442 10.442 10.8 10 10.8 L 6.848 10.8 C 6.406 10.8 6.048 10.442 6.048 10 Z" fill="var(--svg-icon-tint)"></path><path d="M 0 0.8 C 0 0.358 0.358 0 0.8 0 L 3.952 0 C 4.394 0 4.752 0.358 4.752 0.8 L 4.752 3.952 C 4.752 4.394 4.394 4.752 3.952 4.752 L 0.8 4.752 C 0.358 4.752 0 4.394 0 3.952 Z" fill="var(--svg-icon-tint)"></path><path d="M 0 6.848 C 0 6.406 0.358 6.048 0.8 6.048 L 3.952 6.048 C 4.394 6.048 4.752 6.406 4.752 6.848 L 4.752 10 C 4.752 10.442 4.394 10.8 3.952 10.8 L 0.8 10.8 C 0.358 10.8 0 10.442 0 10 Z" fill="var(--svg-icon-tint)" opacity="0.5"></path></g></svg></div>
							<div class="title">Dynamic Grid</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('expand-on-tap')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 0 0 L 7.833 0" transform="translate(8.583 11.583) rotate(270 3.917 0.5)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 14.667 9.333 L 12 6.667 L 9.333 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="1.67" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 14.667 14.667 L 12 17.333 L 9.333 14.667" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="1.67" stroke-linecap="round" stroke-linejoin="round"></path> </svg></div>
							<div class="title">Expand on Tap</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('image-gallery-2')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 10.333 7.333 C 10.886 7.333 11.333 7.781 11.333 8.333 L 11.333 10.333 C 11.333 10.886 10.886 11.333 10.333 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.333 8.333 C 12.333 7.781 12.781 7.333 13.333 7.333 L 15.333 7.333 C 15.886 7.333 16.333 7.781 16.333 8.333 L 16.333 10.333 C 16.333 10.886 15.886 11.333 15.333 11.333 L 13.333 11.333 C 12.781 11.333 12.333 10.886 12.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.333 12.667 C 15.886 12.667 16.333 13.114 16.333 13.667 L 16.333 15.667 C 16.333 16.219 15.886 16.667 15.333 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Image Gallery 2</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-ui')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 6.8 4.8 C 7.905 4.8 8.8 5.695 8.8 6.8 C 8.8 7.905 7.905 8.8 6.8 8.8 C 5.695 8.8 4.8 7.905 4.8 6.8 C 4.8 5.695 5.695 4.8 6.8 4.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 4.8 C 13.105 4.8 14 5.695 14 6.8 C 14 7.905 13.105 8.8 12 8.8 C 10.895 8.8 10 7.905 10 6.8 C 10 5.695 10.895 4.8 12 4.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 17.2 4.8 C 18.305 4.8 19.2 5.695 19.2 6.8 C 19.2 7.905 18.305 8.8 17.2 8.8 C 16.095 8.8 15.2 7.905 15.2 6.8 C 15.2 5.695 16.095 4.8 17.2 4.8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Stories UI</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('todo-list')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8 12.333 L 10.5 14.833 L 16 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">To-Do List</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('toggle-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 17.333 15.333 C 18.438 15.333 19.333 16.229 19.333 17.333 C 19.333 18.438 18.438 19.333 17.333 19.333 C 16.229 19.333 15.333 18.438 15.333 17.333 C 15.333 16.229 16.229 15.333 17.333 15.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 17.333 10 C 18.438 10 19.333 10.895 19.333 12 C 19.333 13.105 18.438 14 17.333 14 C 16.229 14 15.333 13.105 15.333 12 C 15.333 10.895 16.229 10 17.333 10 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 17.333 4.667 C 18.438 4.667 19.333 5.562 19.333 6.667 C 19.333 7.771 18.438 8.667 17.333 8.667 C 16.229 8.667 15.333 7.771 15.333 6.667 C 15.333 5.562 16.229 4.667 17.333 4.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Toggle Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('bottom-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 10.333 C 22 10.886 21.552 11.333 21 11.333 L 3 11.333 C 2.448 11.333 2 10.886 2 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 13.333 C 2 12.781 2.448 12.333 3 12.333 L 21 12.333 C 21.552 12.333 22 12.781 22 13.333 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Bottom Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('draggable-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 14 C 2 12.895 2.895 12 4 12 L 20 12 C 21.105 12 22 12.895 22 14 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z M 10.667 15.333 L 13.333 15.333 C 13.702 15.333 14 15.035 14 14.667 C 14 14.298 13.702 14 13.333 14 L 10.667 14 C 10.298 14 10 14.298 10 14.667 C 10 15.035 10.298 15.333 10.667 15.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Draggable Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('modal-box')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 9.333 C 7.333 8.229 8.229 7.333 9.333 7.333 L 14.667 7.333 C 15.771 7.333 16.667 8.229 16.667 9.333 L 16.667 14.667 C 16.667 15.771 15.771 16.667 14.667 16.667 L 9.333 16.667 C 8.229 16.667 7.333 15.771 7.333 14.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Modal Box</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('side-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 11 2 C 11.552 2 12 2.448 12 3 L 12 21 C 12 21.552 11.552 22 11 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Side Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 11.667 7.333 C 11.667 7.333 11.667 7.333 11.667 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 9 C 16.667 9.552 16.219 10 15.667 10 L 13.333 10 L 13.333 15.667 C 13.333 16.219 12.886 16.667 12.333 16.667 L 11.667 16.667 C 11.114 16.667 10.667 16.219 10.667 15.667 L 10.667 10 L 8.333 10 C 7.781 10 7.333 9.552 7.333 9 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Input Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('loading-indicator')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 16.4 10.4 C 17.284 10.4 18 11.116 18 12 C 18 12.884 17.284 13.6 16.4 13.6 C 15.516 13.6 14.8 12.884 14.8 12 C 14.8 11.116 15.516 10.4 16.4 10.4 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 10.4 C 12.884 10.4 13.6 11.116 13.6 12 C 13.6 12.884 12.884 13.6 12 13.6 C 11.116 13.6 10.4 12.884 10.4 12 C 10.4 11.116 11.116 10.4 12 10.4 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.6 10.4 C 8.484 10.4 9.2 11.116 9.2 12 C 9.2 12.884 8.484 13.6 7.6 13.6 C 6.716 13.6 6 12.884 6 12 C 6 11.116 6.716 10.4 7.6 10.4 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Loading Indicator</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('radio-button-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 9.833 8.167 L 14.167 8.167 C 16.284 8.167 18 9.883 18 12 C 18 14.117 16.284 15.833 14.167 15.833 L 9.833 15.833 C 7.716 15.833 6 14.117 6 12 C 6 9.883 7.716 8.167 9.833 8.167 Z M 11.333 12 C 11.333 13.473 12.527 14.667 14 14.667 C 15.473 14.667 16.667 13.473 16.667 12 C 16.667 10.527 15.473 9.333 14 9.333 C 12.527 9.333 11.333 10.527 11.333 12 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Radio Button Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('checkbox-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8.651 6.931 C 7.911 6.738 7.238 7.411 7.431 8.151 L 9.363 15.558 C 9.592 16.435 10.775 16.58 11.208 15.784 L 13 12.5 L 16.284 10.708 C 17.08 10.275 16.935 9.092 16.058 8.863 Z" fill="var(--svg-icon-tint)"></path><path d="M 16 15.5 L 11 10.5" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round"></path></svg></div>
							<div class="title">Checkbox Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('splash-screen')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.757 13.414 C 6.976 12.633 6.976 11.367 7.757 10.586 L 10.586 7.757 C 11.367 6.976 12.633 6.976 13.414 7.757 L 16.243 10.586 C 17.024 11.367 17.024 12.633 16.243 13.414 L 13.414 16.243 C 12.633 17.024 11.367 17.024 10.586 16.243 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Splash Screen</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('timeout-transition')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1 5.8 C 1 3.149 3.149 1 5.8 1 L 18.2 1 C 20.851 1 23 3.149 23 5.8 L 23 18.2 C 23 20.851 20.851 23 18.2 23 L 5.8 23 C 3.149 23 1 20.851 1 18.2 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 12 6.72 C 14.916 6.72 17.28 9.084 17.28 12 C 17.28 14.916 14.916 17.28 12 17.28 C 9.084 17.28 6.72 14.916 6.72 12 C 6.72 9.084 9.084 6.72 12 6.72 Z M 11.34 12 C 11.34 12.365 11.635 12.66 12 12.66 L 14.2 12.66 C 14.565 12.66 14.86 12.365 14.86 12 C 14.86 11.635 14.565 11.34 14.2 11.34 L 12.66 11.34 L 12.66 9.8 C 12.66 9.435 12.365 9.14 12 9.14 C 11.635 9.14 11.34 9.435 11.34 9.8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Timeout Transition</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('accordion-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 16 10.667 L 12 14.667 L 8 10.667" fill="transparent" stroke-width="2" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Accordion Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('drop-on-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 0 0 L 8 0" transform="translate(8.5 11.5) rotate(270 4 0.5)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 15.333 11.333 L 12 8 L 8.667 11.333" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Drop on Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('nested-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 7 C 21.82 7.552 21.372 8 20.82 8 L 2.82 8 C 2.267 8 1.82 7.552 1.82 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 1.82 17 C 1.82 16.448 2.267 16 2.82 16 L 20.82 16 C 21.372 16 21.82 16.448 21.82 17 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 8.82 10 C 8.82 9.448 9.267 9 9.82 9 L 20.82 9 C 21.372 9 21.82 9.448 21.82 10 L 21.82 14 C 21.82 14.552 21.372 15 20.82 15 L 9.82 15 C 9.267 15 8.82 14.552 8.82 14 Z" fill="var(--svg-icon-tint)"></path><path d="M 1.82 10 C 1.82 9.448 2.267 9 2.82 9 L 6.82 9 C 7.372 9 7.82 9.448 7.82 10 L 7.82 14 C 7.82 14.552 7.372 15 6.82 15 L 2.82 15 C 2.267 15 1.82 14.552 1.82 14 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Nested Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('star-rating')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 11.399 6.884 C 11.645 6.386 12.355 6.386 12.601 6.884 L 13.705 9.122 C 13.803 9.32 13.992 9.457 14.21 9.489 L 16.68 9.848 C 17.229 9.928 17.449 10.603 17.051 10.99 L 15.264 12.733 C 15.106 12.887 15.034 13.108 15.071 13.326 L 15.493 15.786 C 15.587 16.333 15.013 16.75 14.521 16.492 L 12.312 15.331 C 12.117 15.228 11.883 15.228 11.688 15.331 L 9.479 16.492 C 8.987 16.75 8.413 16.333 8.507 15.786 L 8.929 13.326 C 8.966 13.108 8.894 12.887 8.736 12.733 L 6.949 10.99 C 6.551 10.603 6.771 9.928 7.32 9.848 L 9.79 9.489 C 10.008 9.457 10.197 9.32 10.295 9.122 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Star Rating</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('swipe-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 17.33 C 2 16.595 2.595 16 3.33 16 L 21 16 C 21.552 16 22 16.448 22 17 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 10 C 2 9.448 2.448 9 3 9 L 14 9 C 14.552 9 15 9.448 15 10 L 15 14 C 15 14.552 14.552 15 14 15 L 3 15 C 2.448 15 2 14.552 2 14 Z M 19 9 C 20.657 9 22 10.343 22 12 C 22 13.657 20.657 15 19 15 C 17.343 15 16 13.657 16 12 C 16 10.343 17.343 9 19 9 Z" fill="var(--svg-icon-tint)"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 7 C 22 7.552 21.552 8 21 8 L 3 8 C 2.448 8 2 7.552 2 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Swipe Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('switch-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.667 13.333 C 17.139 13.333 18.333 14.527 18.333 16 C 18.333 17.473 17.139 18.667 15.667 18.667 C 14.194 18.667 13 17.473 13 16 C 13 14.527 14.194 13.333 15.667 13.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 8.333 13.333 C 9.806 13.333 11 14.527 11 16 C 11 17.473 9.806 18.667 8.333 18.667 C 6.861 18.667 5.667 17.473 5.667 16 C 5.667 14.527 6.861 13.333 8.333 13.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Switch Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('tab-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 10 15.333 L 14 15.333 L 14 18.667 L 10 18.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 5.333 16.333 C 5.333 15.781 5.781 15.333 6.333 15.333 L 9.333 15.333 L 9.333 18.667 L 6.333 18.667 C 5.781 18.667 5.333 18.219 5.333 17.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 18.667 16.333 C 18.667 15.781 18.219 15.333 17.667 15.333 L 14.667 15.333 L 14.667 18.667 L 17.667 18.667 C 18.219 18.667 18.667 18.219 18.667 17.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Tab Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('wheel-picker')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 3.667 6 C 3.667 3.791 5.458 2 7.667 2 L 16.333 2 C 18.542 2 20.333 3.791 20.333 6 L 20.333 7 C 20.333 7.552 19.886 8 19.333 8 L 4.667 8 C 4.114 8 3.667 7.552 3.667 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 11 C 2 9.895 2.895 9 4 9 L 20 9 C 21.105 9 22 9.895 22 11 L 22 13 C 22 14.105 21.105 15 20 15 L 4 15 C 2.895 15 2 14.105 2 13 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.667 17 C 3.667 16.448 4.114 16 4.667 16 L 19.333 16 C 19.886 16 20.333 16.448 20.333 17 L 20.333 18 C 20.333 20.209 18.542 22 16.333 22 L 7.667 22 C 5.458 22 3.667 20.209 3.667 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Wheel Picker</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('cover-flow')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 11.333 17.962 C 11.333 18.385 11.068 18.762 10.67 18.904 L 4.673 21.045 C 3.37 21.511 2 20.545 2 19.162 L 2 4.838 C 2 3.455 3.37 2.489 4.673 2.955 L 10.67 5.096 C 11.068 5.238 11.333 5.615 11.333 6.038 Z" fill="var(--svg-icon-tint)"></path><path d="M 22 4.838 C 22 3.455 20.63 2.489 19.327 2.955 L 13.33 5.096 C 12.932 5.238 12.667 5.615 12.667 6.038 L 12.667 17.962 C 12.667 18.385 12.932 18.762 13.33 18.904 L 19.327 21.045 C 20.63 21.511 22 20.545 22 19.162 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Cover Flow</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('cube-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6.743 C 2 5.898 2.531 5.144 3.327 4.859 L 9.997 2.477 C 10.648 2.245 11.333 2.727 11.333 3.419 L 11.333 20.581 C 11.333 21.273 10.648 21.755 9.997 21.523 L 3.327 19.141 C 2.531 18.856 2 18.102 2 17.257 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.667 3.419 C 12.667 2.727 13.352 2.245 14.003 2.477 L 20.673 4.859 C 21.469 5.144 22 5.898 22 6.743 L 22 17.257 C 22 18.102 21.469 18.856 20.673 19.141 L 14.003 21.523 C 13.352 21.755 12.667 21.273 12.667 20.581 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Cube Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('flip-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 11.333 4.667 C 11.333 4.114 10.886 3.667 10.333 3.667 L 4 3.667 C 2.895 3.667 2 4.562 2 5.667 L 2 18.333 C 2 19.438 2.895 20.333 4 20.333 L 10.333 20.333 C 10.886 20.333 11.333 19.886 11.333 19.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 20 4.167 C 20 3.891 20.224 3.667 20.5 3.667 L 20.5 3.667 C 21.328 3.667 22 4.338 22 5.167 L 22 18.833 C 22 19.662 21.328 20.333 20.5 20.333 L 20.5 20.333 C 20.224 20.333 20 20.109 20 19.833 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 18.667 4.631 C 18.667 3.309 17.406 2.35 16.131 2.704 L 13.399 3.463 C 12.966 3.583 12.667 3.978 12.667 4.427 L 12.667 19.573 C 12.667 20.022 12.966 20.417 13.399 20.537 L 16.131 21.296 C 17.406 21.65 18.667 20.691 18.667 19.369 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Flip Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('parallax-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 6.667 C 12 5.562 12.895 4.667 14 4.667 L 17.333 4.667 C 18.438 4.667 19.333 5.562 19.333 6.667 L 19.333 10 C 19.333 11.105 18.438 12 17.333 12 L 14 12 C 12.895 12 12 11.105 12 10 Z" fill="var(--svg-icon-tint)"></path><path d="M 4.667 14 C 4.667 12.895 5.562 12 6.667 12 L 10 12 C 11.105 12 12 12.895 12 14 L 12 17.333 C 12 18.438 11.105 19.333 10 19.333 L 6.667 19.333 C 5.562 19.333 4.667 18.438 4.667 17.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Parallax Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('pile-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 6.5 4 C 6.224 4 6 3.776 6 3.5 L 6 3.5 C 6 2.672 6.672 2 7.5 2 L 16.5 2 C 17.328 2 18 2.672 18 3.5 L 18 3.5 C 18 3.776 17.776 4 17.5 4 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 4.5 7 C 4.224 7 4 6.776 4 6.5 L 4 6.5 C 4 5.672 4.672 5 5.5 5 L 18.5 5 C 19.328 5 20 5.672 20 6.5 L 20 6.5 C 20 6.776 19.776 7 19.5 7 Z" fill="var(--svg-icon-tint)" opacity="0.7"></path><path d="M 0 2.67 C 0 1.195 1.195 0 2.67 0 L 11.33 0 C 12.805 0 14 1.195 14 2.67 L 14 17.33 C 14 18.805 12.805 20 11.33 20 L 2.67 20 C 1.195 20 0 18.805 0 17.33 Z" transform="translate(5 5) rotate(-90 7 10)" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Pile Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('shuffle')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.174 10.452 L 16.708 9.06 L 15.174 7.667" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 15.174 16.333 L 16.708 14.94 L 15.174 13.548" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.145 9.06 C 16.145 9.06 13.982 8.542 12.617 9.679 C 11.252 10.815 11.829 12.213 10.776 13.548 C 9.724 14.882 7.708 14.94 7.708 14.94" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.145 14.823 C 16.145 14.823 13.982 15.34 12.617 14.204 C 11.252 13.068 11.829 11.669 10.776 10.335 C 9.724 9.001 7.708 8.942 7.708 8.942" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Shuffle</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('svg-animation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8 12.333 L 10.5 14.833 L 16 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">SVG Animation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('google-sheets')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7 8.667 C 7 8.206 7.373 7.833 7.833 7.833 L 7.833 7.833 C 8.294 7.833 8.667 8.206 8.667 8.667 L 8.667 8.667 C 8.667 9.127 8.294 9.5 7.833 9.5 L 7.833 9.5 C 7.373 9.5 7 9.127 7 8.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 7 12 C 7 11.54 7.373 11.167 7.833 11.167 L 7.833 11.167 C 8.294 11.167 8.667 11.54 8.667 12 L 8.667 12 C 8.667 12.46 8.294 12.833 7.833 12.833 L 7.833 12.833 C 7.373 12.833 7 12.46 7 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 7 15.333 C 7 14.873 7.373 14.5 7.833 14.5 L 7.833 14.5 C 8.294 14.5 8.667 14.873 8.667 15.333 L 8.667 15.333 C 8.667 15.794 8.294 16.167 7.833 16.167 L 7.833 16.167 C 7.373 16.167 7 15.794 7 15.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 8.667 C 9.778 8.206 10.151 7.833 10.611 7.833 L 16.167 7.833 C 16.627 7.833 17 8.206 17 8.667 L 17 8.667 C 17 9.127 16.627 9.5 16.167 9.5 L 10.611 9.5 C 10.151 9.5 9.778 9.127 9.778 8.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 12 C 9.778 11.54 10.151 11.167 10.611 11.167 L 16.167 11.167 C 16.627 11.167 17 11.54 17 12 L 17 12 C 17 12.46 16.627 12.833 16.167 12.833 L 10.611 12.833 C 10.151 12.833 9.778 12.46 9.778 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 15.333 C 9.778 14.873 10.151 14.5 10.611 14.5 L 16.167 14.5 C 16.627 14.5 17 14.873 17 15.333 L 17 15.333 C 17 15.794 16.627 16.167 16.167 16.167 L 10.611 16.167 C 10.151 16.167 9.778 15.794 9.778 15.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Google Sheets</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('map')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 11.82 6.504 C 14.029 6.504 15.82 8.282 15.82 10.476 C 15.82 10.698 15.801 10.915 15.766 11.127 C 15.359 14.488 13.033 16.581 12.155 17.261 C 12.051 17.341 11.976 17.437 11.82 17.437 C 11.663 17.437 11.586 17.34 11.481 17.258 C 10.6 16.576 8.28 14.483 7.873 11.127 C 7.838 10.915 7.82 10.698 7.82 10.476 C 7.82 8.282 9.61 6.504 11.82 6.504 Z M 9.486 10.644 C 9.486 11.933 10.531 12.977 11.82 12.977 C 13.108 12.977 14.153 11.933 14.153 10.644 C 14.153 9.355 13.108 8.311 11.82 8.311 C 10.531 8.311 9.486 9.355 9.486 10.644 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Map</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('signature-pad')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8.82 13.068 C 8.56 12.807 8.56 12.385 8.82 12.125 L 13.733 7.212 C 13.993 6.952 14.415 6.952 14.676 7.212 L 16.788 9.324 C 17.048 9.585 17.048 10.007 16.788 10.267 L 11.875 15.18 C 11.615 15.44 11.193 15.44 10.932 15.18 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.096 0.303 C 3.318 0.17 3.6 0.33 3.6 0.589 L 3.6 3.732 C 3.6 3.991 3.318 4.151 3.096 4.018 L 0.953 2.732 C 0.521 2.473 0.521 1.848 0.953 1.589 Z" transform="translate(6.24 13.8) rotate(-45 1.8 2.16)" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Signature Pad</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('sound-effects')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 14.225 10.793 C 14.471 11.102 14.623 11.529 14.623 12 C 14.623 12.471 14.471 12.898 14.225 13.207" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.224 9.185 C 16.96 9.911 17.417 10.905 17.417 12 C 17.417 13.095 16.96 14.09 16.224 14.816" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 6.083 10.656 C 6.083 10.288 6.382 9.989 6.75 9.989 L 7.674 9.989 L 11.021 7.835 C 11.464 7.549 12.048 7.868 12.048 8.396 L 12.048 15.604 C 12.048 16.132 11.464 16.451 11.021 16.165 L 7.674 14.011 L 6.75 14.011 C 6.382 14.011 6.083 13.712 6.083 13.344 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Sound Effects</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('card-swipe')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 3.423 7.423 C 3.423 5.214 5.214 3.423 7.423 3.423 L 16.756 3.423 C 18.965 3.423 20.756 5.214 20.756 7.423 L 20.756 16.756 C 20.756 18.965 18.965 20.756 16.756 20.756 L 7.423 20.756 C 5.214 20.756 3.423 18.965 3.423 16.756 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 9.172 3.377 C 10.734 1.815 13.266 1.815 14.828 3.377 L 20.721 9.269 C 22.283 10.831 22.283 13.364 20.721 14.926 L 14.828 20.819 C 13.266 22.381 10.734 22.381 9.172 20.819 L 3.279 14.926 C 1.717 13.364 1.717 10.831 3.279 9.269 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Card Swipe</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('custom-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6.2 C 2 5.673 2.31 5.195 2.792 4.981 L 7.063 3.083 C 7.503 2.887 8 3.21 8 3.693 L 8 20.307 C 8 20.79 7.503 21.113 7.063 20.917 L 2.792 19.019 C 2.31 18.805 2 18.327 2 17.8 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 9.333 3.297 C 9.333 2.642 9.954 2.163 10.588 2.33 L 20.509 4.941 C 21.388 5.172 22 5.967 22 6.875 L 22 17.125 C 22 18.033 21.388 18.828 20.509 19.059 L 10.588 21.67 C 9.954 21.837 9.333 21.358 9.333 20.703 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Custom Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('drag-handle')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 2.667 L 2.667 0 L 0 2.667" transform="translate(5.667 10.667) rotate(-90 2.667 1.333)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 5.333 0 L 2.667 2.667 L 0 0" transform="translate(13 10.667) rotate(-90 2.667 1.333)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Drag Handle</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('dynamic-header')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 8 L 2 8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Dynamic Header</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('image-panning')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 14 C 12 12.895 12.895 12 14 12 L 20 12 C 21.105 12 22 12.895 22 14 L 22 18 C 22 20.209 20.209 22 18 22 L 14 22 C 12.895 22 12 21.105 12 20 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Image Panning</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-data')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 10.333 C 16.667 10.886 16.219 11.333 15.667 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.667 12.667 C 16.219 12.667 16.667 13.114 16.667 13.667 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Input Data</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-validation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 10.333 C 16.667 10.886 16.219 11.333 15.667 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.667 12.667 C 16.219 12.667 16.667 13.114 16.667 13.667 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Input Validation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('like-animation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.28 0 C 7.017 0 7.747 2.366 6.357 3.755 C 4.968 5.144 3.543 5.905 3.543 5.905 C 3.543 5.905 2.118 5.144 0.728 3.755 C -0.661 2.365 0.069 -0 1.806 0 C 3.543 0 3.543 1.701 3.543 1.701 C 3.543 1.701 3.543 0 5.28 0 Z" transform="translate(11.213 11.787) rotate(15 3.543 2.953)" fill="var(--svg-icon-tint)"></path><path d="M 5.28 0 C 7.017 -0 7.747 2.365 6.357 3.755 C 4.968 5.144 3.543 5.905 3.543 5.905 C 3.543 5.905 2.118 5.144 0.728 3.755 C -0.661 2.366 0.069 0 1.806 0 C 3.543 0 3.543 1.701 3.543 1.701 C 3.543 1.701 3.543 0 5.28 0 Z" transform="translate(5.701 6.669) rotate(-15 3.543 2.953)" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Like Animation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('like-counter')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 14.778 7.333 C 17.556 7.333 18.724 11.072 16.502 13.268 C 14.279 15.464 12 16.667 12 16.667 C 12 16.667 9.721 15.464 7.498 13.268 C 5.276 11.072 6.444 7.333 9.222 7.333 C 12 7.333 12 10.022 12 10.022 C 12 10.022 12 7.333 14.778 7.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Like Counter</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('lock-screen')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 11 C 7.333 10.448 7.781 10 8.333 10 L 15.667 10 C 16.219 10 16.667 10.448 16.667 11 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 7.333 C 13.289 7.333 14.333 8.378 14.333 9.667 C 14.333 10.955 13.289 12 12 12 C 10.711 12 9.667 10.955 9.667 9.667 C 9.667 8.378 10.711 7.333 12 7.333 Z" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Lock Screen</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('long-press-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 16.667 10.667 C 17.771 10.667 18.667 11.562 18.667 12.667 C 18.667 13.771 17.771 14.667 16.667 14.667 C 15.562 14.667 14.667 13.771 14.667 12.667 C 14.667 11.562 15.562 10.667 16.667 10.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12 8 C 13.105 8 14 8.895 14 10 C 14 11.105 13.105 12 12 12 C 10.895 12 10 11.105 10 10 C 10 8.895 10.895 8 12 8 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.333 10.667 C 8.438 10.667 9.333 11.562 9.333 12.667 C 9.333 13.771 8.438 14.667 7.333 14.667 C 6.229 14.667 5.333 13.771 5.333 12.667 C 5.333 11.562 6.229 10.667 7.333 10.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Long Press Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('perspective-3d')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 6.913 22 C 5.987 22 5.182 21.364 4.967 20.463 L 2.586 10.463 C 2.287 9.206 3.24 8 4.532 8 L 19.468 8 C 20.76 8 21.713 9.206 21.414 10.463 L 19.033 20.463 C 18.818 21.364 18.013 22 17.087 22 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.833 7 C 3.557 7 3.333 6.776 3.333 6.5 L 3.333 6.5 C 3.333 5.672 4.005 5 4.833 5 L 19.167 5 C 19.995 5 20.667 5.672 20.667 6.5 L 20.667 6.5 C 20.667 6.776 20.443 7 20.167 7 Z" fill="var(--svg-icon-tint)" opacity="0.7"></path><path d="M 5.167 4 C 4.891 4 4.667 3.776 4.667 3.5 L 4.667 3.5 C 4.667 2.672 5.338 2 6.167 2 L 17.833 2 C 18.662 2 19.333 2.672 19.333 3.5 L 19.333 3.5 C 19.333 3.776 19.109 4 18.833 4 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Perspective 3D</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('progress-bar')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.153 17 C 5.153 16.08 5.899 15.333 6.82 15.333 L 16.82 15.333 C 17.74 15.333 18.486 16.08 18.486 17 L 18.486 17 C 18.486 17.92 17.74 18.667 16.82 18.667 L 6.82 18.667 C 5.899 18.667 5.153 17.92 5.153 17 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 5.153 17 C 5.153 16.08 5.899 15.333 6.82 15.333 L 11.486 15.333 C 12.407 15.333 13.153 16.08 13.153 17 L 13.153 17 C 13.153 17.92 12.407 18.667 11.486 18.667 L 6.82 18.667 C 5.899 18.667 5.153 17.92 5.153 17 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Progress Bar</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('scroll-progress')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 10.333 C 7.333 9.781 7.781 9.333 8.333 9.333 L 15.667 9.333 C 16.219 9.333 16.667 9.781 16.667 10.333 L 16.667 11.667 C 16.667 12.219 16.219 12.667 15.667 12.667 L 8.333 12.667 C 7.781 12.667 7.333 12.219 7.333 11.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 14.667 C 7.333 14.114 7.781 13.667 8.333 13.667 L 15.667 13.667 C 16.219 13.667 16.667 14.114 16.667 14.667 L 16.667 16 C 16.667 16.552 16.219 17 15.667 17 L 8.333 17 C 7.781 17 7.333 16.552 7.333 16 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 7.667 C 7.333 7.298 7.632 7 8 7 L 16 7 C 16.368 7 16.667 7.298 16.667 7.667 L 16.667 7.667 C 16.667 8.035 16.368 8.333 16 8.333 L 8 8.333 C 7.632 8.333 7.333 8.035 7.333 7.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 7.667 C 7.333 7.298 7.632 7 8 7 L 12.667 7 C 13.035 7 13.333 7.298 13.333 7.667 L 13.333 7.667 C 13.333 8.035 13.035 8.333 12.667 8.333 L 8 8.333 C 7.632 8.333 7.333 8.035 7.333 7.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Scroll Progress</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('show-password')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 10.6 12 C 10.6 11.227 11.227 10.6 12 10.6 L 12 10.6 C 12.773 10.6 13.4 11.227 13.4 12 L 13.4 12 C 13.4 12.773 12.773 13.4 12 13.4 L 12 13.4 C 11.227 13.4 10.6 12.773 10.6 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 12.166 7.833 C 14.892 7.833 17.161 9.42 17.811 12 C 17.161 14.58 14.892 16.167 12.166 16.167 C 9.44 16.167 7.127 14.58 6.478 12 C 7.127 9.42 9.44 7.833 12.166 7.833 Z M 9.333 12 C 9.333 13.473 10.527 14.667 12 14.667 C 13.473 14.667 14.667 13.473 14.667 12 C 14.667 10.527 13.473 9.333 12 9.333 C 10.527 9.333 9.333 10.527 9.333 12 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Show Password</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('slider')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.667 12 L 18.333 12" stroke="var(--svg-icon-tint)" fill="transparent" opacity="0.4" stroke-width="2.67" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 12 8.333 C 14.025 8.333 15.667 9.975 15.667 12 C 15.667 14.025 14.025 15.667 12 15.667 C 9.975 15.667 8.333 14.025 8.333 12 C 8.333 9.975 9.975 8.333 12 8.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Slider</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-drag')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 6.667 C 5.333 5.93 5.93 5.333 6.667 5.333 L 10 5.333 C 10.736 5.333 11.333 5.93 11.333 6.667 L 11.333 6.667 C 11.333 7.403 10.736 8 10 8 L 6.667 8 C 5.93 8 5.333 7.403 5.333 6.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.667 6.667 C 12.667 5.93 13.264 5.333 14 5.333 L 17.333 5.333 C 18.07 5.333 18.667 5.93 18.667 6.667 L 18.667 6.667 C 18.667 7.403 18.07 8 17.333 8 L 14 8 C 13.264 8 12.667 7.403 12.667 6.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Stories: Drag</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-tap')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 6.667 C 5.333 5.93 5.93 5.333 6.667 5.333 L 10 5.333 C 10.736 5.333 11.333 5.93 11.333 6.667 L 11.333 6.667 C 11.333 7.403 10.736 8 10 8 L 6.667 8 C 5.93 8 5.333 7.403 5.333 6.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 12.667 6.667 C 12.667 5.93 13.264 5.333 14 5.333 L 17.333 5.333 C 18.07 5.333 18.667 5.93 18.667 6.667 L 18.667 6.667 C 18.667 7.403 18.07 8 17.333 8 L 14 8 C 13.264 8 12.667 7.403 12.667 6.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Stories: Tap</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('toast-prompt')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18.333 C 22 20.542 20.209 22.333 18 22.333 L 6 22.333 C 3.791 22.333 2 20.542 2 18.333 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 6.333 C 15.13 6.333 17.667 8.87 17.667 12 C 17.667 15.13 15.13 17.667 12 17.667 C 8.87 17.667 6.333 15.13 6.333 12 C 6.333 8.87 8.87 6.333 12 6.333 Z" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)"></path><path d="M 12 13 C 12.552 13 13 13.448 13 14 C 13 14.552 12.552 15 12 15 C 11.448 15 11 14.552 11 14 C 11 13.448 11.448 13 12 13 Z" fill="var(--svg-icon-tint)"></path><path d="M 11.06 9.998 C 11.027 9.457 11.458 9 12 9 L 12 9 C 12.542 9 12.973 9.457 12.94 9.998 L 12.848 11.535 C 12.821 11.983 12.449 12.333 12 12.333 L 12 12.333 C 11.551 12.333 11.179 11.983 11.152 11.535 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Toast Prompt</div>
						</div>
					</li>
				</ul>
			</li>
			-->
		</ul>
		<ul class="nav--editor" *if="mode === 2">
			<li>
				<div class="title" [innerHTML]="'editor_views' | label"></div>
				<ul class="nav--editor">
					<li *for="let item of supportedViewTypes">
						<div class="btn" [class]="{ disabled: item.disabled }" (click)="onSelect({ type:'view', value: item.type.name })">
							<div class="icon">
								<svg-icon [name]="item.type.name"></svg-icon>
							</div>
							<div class="title" [innerHTML]="item.name"></div>
						</div>
					</li>
				</ul>
			</li>
		</ul>
		<ul class="nav--editor" *if="mode === 3">
			<li>
				<div class="title" [innerHTML]="'editor_view_items' | label"></div>
				<ul class="nav--editor">
					<li *for="let item of supportedViewItemTypes">
						<div class="btn" [class]="{ disabled: item.disabled }" (click)="onSelect({ type:'viewItem', value: item.type.name })" [title]="item.id">
							<div class="icon">
								<svg-icon [name]="item.type.name"></svg-icon>
							</div>
							<div class="title" [innerHTML]="item.name"></div>
						</div>
					</li>
				</ul>
				<div class="abstract" *if="supportedViewItemTypes.length == 0" [innerHTML]="'editor_type_no_items' | label"></div>
			</li>
		</ul>
	</div>
	`
};let MENU_UID = 0;
class MenuService {
  static set active(active) {
    this.active$.next(active);
  }

  static get active() {
    return this.active$.getValue();
  }

  static menu$() {
    return this.getMenu$().pipe(operators.switchMap(menu => {
      this.menu$_.next(menu);
      return this.menu$_;
    }));
  }

  static getMenu$() {
    return HttpService.get$(`/api/menu`).pipe(operators.map(data => {
      data.menu.sort((a, b) => {
        return a.order - b.order;
      });
      return data.menu;
    }));
  }

  static updateMenu$(menu) {
    return HttpService.put$(`/api/menu`, menu);
  }

  static createMenuItem$(parentId, order) {
    if (parentId === void 0) {
      parentId = null;
    }

    if (order === void 0) {
      order = 0;
    }

    const payload = {
      parentId: parentId,
      viewId: null,
      order: order * 10,
      name: 'Folder ' + ++MENU_UID
    };
    return HttpService.post$(`/api/menu`, payload);
  }

  static updateMenuItem$(item) {
    return HttpService.put$(`/api/menu/${item.id}`, item);
  }

  static deleteMenuItem$(item) {
    return HttpService.delete$(`/api/menu/${item.id}`);
  }

  static getModelMenu$(views, editor) {
    if (editor === void 0) {
      editor = false;
    }

    return this.menu$().pipe(operators.map(menu => {
      if (menu && menu.length) {
        menu = menu.filter(x => x.viewId == null || x.viewId == 0 || views.find(v => v.id === x.viewId) != null); // menu = menu.filter(x => x.viewId == null || views.find(v => v.id === x.viewId) != null);
        // console.log('getModelMenu$', menu);

        return this.mapMenuItems(menu);
      } else {
        // console.log('MenuService.getModelMenu$.Views', views);
        const keys = {};
        views.forEach(item => {
          if (item.type.name !== ViewType.WaitingRoom.name && (!item.hidden || editor)) {
            let group = keys[item.type.name];

            if (!group) {
              group = keys[item.type.name] = [];
            }

            group.push(item);
          }
        });
        const menu = Object.keys(keys).map(typeName => {
          let name = 'Button';

          switch (typeName) {
            case ViewType.WaitingRoom.name:
              name = 'Waiting Room';
              break;

            case ViewType.Panorama.name:
              name = 'Experience';
              break;

            case ViewType.PanoramaGrid.name:
              name = 'Virtual Tour';
              break;

            case ViewType.Room3d.name:
              name = 'Stanze 3D';
              break;

            case ViewType.Model.name:
              name = 'Modelli 3D';
              break;

            case ViewType.Media.name:
              name = 'Media';
              break;
          }

          return {
            name,
            type: {
              name: 'menu-group'
            },
            items: views.filter(x => x.type.name === typeName && (!x.hidden || editor))
          };
        });
        return menu;
      }
    }));
  }

  static mapMenuItem(item, items) {
    if (item.viewId) {
      return {
        id: item.viewId,
        name: item.name,
        type: {
          name: 'panorama'
        }
      };
    } else {
      return {
        name: item.name,
        type: {
          name: 'menu-group'
        },
        items: this.mapMenuItems(items, item.id)
      };
    }
  }

  static mapMenuItems(items, parentId) {
    if (parentId === void 0) {
      parentId = null;
    }

    return items.filter(item => {
      // console.log('MenuService.mapMenuItems', item);
      return (item.parentId || null) === parentId;
    }).map(item => this.mapMenuItem(item, items)).filter(x => x.id != null || x.items.length > 0);
  }

}
MenuService.active$ = new rxjs.BehaviorSubject(false);
MenuService.menu$_ = new rxjs.BehaviorSubject([]);class DropService {
  static drop$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      const body = document.querySelector('body');
      return rxjs.merge(rxjs.fromEvent(body, 'drop'), rxjs.fromEvent(body, 'dragover')).pipe(operators.map(event => {
        // console.log('DropService.drop$', event);
        event.preventDefault();

        if (event.target === input) {
          input.files = event.dataTransfer.files;
        }

        return;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }

  static change$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      return rxjs.fromEvent(input, 'change').pipe(operators.filter(event => input.files && input.files.length), operators.map(event => Array.from(input.files)));
    } else {
      return rxjs.EMPTY;
    }
  }

  static asset$(input, previews) {
    if (previews === void 0) {
      previews = [];
    }

    return this.change$(input).pipe(operators.switchMap(files => {
      previews.length = files.length;
      previews.fill(null); // output.previews = files.map(() => null);

      const uploads$ = files.map((file, i) => this.read$(file, i, previews).pipe(operators.map(() => file), operators.switchMap(file => AssetService.upload$([file])), operators.switchMap(uploads => {
        const upload = uploads[0];
        const asset = Asset.fromUrl(upload.url);
        return AssetService.assetCreate$(asset);
      })));
      return rxjs.combineLatest(uploads$);
    }));
  }

  static read$(file, i, previews) {
    if (previews === void 0) {
      previews = [];
    }

    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.switchMap(event => {
      const blob = event.target.result;
      return this.resize$(blob);
    }), operators.tap(resized => {
      previews[i] = resized;
    }));
    reader.readAsDataURL(file);
    return reader$;
  }

  static resize$(blob) {
    return rxjs.from(this.resize_(blob));
  }

  static resize_(blob) {
    return new Promise((resolve, reject) => {
      const img = document.createElement('img');

      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;

        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }

        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        resolve(dataUrl);
      };

      img.onerror = function () {
        reject(blob);
      };

      img.src = blob;
    });
  }

}class ControlComponent extends rxcomp.Component {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this); // console.log(this, node, this.control);

    const control = this.control;
    const flags = control.flags;
    Object.keys(flags).forEach(key => {
      flags[key] ? node.classList.add(key) : node.classList.remove(key);
    });
  }

}
ControlComponent.meta = {
  selector: '[control]',
  inputs: ['control']
};class ControlAssetComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || 'image/png, image/jpeg';
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    DropService.drop$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => AssetService.createOrUpdateAsset$(uploads, this.control))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlAssetComponent.change$', assets);
      this.control.value = assets[0];
    });
  }

}
ControlAssetComponent.meta = {
  selector: '[control-asset]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--picture">
				<div class="group--picture__info">
					<span [innerHTML]="'browse' | label"></span>
				</div>
				<img [lazy]="control.value | asset" [size]="{ width: 320, height: 240 }" *if="control.value && control.value.type.name === 'image'" />
				<video [src]="control.value | asset" *if="control.value && control.value.type.name === 'video'"></video>
				<input type="file">
			</div>
			<div class="file-name" *if="control.value" [innerHTML]="control.value.file"></div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlMenuComponent extends ControlAssetComponent {
  static itemToFormGroup(item) {
    return new rxcompForm.FormGroup({
      id: item.id,
      parentId: item.parentId,
      viewId: item.viewId,
      name: item.name,
      items: new rxcompForm.FormArray()
    });
  }
  /*
  static newFormGroup(parentId = null) {
  	return new FormGroup({
  		id: null,
  		parentId: parentId,
  		viewId: null,
  		name: 'Folder ' + (++MENU_UID),
  		items: new FormArray(),
  	});
  }
  */


  onInit() {
    this.dropdownId = DropdownDirective.nextId();
    this.controls = this.control.controls;
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
    });
  }

  onAddItem() {
    MenuService.createMenuItem$(this.controls.id.value, this.controls.items.length).pipe(operators.first()).subscribe(item => {
      this.controls.items.push(ControlMenuComponent.itemToFormGroup(item));
    }); // this.controls.items.push(ControlMenuComponent.newFormGroup(this.controls.id.value));
  }

  onRemoveItem() {
    this.remove.next(this.control);
  }

  onRemoveControl(control) {
    MenuService.deleteMenuItem$(control.value).pipe(operators.first()).subscribe(() => {
      this.controls.items.remove(control);
    }); // this.controls.items.remove(control);
  }

  onLinkItem() {
    this.link.next(this.control);
  }

  onLinkControl(control) {
    this.link.next(control);
  }

  onItemUp() {
    this.up.next(this.control);
  }

  onItemDown() {
    this.down.next(this.control);
  }

  onUpControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);

    if (index > 0) {
      index--;
    } else {
      index = length - 1;
    }

    items.insert(control, index);
  }

  onDownControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);

    if (index < length - 1) {
      index++;
    } else {
      index = 0;
    }

    items.insert(control, index);
  }

  setView(view) {
    // console.log('ControlMenuComponent.setView', view.id);
    const payload = Object.assign({}, this.control.value);
    payload.viewId = view.id;

    if (view.id) {
      payload.name = view.name;
    }

    MenuService.updateMenuItem$(payload).pipe(operators.first()).subscribe(() => {
      this.controls.viewId.value = view.id;

      if (view.id) {
        this.controls.name.value = view.name; // clear sub items

        this.controls.items.controls = [];
        this.controls.items.switchSubjects_();
      } // this.change.next(value);

    });
  }

  onTextDidChange(event) {
    // console.log('ControlMenuComponent.onTextDidChange', this.controls.name.value);
    MenuService.updateMenuItem$(this.control.value).pipe(operators.first()).subscribe();
  }

  hasOption(item) {
    return this.controls.viewId.value === item.id;
  }

  onDropped(id) {// console.log('ControlMenuComponent.onDropped', id);
  }

}
ControlMenuComponent.meta = {
  selector: '[control-menu]',
  outputs: ['remove', 'link', 'up', 'down'],
  inputs: ['control'],
  template:
  /* html */
  `
		<div class="group--form">
			<button type="button" class="control-menu__link" [class]="{ active: control.controls.viewId.value }" (click)="onLinkItem($event)" [dropdown]="dropdownId" (dropped)="onDropped($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#link"></use></svg>
				<div class="dropdown" [dropdown-item]="dropdownId">
					<div class="category">View</div>
					<ul class="nav--dropdown">
						<li (click)="setView(item)" [class]="{ empty: item.id == null }" *for="let item of control.controls.viewId.options">
							<span [class]="{ active: hasOption(item) }" [innerHTML]="item.name"></span>
						</li>
					</ul>
				</div>
			</button>
			<input type="text" class="control--text" [formControl]="control.controls.name" placeholder="Name" (change)="onTextDidChange($event)" />
			<!--
			<button type="button" class="control-menu__add" (click)="onAddItem($event)">
				<span [innerHTML]="control.controls.viewId.value"></span>
			</button>
			-->
			<!--
			<select class="control--select" [formControl]="control.controls.viewId">
				<option [value]="item.id" *for="let item of control.controls.viewId.options" [innerHTML]="item.name"></option>
			</select>
			-->
			<button type="button" class="control-menu__up" (click)="onItemUp($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#up"></use></svg>
			</button>
			<button type="button" class="control-menu__down" (click)="onItemDown($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#down"></use></svg>
			</button>
			<button type="button" class="control-menu__add" (click)="onAddItem($event)" *if="!control.controls.viewId.value">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#add"></use></svg>
			</button>
			<button type="button" class="control-menu__remove" (click)="onRemoveItem($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#remove"></use></svg>
			</button>
		</div>
		<div class="group--items">
			<div control-menu *for="let sub of control.controls.items.controls" [control]="sub" (remove)="onRemoveControl($event)" (link)="onLinkControl($event)" (up)="onUpControl($event)" (down)="onDownControl($event)"></div>
		</div>
	`
};class MenuBuilderComponent extends rxcomp.Component {
  onInit() {
    this.changes = 0;
    this.form = null;
    MenuService.getMenu$().pipe(operators.first()).subscribe(menu => this.initForm(menu));
  }

  initForm(menu) {
    if (menu === void 0) {
      menu = [];
    }

    const items = this.menuToControls(menu); // console.log('MenuBuilderComponent', items);

    const form = this.form = new rxcompForm.FormGroup({
      items: items
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('MenuBuilderComponent', changes);
      this.changes++;
      this.pushChanges();
    });
  }

  onLinkControl(control) {}

  onUpControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);

    if (index > 0) {
      index--;
    } else {
      index = length - 1;
    }

    items.insert(control, index);
  }

  onDownControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);

    if (index < length - 1) {
      index++;
    } else {
      index = 0;
    }

    items.insert(control, index);
  }

  onAddItem() {
    MenuService.createMenuItem$(null, this.controls.items.length).pipe(operators.first()).subscribe(item => {
      this.controls.items.push(ControlMenuComponent.itemToFormGroup(item));
    }); // this.controls.items.push(ControlMenuComponent.newFormGroup());
  }

  onRemoveControl(control) {
    MenuService.deleteMenuItem$(control.value).pipe(operators.first()).subscribe(() => {
      this.controls.items.remove(control);
    }); // this.controls.items.remove(control);
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }

  onSubmit(event) {
    if (this.form.valid) {
      const changes = this.form.value;
      const menu = this.controlsToMenu(changes);
      MenuService.updateMenu$(menu);
    } else {
      this.form.touched = true;
    }
  }

  menuToControls(menu, parentId) {
    if (parentId === void 0) {
      parentId = null;
    }

    const items = new rxcompForm.FormArray(menu.filter(x => {
      return (x.parentId || null) === parentId;
    }).map(x => {
      const subitems = this.menuToControls(menu, x.id);
      return new rxcompForm.FormGroup({
        id: x.id,
        parentId: x.parentId,
        viewId: x.viewId,
        name: x.name,
        items: subitems
      });
    }));
    return items;
  }

  controlsToMenu(changes) {
    const menu = [];

    const pushItem = items => {
      if (items) {
        items.forEach((item, i) => {
          const menuItem = Object.assign({}, item);
          menuItem.order = i * 10;
          delete menuItem.items;
          menu.push(menuItem);
          pushItem(item.items);
        });
      }
    };

    pushItem(changes.items);
    return menu;
  }

}
MenuBuilderComponent.meta = {
  selector: '[menu-builder]',
  inputs: ['views'],
  template:
  /* html */
  `
	<div class="group--head">
		<div class="title" [innerHTML]="'editor_menu' | label"></div>
	</div>
	<div class="group--main">
		<div class="nav--tree" *if="form">
			<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
				<div class="abstract" *if="controls.items.controls.length == 0" [innerHTML]="'editor_add_item' | label"></div>
				<div *for="let control of controls.items.controls">
					<div control-menu [control]="control" (remove)="onRemoveControl($event)" (link)="onLinkControl($event)" (up)="onUpControl($event)" (down)="onDownControl($event)"></div>
				</div>
			</form>
		</div>
	</div>
	<div class="group--foot">
		<button type="button" class="btn--mode" (click)="onAddItem($event)" [innerHTML]="'editor_add' | label"></button>
		<button type="button" class="btn--mode" (click)="isValid() && onSubmit()" *if="changes > 1" [innerHTML]="'editor_save' | label"></button>
	</div>
	`
};class NavmapItemModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }

    return data;
  }

  get navmap() {
    let navmap = null;
    const data = this.data;

    if (data) {
      navmap = data.navmap;
    }

    return navmap;
  }

  get position() {
    let position = [0, 0, 0];
    const data = this.data;

    if (data) {
      position = [data.hit.x, data.hit.y, 0];
    }

    return position;
  }

  onInit() {
    const position = this.position;
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Nav,
      title: null,
      abstract: null,
      viewId: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      keepOrientation: false,
      important: false,
      transparent: false,
      position: new rxcompForm.FormControl(position, rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapItemModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const item = Object.assign({}, this.form.value);
      item.viewId = parseInt(item.viewId); // console.log('NavmapItemModalComponent.onSubmit', this.navmap, item);

      NavmapService.itemCreate$(this.navmap, item).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapItemModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavmapItemModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.submitted = false; // this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
NavmapItemModalComponent.meta = {
  selector: '[navmap-item-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Map Nav.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.title" label="Title"></div>
						<div control-textarea [control]="controls.abstract" label="Abstract"></div>
						<div control-custom-select [control]="controls.viewId" label="NavToView"></div>
						<div control-vector [control]="controls.position" label="Position" [precision]="3" [disabled]="true"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

NavmapItemModalComponent.chunk = () =>
/* html */
`<div class="nav-modal" navmap-item-modal></div>`;class NavmapModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const navmap = {
        name: values.name,
        asset: values.asset
      }; // console.log('NavmapModalComponent.onSubmit.navmap', navmap);

      return NavmapService.navmapCreate$(navmap).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavmapModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
NavmapModalComponent.meta = {
  selector: '[navmap-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Map.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/png"></div>
					</div>
					<div class="description">Formato immagine .png con trasparenza (2048x1024 o 1024x512)</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};

NavmapModalComponent.chunk = () =>
/* html */
`<div class="panorama-modal" navmap-modal></div>`;class NavmapBuilderComponent extends rxcomp.Component {
  onInit() {
    this.navmap = null;
    this.navmaps = [];
    NavmapService.navmapGet$().pipe(operators.first()).subscribe(navmaps => {
      this.navmaps = navmaps;
      this.pushChanges();
    });
  }

  onBack(event) {
    this.navmap = null;
    this.pushChanges();
  }

  onAdd() {
    ModalService.open$({
      template: NavmapModalComponent.chunk()
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.navmaps.push(event.data);
        this.navmap = event.data;
        this.pushChanges();
      }
    });
  }

  onSet(item) {
    this.navmap = this.navmaps.find(x => x.id === item.id);
    this.pushChanges();
  }

  onAddItem(navmap, hit) {
    ModalService.open$({
      template: NavmapItemModalComponent.chunk(),
      data: {
        navmap,
        hit
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        const items = navmap.items || [];
        items.push(event.data);
        Object.assign(navmap, {
          items
        });
        this.pushChanges();
      }
    });
  }

  onDelete(navmap) {
    const index = this.navmaps.indexOf(navmap);

    if (index !== -1) {
      this.navmaps.splice(index, 1);
    }

    this.navmap = null;
    this.pushChanges();
  }

}
NavmapBuilderComponent.meta = {
  selector: '[navmap-builder]',
  inputs: ['views'],
  template:
  /* html */
  `
	<div class="group--head">
		<div class="title" [innerHTML]="'editor_navmaps' | label"></div>
	</div>
	<div class="group--main">
		<!-- listing navmaps -->
		<div class="listing--navmaps" *if="!navmap">
			<div class="abstract" *if="navmaps.length == 0" [innerHTML]="'editor_add_item' | label"></div>
			<div class="listing__item" *for="let item of navmaps">
				<div class="card--navmap" (click)="onSet(item)">
					<div class="card__picture">
						<img [src]="item.asset | asset" *if="item.asset" />
					</div>
					<div class="card__content">
						<div class="card__name" [innerHTML]="item.name"></div>
					</div>
				</div>
			</div>
		</div>
		<!-- navmap edit -->
		<div class="navmap" navmap-edit [navmap]="navmap" (delete)="onDelete($event)" *if="navmap">
			<form class="form" [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
				<div class="title"><span [innerHTML]="navmap.name"></span> <span [innerHTML]="navmap.id"></span></div>
				<div class="form-controls">
					<div control-text [control]="controls.name" label="Name"></div>
					<!--
					<div control-asset [control]="controls.asset" label="Image" accept="image/png"></div>
					-->
				</div>
				<div class="group--cta">
					<button type="submit" class="btn--accept">
						<span [innerHTML]="'editor_save' | label"></span>
					</button>
					<button type="button" class="btn--remove" (click)="onRemove($event)">
						<span [innerHTML]="'editor_remove' | label"></span>
					</button>
				</div>
				<div class="navmap-control" [class]="mode">
					<div class="navmap-control__image">
						<img draggable="false" [src]="navmap.asset | asset" *if="navmap.asset" />
						<div class="navmap__item" [style]="{ left: item.position[0] * 100 + '%', top: item.position[1] * 100 + '%' }" (mousedown)="onMoveItem($event, item)" (click)="onRemoveItem(item)" *for="let item of navmap.items">
							<img draggable="false" [src]="'textures/ui/nav-point.png' | asset" />
							<div class="title" [innerHTML]="item.title" *if="item.title"></div>
						</div>
					</div>
					<ul class="navmap-control__toolbar">
						<li class="nav__item"><span [class]="{ active: mode === 'insert' }" (click)="onToggleMode('insert')"><svg class="pencil" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#pencil"></use></svg></span></li>
						<li class="nav__item"><span [class]="{ active: mode === 'move' }" (click)="onToggleMode('move')"><svg class="move" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#move"></use></svg></span></li>
						<li class="nav__item"><span [class]="{ active: mode === 'remove' }" (click)="onToggleMode('remove')"><svg class="erase" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#erase"></use></svg></span></li>
					</ul>
				</div>
			</form>
		</div>
	</div>
	<div class="group--foot">
		<button type="button" class="btn--mode" (click)="onAdd($event)" [innerHTML]="'editor_add' | label" *if="!navmap"></button>
		<button type="button" class="btn--mode" (click)="onBack($event)" [innerHTML]="'editor_back' | label" *if="navmap"></button>
	</div>
	`
};const NavmapModes = {
  Idle: 'idle',
  Insert: 'insert',
  Remove: 'remove',
  Move: 'move'
};
class ControlEvent {
  constructor(element, event) {
    const rect = element.getBoundingClientRect();
    this.x = (event.clientX - rect.x) / rect.width;
    this.y = (event.clientY - rect.y) / rect.height; // console.log(this);
  }

}
class ControlDownEvent extends ControlEvent {}
class ControlMoveEvent extends ControlEvent {}
class ControlUpEvent extends ControlEvent {}
class NavmapEditComponent extends rxcomp.Component {
  onInit() {
    this.mode = NavmapModes.Idle;
    this.error = null;
    const navmap = this.navmap;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(navmap.name, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(navmap.asset, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapEditComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    this.insert$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('NavmapEditComponent.insert', event);
      const hit = event;
      ModalService.open$({
        template: NavmapItemModalComponent.chunk(),
        data: {
          navmap,
          hit
        }
      }).pipe(operators.first()).subscribe(event => {
        if (event instanceof ModalResolveEvent) {
          const items = navmap.items || [];
          items.push(event.data);
          Object.assign(navmap, {
            items
          });
          this.pushChanges();
        }
      });
    });
  }

  insert$() {
    const {
      node
    } = rxcomp.getContext(this);
    const image = node.querySelector('.navmap-control__image');
    return rxjs.fromEvent(image, 'pointerdown').pipe(operators.filter(x => this.mode === NavmapModes.Insert), operators.map(event => new ControlDownEvent(image, event)));
  }

  onToggleMode(mode) {
    this.mode = this.mode === mode ? NavmapModes.Idle : mode;
    this.pushChanges();
  }

  onMoveItem(event, item) {
    const navmap = this.navmap;

    switch (this.mode) {
      case NavmapModes.Move:
        const {
          node
        } = rxcomp.getContext(this);
        const image = node.querySelector('.navmap-control__image');
        const position = item.position.slice();
        const down = new ControlDownEvent(image, event);
        const move$ = rxjs.fromEvent(image, 'mousemove').pipe(operators.map(event => new ControlMoveEvent(image, event)), operators.tap(event => {
          const diff = {
            x: event.x - down.x,
            y: event.y - down.y
          };
          item.position = [Math.max(0, Math.min(1, position[0] + diff.x)), Math.max(0, Math.min(1, position[1] + diff.y)), 0];
          this.pushChanges();
        }));
        const up$ = rxjs.fromEvent(image, 'mouseup').pipe(operators.map(event => new ControlUpEvent(image, event)), operators.tap(event => {
          const diff = {
            x: event.x - down.x,
            y: event.y - down.y
          };
          item.position = [Math.max(0, Math.min(1, position[0] + diff.x)), Math.max(0, Math.min(1, position[1] + diff.y)), 0]; // console.log('NavmapEditComponent.onNavmapItem.Update', navmap, item);

          NavmapService.itemUpdate$(navmap, item).pipe(operators.first()).subscribe(item_ => {
            Object.assign(item, item_); // console.log('NavmapEditComponent.onNavmapItem.Update');

            this.pushChanges();
          });
        }));
        move$.pipe(operators.takeUntil(up$)).subscribe();
        break;
    }
  }

  onRemoveItem(item) {
    const navmap = this.navmap;

    switch (this.mode) {
      case NavmapModes.Remove:
        NavmapService.itemDelete$(navmap, item).pipe(operators.first()).subscribe(_ => {
          // console.log('NavmapEditComponent.onNavmapItem.Remove');
          const items = navmap.items || [];
          const index = items.indexOf(item);

          if (index !== -1) {
            items.splice(index, 1);
          }

          Object.assign(navmap, {
            items
          });
          this.pushChanges();
        });
        break;
    }
  }

  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const payload = Object.assign({
        items: []
      }, this.navmap, {
        name: values.name
      }); // console.log('NavmapEditComponent.onSubmit.navmap', payload);

      NavmapService.navmapUpdate$(payload).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapEditComponent.onSubmit.success', response);
        Object.assign(this.navmap, response);
        this.pushChanges();
      }, error => {
        // console.log('NavmapEditComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }

  onRemove() {
    const navmap = this.navmap;
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: navmap
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        NavmapService.navmapDelete$(navmap).pipe(operators.first()).subscribe(response => {
          this.delete.next(navmap);
        });
      }
    });
  }

}
NavmapEditComponent.meta = {
  selector: '[navmap-edit]',
  outputs: ['delete'],
  inputs: ['navmap']
};class UpdateViewItemComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    this.active = false;
    this.useHooks = WebhookService.enabled;
    const form = this.form = new rxcompForm.FormGroup();
    this.controls = form.controls;
    const item = this.item;
    this.originalItem = Object.assign({}, item);
    item.hasChromaKeyColor = item.asset && item.asset.chromaKeyColor ? true : false;
    item.autoplay = item.asset && item.asset.type.name === AssetType.Video.name ? item.asset.autoplay : undefined;
    item.loop = item.asset && item.asset.type.name === AssetType.Video.name ? item.asset.loop : undefined;
    item.assetType = assetGroupTypeFromItem(item).id;
    this.doUpdateForm();
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewItemComponent.form.changes$', changes);
      this.doUpdateItem(changes);
      this.pushChanges();
    });
  }

  getFlagsDidChange(item, changes) {
    const flags = ['hasChromaKeyColor', 'autoplay', 'loop'];
    return flags.reduce((p, c) => {
      const a = changes[c] || false;
      const b = item[c] || false; // console.log(c, a, b);

      return p || a !== b;
    }, false);
  }

  getAssetDidChange(item, changes) {
    // console.log('UpdateViewItemComponent.getAssetDidChange', item.asset, changes.asset);
    return AssetService.assetDidChange(item.asset, changes.asset);
  }

  doUpdateItem(changes) {
    const item = this.item;
    const assetDidChange = this.getAssetDidChange(item, changes);
    const flagsDidChange = this.getFlagsDidChange(item, changes); // console.log('UpdateViewItemCompoent.doUpdateItem', 'assetDidChange', assetDidChange, 'flagsDidChange', flagsDidChange);

    Object.assign(item, changes);

    if (item.asset) {
      item.asset.chromaKeyColor = item.hasChromaKeyColor ? [0.0, 1.0, 0.0] : null;
      item.asset.autoplay = item.autoplay;
      item.asset.loop = item.loop;
    }

    if (assetDidChange || flagsDidChange) {
      const asset$ = item.asset ? AssetService.assetUpdate$(item.asset) : rxjs.of(null);
      asset$.pipe(operators.switchMap(() => EditorService.inferItemUpdate$(this.view, item)), operators.first()).subscribe(); // !!! create indices for nextAttendeeStream

      this.view.updateIndices(this.view.items);

      if (typeof item.onUpdateAsset === 'function') {
        item.onUpdateAsset();
      }
    }

    if (typeof item.onUpdate === 'function') {
      item.onUpdate();
    }
  }

  doUpdateForm() {
    const item = this.item;
    const form = this.form;

    if (!this.type || this.type.name !== item.type.name) {
      this.type = item.type;
      Object.keys(this.controls).forEach(key => {
        form.removeKey(key);
      });
      let keys;

      switch (item.type.name) {
        case ViewItemType.Nav.name:
          if (this.useHooks) {
            keys = ['id', 'type', 'title?', 'abstract?', 'viewId?', 'hook?', 'hookExtra?', 'keepOrientation?', 'important?', 'transparent?', 'position', 'rotation', 'scale', 'asset?', 'link?', 'links?'];
          } else {
            keys = ['id', 'type', 'title?', 'abstract?', 'viewId?', 'keepOrientation?', 'important?', 'transparent?', 'position', 'rotation', 'scale', 'asset?', 'link?', 'links?'];
          }

          break;

        case ViewItemType.Plane.name:
          keys = ['id', 'type', 'position', 'rotation', 'scale', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?'];
          break;

        case ViewItemType.CurvedPlane.name:
          keys = ['id', 'type', 'position', 'rotation', 'scale', 'radius', 'height', 'arc', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?'];
          break;

        case ViewItemType.Texture.name:
          keys = ['id', 'type', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?']; // asset, key no id!!

          break;

        case ViewItemType.Model.name:
          if (this.view.type.name === ViewType.Model) {
            keys = ['id', 'type', 'asset?'];
          } else {
            keys = ['id', 'type', 'position', 'rotation', 'asset?'];
          }

          break;

        default:
          keys = ['id', 'type'];
      }

      keys.forEach(key => {
        const optional = key.indexOf('?') !== -1;
        key = key.replace('?', '');
        const value = item[key] != null ? item[key] : null;
        let control;

        switch (key) {
          case 'viewId':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
            EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
              control.options = options;
              control.value = control.value || null;
              this.pushChanges();
            });
            break;

          case 'hook':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());

            if (WebhookService.enabled) {
              const options = environment.webhook.methods.nav.map(x => ({
                id: x,
                name: x
              }));
              options.unshift({
                id: null,
                name: 'select'
              });
              control.options = options;
            }

            control.value = control.value || null;
            this.pushChanges();
            break;

          case 'assetType':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
            control.options = Object.keys(AssetGroupType).map(x => AssetGroupType[x]); // console.log(control.options);

            break;

          case 'link':
            /*
            const title = item.link ? item.link.title : null;
            const href = item.link ? item.link.href : null;
            const target = '_blank';
            control = new FormGroup({
            	title: new FormControl(title),
            	href: new FormControl(href),
            	target
            });
            */
            break;

          case 'links':
            const links = item.links;
            control = new rxcompForm.FormArray(links.map(link => new rxcompForm.FormGroup({
              title: new rxcompForm.FormControl(link.title),
              href: new rxcompForm.FormControl(link.href),
              target: '_blank'
            })));
            break;

          default:
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
        }

        form.add(control, key);
      });
      this.controls = form.controls;
    } else {
      Object.keys(this.controls).forEach(key => {
        switch (key) {
          case 'link':
            /*
            const title = item.link ? item.link.title : null;
            const href = item.link ? item.link.href : null;
            const target = '_blank';
            this.controls[key].value = { title, href, target };
            */
            break;

          case 'links':
            const links = item.links.map(link => ({
              title: link.title || null,
              href: link.href || null,
              target: '_blank'
            }));
            const formArray = this.controls[key];

            while (formArray.controls.length > links.length) {
              formArray.remove(formArray.controls[formArray.controls.length - 1]);
            }

            while (formArray.controls.length < links.length) {
              formArray.push(new rxcompForm.FormGroup({
                title: new rxcompForm.FormControl(null),
                href: new rxcompForm.FormControl(null),
                target: '_blank'
              }));
            } // console.log(formArray, links);


            formArray.patch(links);
            break;

          case 'hasChromaKeyColor':
            this.controls[key].value = item.asset && item.asset.chromaKeyColor ? true : false;
            break;

          case 'autoplay':
            this.controls[key].value = item.asset && item.asset.autoplay ? true : false;
            break;

          case 'loop':
            this.controls[key].value = item.asset && item.asset.loop ? true : false;
            break;

          case 'assetType':
            this.controls[key].value = assetGroupTypeFromItem(item).id;
            break;

          default:
            this.controls[key].value = item[key] != null ? item[key] : null;
        }
      });
    }
  }

  onAssetTypeDidChange(assetType) {
    const item = this.item;
    const currentType = assetGroupTypeFromItem(item).id; // console.log('UpdateViewItemComponent.onAssetTypeDidChange', assetType, currentType);

    if (assetType !== currentType) {
      item.assetType = assetType;
      let asset$ = rxjs.of(null); // AssetService.assetDelete$(item.asset);

      if (assetType !== AssetGroupType.ImageOrVideo.id) {
        asset$ = asset$.pipe(operators.switchMap(() => {
          const asset = assetPayloadFromGroupTypeId(assetType);
          return AssetService.assetCreate$(asset);
        }));
      }

      asset$.pipe(operators.first()).subscribe(asset => {
        // console.log('UpdateViewItemComponent.asset$', asset);
        this.controls.asset.value = asset;
      });
      /*
      asset$.pipe(
      	tap(asset => {
      		item.asset = asset;
      		if (typeof item.onUpdateAsset === 'function') {
      			item.onUpdateAsset();
      		}
      	}),
      	switchMap(() => EditorService.inferItemUpdate$(this.view, item)),
      	first()
      ).subscribe();
      */
    }
  }

  onChanges(changes) {
    // console.log('UpdateViewItemComponent.onChanges', changes);
    this.doUpdateForm();
  }

  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const changes = this.form.value;
      const payload = Object.assign({}, changes);

      if (this.item.type.name === ViewItemType.Nav.name) {
        payload.viewId = payload.viewId || this.view.id;
      }

      const view = this.view;
      const item = new ViewItem(payload);
      EditorService.inferItemUpdate$(view, item).pipe(operators.first()).subscribe(response => {
        // console.log('UpdateViewItemComponent.onSubmit.inferItemUpdate$.success', response);
        EditorService.inferItemUpdateResult$(view, item);
        this.update.next({
          view,
          item
        });
        this.setTimeout(() => {
          this.busy = false;
          this.pushChanges();
        });
      }, error => console.log('UpdateViewItemComponent.onSubmit.inferItemUpdate$.error', error)); // this.update.next({ view: this.view, item: new ViewItem(payload) });
    } else {
      this.form.touched = true;
    }
  }

  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: this.item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view,
          item: this.item
        });
      }
    });
  }

  onSelect(event) {
    this.select.next({
      view: this.view,
      item: this.item.selected ? null : this.item
    });
    /*
    this.item.active = !this.item.active;
    this.pushChanges();
    */
  }

  getTitle(item) {
    return LabelPipe.getKeys('editor', item.type.name);
  }

  onAddLink(event) {
    this.controls.links.push(new rxcompForm.FormGroup({
      title: new rxcompForm.FormControl(null),
      href: new rxcompForm.FormControl(null),
      target: '_blank'
    }));
  }

  onRemoveLink(item) {
    this.controls.links.remove(item);
  }

  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }

  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }

    this.clearTimeout();

    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }

  onDestroy() {
    this.clearTimeout();
  }

}
UpdateViewItemComponent.meta = {
  selector: 'update-view-item',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view', 'item'],
  template:
  /* html */
  `
		<div class="group--headline" [class]="{ active: item.selected }" (click)="onSelect($event)">
			<!-- <div class="id" [innerHTML]="item.id"></div> -->
			<div class="icon">
				<svg-icon [name]="item.type.name"></svg-icon>
			</div>
			<div class="title" [innerHTML]="getTitle(item)"></div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="item.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<!-- <div control-text [control]="controls.type" label="Type" [disabled]="true"></div> -->
			</div>
			<div class="form-controls" *if="item.type.name == 'nav'">
				<div control-text [control]="controls.title" label="Title"></div>
				<div control-textarea [control]="controls.abstract" label="Abstract"></div>
				<div control-custom-select [control]="controls.viewId" label="NavToView"></div>
				<div control-checkbox [control]="controls.keepOrientation" label="Keep Orientation"></div>
				<div control-checkbox [control]="controls.important" label="Important"></div>
				<div control-checkbox [control]="controls.transparent" label="Transparent"></div>
				<div control-vector [control]="controls.position" label="Position" [precision]="3"></div>
				<div *if="controls.transparent.value == true">
					<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
					<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				</div>
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg, image/png"></div>

				<div class="group--link" *for="let link of controls.links.controls">
					<div class="group--controls">
						<div control-text [control]="link.controls.title" label="Link Title"></div>
						<div control-text [control]="link.controls.href" label="Link Url"></div>
					</div>
					<button type="button" class="btn--remove" (click)="onRemoveLink(link)"><svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#remove"></use></svg></button>
				</div>

				<div class="group--cta">
					<button type="button" class="btn--update" (click)="onAddLink($event)">
						<span>Add Link</span>
					</button>
				</div>

				<div *if="useHooks">
					<div control-custom-select [control]="controls.hook" label="Hook"></div>
					<div control-text [control]="controls.hookExtra" label="Hook Extra"></div>
				</div>
			</div>
			<div class="form-controls" *if="item.type.name == 'plane' && view.type.name != 'media'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
				<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Localized Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'plane' && view.type.name == 'media'">
				<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				<div control-localized-asset [control]="controls.asset" label="Localized Image or Video" accept="image/jpeg, video/mp4"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'curved-plane'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
				<!-- <div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div> -->
				<div control-number [control]="controls.radius" label="Radius" [precision]="2"></div>
				<div control-number [control]="controls.height" label="Height" [precision]="2"></div>
				<div control-number [control]="controls.arc" label="Arc" [precision]="0"></div>
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'texture'">
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'model'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2" *if="view.type.name !== 'model'"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" *if="view.type.name !== 'model'"></div>
				<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<button type="button" class="btn--remove" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
			</div>
		</form>
	`
};class UpdateViewTileComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    this.active = false;
    const form = this.form = new rxcompForm.FormGroup({
      id: new rxcompForm.FormControl(this.tile.id, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(this.tile.asset, rxcompForm.RequiredValidator()),
      navs: new rxcompForm.FormControl(this.tile.navs, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewTileComponent.form.changes$', changes);
      const tile = this.tile;
      Object.assign(tile, changes);

      if (typeof tile.onUpdate === 'function') {
        tile.onUpdate();
      }

      this.pushChanges();
    }); // console.log('UpdateViewTileComponent.onInit', this.view, this.tile);
  }

  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const payload = Object.assign({}, this.form.value);
      const view = this.view;
      const tile = payload;
      /*
      EditorService.tileUpdate$...
      */

      this.update.next({
        view,
        tile
      });
      this.setTimeout(() => {
        this.busy = false;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }

  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        tile: this.tile
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view,
          tile: this.tile
        });
      }
    });
  }

  onSelect(event) {
    this.select.next({
      view: this.view,
      tile: this.tile.selected ? null : this.tile
    });
  }

  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }

  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }

    this.clearTimeout();

    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }

  onDestroy() {
    this.clearTimeout();
  }

}
UpdateViewTileComponent.meta = {
  selector: 'update-view-tile',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view', 'tile'],
  template:
  /* html */
  `
		<div class="group--headline" [class]="{ active: tile.selected }" (click)="onSelect($event)">
			<div class="icon">
				<svg-icon name="tile"></svg-icon>
			</div>
			<div class="title">Tile {{tile.id}}</div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="tile.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg, image/png"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<!--
				<button type="button" class="btn--remove" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
				-->
			</div>
		</form>
	`
};class UpdateViewComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    const form = this.form = new rxcompForm.FormGroup();
    this.controls = form.controls;
    this.doUpdateForm();
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewComponent.form.changes$', changes);
      this.doUpdateView(changes);
      this.pushChanges();
    });
    this.orbit$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      switch (this.view.type.name) {
        case ViewType.WaitingRoom.name:
        case ViewType.Panorama.name:
        case ViewType.PanoramaGrid.name:
        case ViewType.Room3d.name:
        case ViewType.Model.name:
        case ViewType.Media.name:
          this.form.patch({
            latitude: message.orientation.latitude,
            longitude: message.orientation.longitude,
            zoom: message.zoom
          });
          break;
      }
    });
  }

  orbit$() {
    let latitude,
        longitude,
        zoom = null;
    return MessageService.in$.pipe(operators.filter(message => message.type === MessageType.ControlInfo), operators.auditTime(65), operators.distinctUntilChanged((previous, current) => {
      const didChange = latitude !== current.orientation.latitude || longitude !== current.orientation.longitude || zoom !== current.zoom;
      latitude = current.orientation.latitude;
      longitude = current.orientation.longitude;
      zoom = current.zoom;
      return !didChange;
    }));
  }

  getAssetDidChange(changes) {
    const view = this.view;

    if (view.type.name === ViewType.PanoramaGrid.name) {
      return false;
    }

    const assetDidChange = AssetService.assetDidChange(view.asset, changes.asset);
    const usdzDidChange = AssetService.assetDidChange(view.ar ? view.ar.usdz : null, changes.usdz);
    const gltfDidChange = AssetService.assetDidChange(view.ar ? view.ar.gltf : null, changes.gltf);

    if (assetDidChange || usdzDidChange || gltfDidChange) {
      // console.log('UpdateViewComponent.getAssetDidChange', assetDidChange, usdzDidChange, gltfDidChange);
      return true;
    } else {
      return false;
    }
  }

  doUpdateView(changes) {
    const assetDidChange = this.getAssetDidChange(changes); // console.log('doUpdateItem.assetDidChange', assetDidChange);

    if (assetDidChange) {
      this.onSubmit();
    }
  }

  doUpdateForm() {
    const view = this.view;

    if (!this.type || this.type.name !== view.type.name) {
      this.type = view.type;
      const form = this.form;
      Object.keys(this.controls).forEach(key => {
        form.removeKey(key);
      });
      let keys;

      switch (view.type.name) {
        case ViewType.WaitingRoom.name:
          keys = ['id', 'type', 'name', 'latitude', 'longitude', 'zoom', 'asset'];
          break;

        case ViewType.Panorama.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;

        case ViewType.PanoramaGrid.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom'];
          break;

        case ViewType.Room3d.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;

        case ViewType.Model.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;

        case ViewType.Media.name:
          keys = ['id', 'type', 'name', 'hidden?', 'asset'];
          break;

        default:
          keys = ['id', 'type', 'name'];
      }

      if (view.type.name !== ViewType.WaitingRoom.name && environment.flags.ar) {
        keys.push('usdz?');
        keys.push('gltf?');
      }

      keys.forEach(key => {
        const optional = key.indexOf('?') !== -1;
        key = key.replace('?', '');

        switch (key) {
          case 'latitude':
          case 'longitude':
            const orientation = view.orientation || {
              latitude: 0,
              longitude: 0
            };
            form.add(new rxcompForm.FormControl(orientation[key], rxcompForm.RequiredValidator()), key);
            break;

          case 'usdz':
          case 'gltf':
            form.add(new rxcompForm.FormControl(view.ar ? view.ar[key] || null : null, optional ? undefined : rxcompForm.RequiredValidator()), key);
            break;

          default:
            form.add(new rxcompForm.FormControl(view[key] != null ? view[key] : null, optional ? undefined : rxcompForm.RequiredValidator()), key);
        }
      });
      this.controls = form.controls;
    }
  }

  onChanges(changes) {
    // console.log('UpdateViewComponent.onChanges');
    this.doUpdateForm();
  }

  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const payload = Object.assign({}, this.form.value);

      if (payload.latitude != null) {
        // !!! keep loose inequality
        payload.orientation = {
          latitude: payload.latitude,
          longitude: payload.longitude
        };
        delete payload.latitude;
        delete payload.longitude;
      }

      const usdz = payload.usdz || null;
      const gltf = payload.gltf || null;
      delete payload.usdz;
      delete payload.gltf;
      payload.ar = usdz || gltf ? {
        usdz,
        gltf
      } : null;
      const view = new View$1(Object.assign({}, this.view, payload));
      /*
      let dataView = Object.assign({}, ViewService.getDataView(this.view.id), payload);
      dataView = new View(dataView);
      let pathView = Object.assign({}, this.view, payload);
      pathView = new View(pathView);
      */

      EditorService.viewUpdate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('UpdateViewComponent.onSubmit.viewUpdate$.success', response);
        this.update.next({
          view: view
        });
        this.setTimeout(() => {
          this.busy = false;
          this.pushChanges();
        });
      }, error => console.log('UpdateViewComponent.onSubmit.viewUpdate$.error', error)); // this.update.next({ view: new View(payload) });
    } else {
      this.form.touched = true;
    }
  }

  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: this.item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view
        });
      }
    });
  }

  onSelect(event) {
    this.select.next({
      view: this.view.selected ? null : this.view
    });
  }

  getTitle(view) {
    return LabelPipe.getKeys('editor', view.type.name);
  }

  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }

  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }

    this.clearTimeout();

    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }

  onDestroy() {
    this.clearTimeout();
  }

}
UpdateViewComponent.meta = {
  selector: 'update-view',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view'],
  template:
  /* html */
  `
		<div class="group--headline" [class]="{ active: view.selected }" (click)="onSelect($event)">
			<!-- <div class="id" [innerHTML]="view.id"></div> -->
			<div class="icon">
				<svg-icon [name]="view.type.name"></svg-icon>
			</div>
			<div class="title" [innerHTML]="getTitle(view)"></div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="view.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<!-- <div control-text [control]="controls.type" label="Type" [disabled]="true"></div> -->
				<div control-text [control]="controls.name" label="Name"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'waiting-room'">
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'panorama'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'panorama-grid'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'room-3d'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'model'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name != 'waiting-room' && ('ar' | flag)">
				<div control-model [control]="controls.usdz" label="AR IOS (.usdz)" accept=".usdz"></div>
				<div control-model [control]="controls.gltf" label="AR Android (.glb)" accept=".glb"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<button type="button" class="btn--remove" *if="view.type.name != 'waiting-room'" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
			</div>
		</form>
	`
};const factories = [AsideComponent, CurvedPlaneModalComponent, EditorComponent, ItemModelModalComponent, NavmapBuilderComponent, NavmapEditComponent, NavmapModalComponent, NavmapItemModalComponent, MediaModalComponent, MenuBuilderComponent, ModelModalComponent, NavModalComponent, PanoramaModalComponent, PanoramaGridModalComponent, PathAddModalComponent, PathEditModalComponent, PlaneModalComponent, RemoveModalComponent, Room3DModalComponent, ToastOutletComponent, UpdateViewItemComponent, UpdateViewTileComponent, UpdateViewComponent];
const pipes = [];
class EditorModule extends rxcomp.Module {}
EditorModule.meta = {
  imports: [],
  declarations: [...factories, ...pipes],
  exports: [...factories, ...pipes]
};class IframeModalComponent extends rxcomp.Component {
  onClose() {
    ModalService.reject();
  }

}
IframeModalComponent.meta = {
  selector: '[iframe-modal]',
  inputs: ['src'],
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="modal__content">
			<iframe [src]="src"></iframe>
		</div>
	`
};

IframeModalComponent.chunk = src =>
/* html */
`<div class="iframe-modal" iframe-modal src="${src}"></div>`;class EnvPipe extends rxcomp.Pipe {
  static transform(keypath) {
    let env = environment;
    const keys = keypath.split('.');
    let k = keys.shift();

    while (keys.length > 0 && env[k]) {
      env = env[k];
      k = keys.shift();
    }

    const value = env[k] || null;
    return value;
  }

}
EnvPipe.meta = {
  name: 'env'
};class FlagPipe extends rxcomp.Pipe {
  static transform(key) {
    const flags = environment.flags;
    return flags[key] || false;
  }

}
FlagPipe.meta = {
  name: 'flag'
};class UploadItem {
  constructor(file) {
    this.file = file;
    this.name = file.name;
    this.type = assetTypeFromPath(file.name);
    this.progress = 0;
    this.size = file.size;
    this.uploading = false;
    this.paused = false;
    this.success = false;
    this.complete = false;
    this.error = null;
    this.preview = null;
  }

}
class UploadEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }

}
class UploadStartEvent extends UploadEvent {}
class UploadCompleteEvent extends UploadEvent {}
class UploadAssetEvent extends UploadEvent {}
class UploadService {
  constructor() {
    this.concurrent$ = new rxjs.BehaviorSubject(0);
    this.items$ = new rxjs.BehaviorSubject([]);
    this.events$ = new rxjs.ReplaySubject(1);
  }

  upload$() {
    const items = this.items$.getValue();
    const uploadItems = items.filter(item => !item.uploading);
    return rxjs.combineLatest(uploadItems.map(item => this.uploadItem$(item)));
  }

  uploadItem$(item) {
    // max 4 concurrent upload
    item.uploading = true;
    this.events$.next(new UploadStartEvent({
      item
    }));
    const files = [item.file];
    return rxjs.of(files).pipe(operators.delayWhen(() => this.concurrent$.pipe(operators.filter(x => x < 4))), operators.tap(() => this.concurrent$.next(this.concurrent$.getValue() + 1)), operators.first(), operators.switchMap(files => AssetService.upload$(files)), operators.switchMap(uploads => {
      const upload = uploads[0];
      item.uploading = false;
      item.complete = true;
      const asset = Asset.fromUrl(upload.url);
      this.events$.next(new UploadCompleteEvent({
        item,
        asset
      }));
      return AssetService.assetCreate$(asset).pipe(operators.tap(asset => {
        this.remove(item);
        this.events$.next(new UploadAssetEvent({
          item,
          asset
        }));
        this.concurrent$.next(this.concurrent$.getValue() - 1);
      }));
    }));
    /*
    // concurrent upload
    return AssetService.upload$([item.file]).pipe(
    	switchMap((uploads) => {
    		const upload = uploads[0];
    		item.uploading = false;
    		item.complete = true;
    		const asset = Asset.fromUrl(upload.url);
    		this.events$.next(new UploadCompleteEvent({ item, asset }));
    		return AssetService.assetCreate$(asset).pipe(
    			tap(asset => {
    				this.remove(item);
    				this.events$.next(new UploadAssetEvent({ item, asset }));
    			}),
    		);
    	}),
    );
    */
  }

  addItems(files) {
    if (files && files.length) {
      // console.log('addItems', files);
      const items = this.items$.getValue();
      const newItems = Array.from(files).map(file => new UploadItem(file));
      items.push(...newItems);
      this.items$.next(items);
    }
  }

  remove(item) {
    const items = this.items$.getValue();
    const index = items.indexOf(item);

    if (index !== -1) {
      items.splice(index, 1);
    }

    this.items$.next(items);
  }

  removeAll() {
    // !!!
    this.items$.next([]);
  }

  drop$(input, dropArea) {
    if (rxcomp.isPlatformBrowser && input) {
      dropArea = dropArea || input;
      const body = document.querySelector('body');
      return rxjs.merge(rxjs.fromEvent(body, 'drop'), rxjs.fromEvent(body, 'dragover')).pipe(operators.map(event => {
        // console.log('UploadService.drop$', event);
        event.preventDefault();

        if (event.target === dropArea) {
          this.addItems(event.dataTransfer.files);
        }

        return this.items$;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }

  change$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      return rxjs.fromEvent(input, 'change').pipe(operators.switchMap(event => {
        if (input.files.length) {
          this.addItems(input.files);
          input.value = '';
        }

        return this.items$;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }

  files$(files) {
    return rxjs.combineLatest(Array.from(files).map((file, i) => this.file$(file, i)));
  }

  file$(file, i) {
    return this.read$(file, i).pipe(operators.switchMap(() => this.uploadFile$(file)));
  }
  /*
  static files$(files) {
  	const fileArray = Array.from(files);
  	this.previews = fileArray.map(() => null);
  	const uploads$ = fileArray.map((file, i) => this.read$(file, i).pipe(
  		switchMap(() => this.uploadFile$(file)),
  	));
  	return combineLatest(uploads$);
  }
  */


  read$(file, i) {
    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.tap(event => {
      const blob = event.target.result;
      this.resize(blob, resized => {
        this.previews[i] = resized; // console.log('resized', resized);

        this.pushChanges();
      });
    }));
    reader.readAsDataURL(file);
    return reader$;
  }

  uploadFile$(file) {
    return AssetService.upload$([file]).pipe(operators.switchMap(uploads => {
      const upload = uploads[0];
      /*
      id: 1601303293569
      type: 'image/jpeg'
      file: '1601303293569_ambiente1_x0_y2.jpg'
      originalFileName: 'ambiente1_x0_y2.jpg'
      url: '/uploads/1601303293569_ambiente1_x0_y2.jpg'
      */

      const asset = Asset.fromUrl(upload.url);
      return AssetService.assetCreate$(asset);
    }));
  }

  resize(blob, callback) {
    if (typeof callback === 'function') {
      const img = document.createElement('img');

      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;

        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }

        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        callback(dataUrl);
      };

      img.src = blob;
    }
  }

  supported() {
    return supportFileAPI() && supportAjaxUploadProgressEvents() && supportFormData();

    function supportFileAPI() {
      var input = document.createElement('input');
      input.type = 'file';
      return 'files' in input;
    }

    function supportAjaxUploadProgressEvents() {
      var xhr = new XMLHttpRequest();
      return !!(xhr && 'upload' in xhr && 'onprogress' in xhr.upload);
    }

    function supportFormData() {
      return !!window.FormData;
    }
  }

}class ControlAssetsComponent extends ControlComponent {
  get items() {
    return this.items_;
  }

  set items(items) {
    this.items_ = items;
    this.uploadCount = items.reduce((p, c) => {
      return p + (c.uploading || c.completed ? 0 : 1);
    }, 0);
  }

  onInit() {
    this.label = this.label || 'label';
    this.accept = this.accept || 'image/png, image/jpeg';
    this.multiple = this.multiple !== false;
    this.items = [];
    this.assets = this.control.value || [];
    this.hasFiles = false;
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    const dropArea = node.querySelector('.upload-drop');
    const service = this.service = new UploadService();
    service.drop$(input, dropArea).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(items => {
      // console.log('ControlAssetComponent.drop$', items);
      this.items = items;
      this.pushChanges();
    });
    service.change$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(items => {
      // console.log('ControlAssetComponent.change$', items);
      this.items = items;
      this.pushChanges();
    });
    service.events$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('ControlAssetComponent.events$', event);
      if (event instanceof UploadAssetEvent) {
        this.assets.push(event.asset);
        this.control.value = this.assets;
      }

      this.items = this.items;
      this.pushChanges(); // this.control.value = assets;
    });
  }

  onUpload() {
    // console.log('ControlAssetsComponent.onUpload');
    this.service.upload$().pipe(operators.first()).subscribe();
  }

  onCancel() {
    // console.log('ControlAssetsComponent.onCancel');
    this.service.removeAll();
  }

  onItemPause(item) {// console.log('ControlAssetsComponent.onPause', item);
  }

  onItemResume(item) {// console.log('ControlAssetsComponent.onResume', item);
  }

  onItemCancel(item) {// console.log('ControlAssetsComponent.onCancel', item);
  }

  onItemRemove(item) {
    // console.log('ControlAssetsComponent.onRemove', item);
    this.service.remove(item);
  }

}
ControlAssetsComponent.meta = {
  selector: '[control-assets]',
  inputs: ['control', 'label', 'multiple'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="listing--assets">
				<div class="listing__item" *for="let item of assets">
					<div class="upload-item">
						<div class="picture">
							<img [lazy]="item | asset" [size]="{ width: 320, height: 240 }" *if="item.type.name === 'image'" />
							<video [src]="item | asset" *if="item.type.name === 'video'"></video>
						</div>
						<div class="name" [innerHTML]="item.file"></div>
					</div>
				</div>
				<div class="listing__item" *for="let item of items">
					<div upload-item [item]="item" (pause)="onItemPause($event)" (resume)="onItemResume($event)" (cancel)="onItemCancel($event)" (remove)="onItemRemove($event)"></div>
				</div>
			</div>
			<div class="group--cta">
				<div class="btn--browse">
					<span [innerHTML]="'browse' | label"></span>
					<input type="file" accept="image/jpeg" multiple />
				</div>
				<div class="btn--upload" (click)="onUpload()" *if="uploadCount > 0" [innerHTML]="'upload' | label"></div>
				<div class="btn--cancel" (click)="onCancel()" *if="uploadCount > 0" [innerHTML]="'cancel' | label"></div>
			</div>
			<div class="upload-drop">
    			<span [innerHTML]="'drag_and_drop_images' | label"></span>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class GenericModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }

    return data;
  }

  onInit() {
    console.log(this.data);
    this.page = null;
    GenericService.currentLanguagePage$(this.data.mode).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(page => {
      this.page = page;
      this.pushChanges();
    });
  }

  onClose() {
    ModalService.reject();
  }

}
GenericModalComponent.meta = {
  selector: '[generic-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container" *if="page">
			<h1 class="title" [innerHTML]="page.title"></h1>
			<div class="description" [innerHTML]="page.description"></div>
		</div>
		<div class="modal__footer">
			<button type="button" class="btn--accept" (click)="onClose()">
				<span [innerHTML]="'title_close' | label"></span>
			</button>
		</div>
	`
};

GenericModalComponent.chunk = () =>
/* html */
`<div class="generic-modal" generic-modal></div>`;class ControlCheckboxComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.linksSubject = new rxjs.ReplaySubject();
    this.links$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }

  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    const links = Array.prototype.slice.call(node.querySelectorAll('a')); // console.log('ControlCheckboxComponent.onChanges', links);

    this.linksSubject.next(links.length ? rxjs.fromEvent(links, 'click') : rxjs.EMPTY);
  }

  links$() {
    const linksSubject = this.linksSubject.pipe(operators.switchAll(), operators.tap(event => {
      // console.log(event);
      if (environment.flags.gdprRoutes) {
        const template = GenericModalComponent.chunk();
        ModalService.open$({
          template,
          data: {
            mode: 'privacy_policy'
          }
        }).pipe(operators.first()).subscribe();
        event.preventDefault();
      }
    }));
    return linksSubject;
  }

}
ControlCheckboxComponent.meta = {
  selector: '[control-checkbox]',
  inputs: ['control', 'label'],
  template:
  /* html */
  `
		<div class="group--form--checkbox" [class]="{ required: control.validators.length }">
			<label>
				<input type="checkbox" class="control--checkbox" [formControl]="control" [value]="true" />
				<span [innerHTML]="label | html"></span>
			</label>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlCustomSelectComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.dropped = false;
    this.dropdownId = DropdownDirective.nextId();
    KeyboardService.typing$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(word => {
      this.scrollToWord(word);
    });
    /*
    KeyboardService.key$().pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe(key => {
    	this.scrollToKey(key);
    });
    */
  }
  /*
  onChanges() {
  	// console.log('ControlCustomSelectComponent.onChanges');
  }
  */


  scrollToWord(word) {
    // console.log('ControlCustomSelectComponent.scrollToWord', word);
    const items = this.control.options || [];
    let index = -1;

    for (let i = 0; i < items.length; i++) {
      const x = items[i];

      if (x.name.toLowerCase().indexOf(word.toLowerCase()) === 0) {
        // console.log(word, x.name);
        index = i;
        break;
      }
    }

    if (index !== -1) {
      const {
        node
      } = rxcomp.getContext(this);
      const dropdown = node.querySelector('.dropdown');
      const navDropdown = node.querySelector('.nav--dropdown');
      const item = navDropdown.children[index];

      if (item) {
        dropdown.scrollTo(0, item.offsetTop);
      }
    }
  }

  setOption(item) {
    // console.log('setOption', item, this.isMultiple);
    let value;

    if (this.isMultiple) {
      const value = this.control.value || [];
      const index = value.indexOf(item.id);

      if (index !== -1) {
        // if (value.length > 1) {
        value.splice(index, 1); // }
      } else {
        value.push(item.id);
      }

      value = value.length ? value.slice() : null;
    } else {
      value = item.id; // DropdownDirective.dropdown$.next(null);
    }

    this.control.value = value;
    this.change.next(value);
  }

  hasOption(item) {
    if (this.isMultiple) {
      const values = this.control.value || [];
      return values.indexOf(item.id) !== -1;
    } else {
      return this.control.value === item.id;
    }
  }

  getLabel() {
    let value = this.control.value;
    const items = this.control.options || [];

    if (this.isMultiple) {
      value = value || [];

      if (value.length) {
        return value.map(v => {
          const item = items.find(x => x.id === v || x.name === v);
          return item ? item.name : '';
        }).join(', ');
      } else {
        return 'select'; // LabelPipe.transform('select');
      }
    } else {
      const item = items.find(x => x.id === value || x.name === value);

      if (item) {
        return item.name;
      } else {
        return 'select'; // LabelPipe.transform('select');
      }
    }
  }

  onDropped($event) {
    // console.log('ControlCustomSelectComponent.onDropped', id);
    if (this.dropped && $event === null) {
      this.control.touched = true;
    }

    this.dropped = $event === this.dropdownId;
  }

  get isMultiple() {
    return this.multiple && this.multiple !== false && this.multiple !== 'false';
  }

}
ControlCustomSelectComponent.meta = {
  selector: '[control-custom-select]',
  outputs: ['change'],
  inputs: ['control', 'label', 'multiple'],
  template:
  /* html */
  `
		<div class="group--form--select" [class]="{ required: control.validators.length, multiple: isMultiple }" [dropdown]="dropdownId" (dropped)="onDropped($event)">
			<label [innerHTML]="label"></label>
			<span class="control--custom-select" [innerHTML]="getLabel() | label"></span>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
		<div class="dropdown" [dropdown-item]="dropdownId">
			<div class="category" [innerHTML]="label"></div>
			<ul class="nav--dropdown" [class]="{ multiple: isMultiple }">
				<li (click)="setOption(item)" [class]="{ empty: item.id == null }" *for="let item of control.options">
					<span [class]="{ active: hasOption(item) }" [innerHTML]="item.name | label"></span>
				</li>
			</ul>
		</div>
	`
};class ControlLinkComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    const {
      node
    } = getContext(this);
    const input = this.input = node.querySelector('input');
    merge(fromEvent(input, 'input')).pipe(takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidChange(event));
    fromEvent(input, 'blur').pipe(takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidBlur(event));
  }

  onInputDidChange(event) {// console.log('ControlLinkComponent.onInputDidChange', event.target.value);
  }

  onInputDidBlur(event) {
    // console.log('ControlLinkComponent.onInputDidBlur', event.target.value);
    this.control.touched = true;
    this.value = this.input.value;
  }

}
ControlLinkComponent.meta = {
  selector: '[control-link]',
  inputs: ['control', 'label', 'disabled'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<input type="text" class="control--text" [formControl]="control" [placeholder]="label" [disabled]="disabled" />
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlLocalizedAssetComponent extends ControlComponent {
  get localizedValue() {
    let asset = this.control.value;

    if (asset && asset.locale) {
      const localizedAsset = asset.locale[this.currentLanguage];

      if (localizedAsset) {
        asset = localizedAsset;
      }
    }

    return asset;
  }

  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || 'image/png, image/jpeg';
    this.languages = environment.languages;
    this.currentLanguage = LanguageService.lang;
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    DropService.drop$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => (this.languages.length > 1 ? AssetService.createOrUpdateLocalizedAsset$ : AssetService.createOrUpdateAsset$)(uploads, this.control, this.currentLanguage))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlLocalizedAssetComponent.change$', assets);
      this.control.value = assets[0];
    });
  }

  setLanguage(language) {
    LanguageService.setLanguage$(language).pipe(operators.first()).subscribe(_ => {
      this.currentLanguage = language;
      this.pushChanges();
    });
  }

}
ControlLocalizedAssetComponent.meta = {
  selector: '[control-localized-asset]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--picture">
				<div class="group--picture__info">
					<span [innerHTML]="'browse' | label"></span>
				</div>
				<img [lazy]="localizedValue | asset" [size]="{ width: 320, height: 240 }" *if="localizedValue && localizedValue.type.name === 'image'" />
				<video [src]="localizedValue | asset" *if="localizedValue && localizedValue.type.name === 'video'"></video>
				<input type="file">
			</div>
			<div class="file-name" *if="localizedValue" [innerHTML]="localizedValue.file"></div>
			<ul class="nav--languages" *if="languages.length > 1">
				<li class="nav__item" [class]="{ active: lang == currentLanguage }" (click)="setLanguage(lang)" [innerHTML]="lang" *for="let lang of languages"></li>
			</ul>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlModelComponent extends ControlAssetComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || '.glb';
    const {
      node
    } = rxcomp.getContext(this);
    const input = this.input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    /*
    this.click$(input).pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe();
    */

    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => AssetService.createOrUpdateAsset$(uploads, this.control))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlModelComponent.change$', assets);
      this.control.value = assets[0];
    });
  }

  onRemove(event) {
    AssetService.assetDelete$(this.control.value).pipe(operators.first()).subscribe(() => {
      this.control.value = null;
      this.input.value = null;
      this.control.touched = true; // !!!
    }); // !!! delete upload
    // !!! delete asset
  }
  /*
  click$(input) {
  	if (isPlatformBrowser && input) {
  		return fromEvent(input, 'click').pipe(
  			tap(() => input.value = null),
  		);
  	} else {
  		return EMPTY;
  	}
  }
  */


  read$(file, i) {
    return rxjs.of(file);
  }

}
ControlModelComponent.meta = {
  selector: '[control-model]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--model">
				<div class="file-name" *if="!control.value" [innerHTML]="'select_file' | label"></div>
				<div class="file-name" *if="control.value" [innerHTML]="control.value.file"></div>
				<div class="btn--upload"><input type="file"><span [innerHTML]="'browse' | label"></span></div>
				<div class="btn--remove" *if="control.value" (click)="onRemove($event)"><span [innerHTML]="'remove' | label"></span></div>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlNumberComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
  }

  updateValue(value) {
    this.control.value = value;
  }

}
ControlNumberComponent.meta = {
  selector: '[control-number]',
  inputs: ['control', 'label', 'precision', 'increment', 'disabled'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="control--content control--number">
				<input-value label="" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value" (update)="updateValue($event)"></input-value>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlPasswordComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
  }

}
ControlPasswordComponent.meta = {
  selector: '[control-password]',
  inputs: ['control', 'label'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length }">
			<label [innerHTML]="label"></label>
			<input type="password" class="control--text" [formControl]="control" [placeholder]="label" />
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlSelectComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
  }

}
ControlSelectComponent.meta = {
  selector: '[control-select]',
  inputs: ['control', 'label'],
  template:
  /* html */
  `
		<div class="group--form--select" [class]="{ required: control.validators.length }">
			<label [innerHTML]="label"></label>
			<select class="control--select" [formControl]="control" required>
				<option [value]="null" [innerHTML]="'select' | label"></option>
				<option [value]="item.id" *for="let item of control.options" [innerHTML]="item.name"></option>
			</select>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlTextComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
  }

}
ControlTextComponent.meta = {
  selector: '[control-text]',
  inputs: ['control', 'label', 'disabled'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
			<input type="text" class="control--text" [formControl]="control" [placeholder]="label" [disabled]="disabled" />
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlTextareaComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
  }

}
ControlTextareaComponent.meta = {
  selector: '[control-textarea]',
  inputs: ['control', 'label', 'disabled'],
  template:
  /* html */
  `
		<div class="group--form--textarea" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<textarea class="control--text" [formControl]="control" [placeholder]="label" [innerHTML]="label" rows="4" [disabled]="disabled"></textarea>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlVectorComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
  }

  updateValue(index, value) {
    const values = this.control.value;
    values[index] = value;
    this.control.value = values.slice();
  }

}
ControlVectorComponent.meta = {
  selector: '[control-vector]',
  inputs: ['control', 'label', 'precision', 'increment', 'disabled'],
  template:
  /* html */
  `
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="control--content control--vector">
				<input-value label="x" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[0]" (update)="updateValue(0, $event)"></input-value>
				<input-value label="y" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[1]" (update)="updateValue(1, $event)"></input-value>
				<input-value label="z" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[2]" (update)="updateValue(2, $event)"></input-value>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class DisabledDirective extends rxcomp.Directive {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this); // console.log('DisabledDirective.onChanges', this.disabled);

    if (this.disabled === true) {
      node.disabled = this.disabled;
      node.setAttribute('disabled', this.disabled);
    } else {
      delete node.disabled;
      node.removeAttribute('disabled');
    }
  }

}
DisabledDirective.meta = {
  selector: 'input[disabled],textarea[disabled]',
  inputs: ['disabled']
};class ErrorsComponent extends ControlComponent {
  getLabel(key, value) {
    const label = LabelPipe.transform(`error_${key}`);
    return label;
  }

}
ErrorsComponent.meta = {
  selector: 'errors-component',
  inputs: ['control'],
  template:
  /* html */
  `
	<div class="inner" [style]="{ display: control.invalid && control.touched ? 'block' : 'none' }">
		<div class="error" *for="let [key, value] of control.errors">
			<span [innerHTML]="getLabel(key, value)"></span>
			<!-- <span class="key" [innerHTML]="key"></span> <span class="value" [innerHTML]="value | json"></span> -->
		</div>
	</div>
	`
};class InputValueComponent extends rxcomp.Component {
  onInit() {
    this.label = this.label || 'label';
    this.value = this.value || 0;
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
    this.increment$('.btn--more', 1).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('InputValueComponent.increment$', event);
      this.value += event;
      this.update.next(this.value);
      this.pushChanges();
    });
    this.increment$('.btn--less', -1).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('InputValueComponent.increment$', event);
      this.value += event;
      this.update.next(this.value);
      this.pushChanges();
    });
    const {
      node
    } = rxcomp.getContext(this);
    const input = this.input = node.querySelector('input'); // fromEvent(input, 'change')

    rxjs.merge(rxjs.fromEvent(input, 'input')).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidChange(event));
    rxjs.merge(rxjs.fromEvent(input, 'blur'), rxjs.fromEvent(input, 'keydown').pipe(operators.filter(event => event.key === 'Enter' || event.keyCode === 13))).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidBlur(event)); // fromEvent(node, 'focus').pipe(takeUntil(this.unsubscribe$)).subscribe(event => this.onFocus(event));
  }

  onInputDidChange(event) {
    // const node = getContext(this).node;
    // const value = node.value === '' ? null : node.value;
    event.target.value = event.target.value.replace(/[^\d|\.|-]/g, ''); // console.log('InputValueComponent.onInputDidChange', event.target.value);

    /*
    const value = parseFloat(event.target.value);
    if (this.value !== value) {
    	if (value !== NaN) {
    		this.value = value;
    		this.update.next(this.value);
    	}
    }
    */
  }

  onInputDidBlur(event) {
    // this.control.touched = true;
    // console.log('InputValueComponent.onInputDidBlur', event.target.value);
    const value = parseFloat(this.input.value);

    if (this.value !== value) {
      if (value !== NaN) {
        this.value = value;
        this.update.next(this.value);
      } else {
        this.input.value = this.getValue();
      }
    }
  }

  increment$(selector, sign) {
    const {
      node
    } = rxcomp.getContext(this);
    const element = node.querySelector(selector);
    let m, increment;
    return rxjs.race(rxjs.fromEvent(element, 'mousedown'), rxjs.fromEvent(element, 'touchstart')).pipe(operators.tap(() => {
      increment = this.increment;
      m = 16;
    }), operators.switchMap(e => {
      return rxjs.interval(30).pipe(operators.filter(i => {
        return i % m === 0;
      }), operators.map(() => {
        const i = increment * sign; // increment = Math.min(this.increment * 100, increment * 2);

        m = Math.max(1, Math.floor(m * 0.85));
        return i;
      }), // startWith(increment * sign),
      operators.takeUntil(rxjs.race(rxjs.fromEvent(element, 'mouseup'), rxjs.fromEvent(element, 'touchend'))));
    }));
  }

  getValue() {
    return this.value.toFixed(this.precision);
  }

  setValue(sign) {
    this.value += this.increment * sign;
    this.update.next(this.value);
    this.pushChanges();
  }

}
InputValueComponent.meta = {
  selector: 'input-value',
  outputs: ['update'],
  inputs: ['value', 'label', 'precision', 'increment', 'disabled'],
  template:
  /* html */
  `
		<div class="group--control" [class]="{ disabled: disabled }">
			<input type="text" class="control--text" [placeholder]="label" [value]="getValue()" [disabled]="disabled" />
			<div class="control--trigger">
				<div class="btn--more" (click)="setValue(1)">+</div>
				<div class="btn--less" (click)="setValue(-1)">-</div>
			</div>
		</div>
	`
};class TestComponent extends rxcomp.Component {
  onInit() {
    this.env = ENV;
  }

  onTest(event) {
    this.test.next(event);
  }

  onReset(event) {
    this.reset.next(event);
  }

}
TestComponent.meta = {
  selector: 'test-component',
  inputs: ['form'],
  outputs: ['test', 'reset'],
  template:
  /* html */
  `
	<div class="group--form--results" *if="env.DEVELOPMENT">
		<code [innerHTML]="form.value | json"></code>
		<button type="button" class="btn--mode" (click)="onReset($event)"><span>reset</span></button>
		<button type="button" class="btn--mode" (click)="onTest($event)"><span>test</span></button>
	</div>
	`
};class ValueDirective extends rxcomp.Directive {
  onChanges(changes) {
    const {
      node
    } = rxcomp.getContext(this); // console.log('ValueDirective.onChanges', this.value);

    node.value = this.value;
    node.setAttribute('value', this.value);
  }

}
ValueDirective.meta = {
  selector: '[value]',
  inputs: ['value']
};/*
['quot', 'amp', 'apos', 'lt', 'gt', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'amp', 'bull', 'deg', 'infin', 'permil', 'sdot', 'plusmn', 'dagger', 'mdash', 'not', 'micro', 'perp', 'par', 'euro', 'pound', 'yen', 'cent', 'copy', 'reg', 'trade', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'];
['"', '&', ''', '<', '>', ' ', '¡', '¢', '£', '¤', '¥', '¦', '§', '¨', '©', 'ª', '«', '¬', '­', '®', '¯', '°', '±', '²', '³', '´', 'µ', '¶', '·', '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', '&', '•', '°', '∞', '‰', '⋅', '±', '†', '—', '¬', 'µ', '⊥', '∥', '€', '£', '¥', '¢', '©', '®', '™', 'α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω', 'Α', 'Β', 'Γ', 'Δ', 'Ε', 'Ζ', 'Η', 'Θ', 'Ι', 'Κ', 'Λ', 'Μ', 'Ν', 'Ξ', 'Ο', 'Π', 'Ρ', 'Σ', 'Τ', 'Υ', 'Φ', 'Χ', 'Ψ', 'Ω'];
*/

class HtmlPipe extends rxcomp.Pipe {
  static transform(value) {
    if (value) {
      value = value.replace(/&#(\d+);/g, function (m, n) {
        return String.fromCharCode(parseInt(n));
      });
      const escapes = ['quot', 'amp', 'apos', 'lt', 'gt', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'amp', 'bull', 'deg', 'infin', 'permil', 'sdot', 'plusmn', 'dagger', 'mdash', 'not', 'micro', 'perp', 'par', 'euro', 'pound', 'yen', 'cent', 'copy', 'reg', 'trade', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'];
      const unescapes = ['"', '&', '\'', '<', '>', ' ', '¡', '¢', '£', '¤', '¥', '¦', '§', '¨', '©', 'ª', '«', '¬', '­', '®', '¯', '°', '±', '²', '³', '´', 'µ', '¶', '·', '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', '&', '•', '°', '∞', '‰', '⋅', '±', '†', '—', '¬', 'µ', '⊥', '∥', '€', '£', '¥', '¢', '©', '®', '™', 'α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω', 'Α', 'Β', 'Γ', 'Δ', 'Ε', 'Ζ', 'Η', 'Θ', 'Ι', 'Κ', 'Λ', 'Μ', 'Ν', 'Ξ', 'Ο', 'Π', 'Ρ', 'Σ', 'Τ', 'Υ', 'Φ', 'Χ', 'Ψ', 'Ω'];
      const rx = new RegExp(`(&${escapes.join(';)|(&')};)`, 'g');
      value = value.replace(rx, function () {
        for (let i = 1; i < arguments.length; i++) {
          if (arguments[i]) {
            // console.log(arguments[i], unescapes[i - 1]);
            return unescapes[i - 1];
          }
        }
      }); // console.log(value);

      return value;
    }
  }

}
HtmlPipe.meta = {
  name: 'html'
};class IdDirective extends rxcomp.Directive {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    node.setAttribute('id', this.id);
  }

}
IdDirective.meta = {
  selector: '[id]',
  inputs: ['id']
};class LanguageComponent extends rxcomp.Component {
  onInit() {
    this.showLanguages = false;
    this.languageService = LanguageService;
  }

  setLanguage(language) {
    this.languageService.setLanguage$(language).pipe(operators.first()).subscribe(_ => {
      this.showLanguages = false;
      this.pushChanges();
      this.set.next();
    });
  }

  toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }

}
LanguageComponent.meta = {
  selector: '[language]',
  outputs: ['set'],
  template:
  /* html */
  `
		<button type="button" class="btn--language" (click)="toggleLanguages()" *if="languageService.hasLanguages"><span [innerHTML]="languageService.activeLanguage.title"></span> <svg viewBox="0 0 8 5"><use xlink:href="#caret-down"></use></svg></button>
		<ul class="nav--language" *if="showLanguages">
			<li (click)="setLanguage(language)" *for="let language of languageService.languages"><span [innerHTML]="language.title"></span></li>
		</ul>
	`
};class IntersectionService {
  static observer() {
    if (!this.observer_) {
      this.readySubject_ = new rxjs.BehaviorSubject(false);
      this.observerSubject_ = new rxjs.Subject();
      this.observer_ = new IntersectionObserver(entries => {
        this.observerSubject_.next(entries);
      });
    }

    return this.observer_;
  }

  static intersection$(node) {
    if ('IntersectionObserver' in window) {
      const observer = this.observer();
      observer.observe(node);
      return this.observerSubject_.pipe( // tap(entries => console.log(entries.length)),
      operators.map(entries => entries.find(entry => entry.target === node)), // tap(entry => console.log('IntersectionService.intersection$', entry)),
      operators.filter(entry => entry !== undefined && entry.isIntersecting), // entry.intersectionRatio > 0
      operators.first(), operators.finalize(() => observer.unobserve(node)));
    } else {
      return rxjs.of({
        target: node
      });
    }
    /*
    function observer() {
    	if ('IntersectionObserver' in window) {
    		return new IntersectionObserver(entries => {
    			entries.forEach(function(entry) {
    				if (entry.isIntersecting) {
    					entry.target.classList.add('appear');
    				}
    			})
    		});
    	} else {
    		return { observe: function(node) { node.classList.add('appear')}, unobserve: function() {} };
    	}
    }
    observer.observe(node);
    observer.unobserve(node);
    */

  }

}class LazyCache {
  static get cache() {
    if (!this.cache_) {
      this.cache_ = {};
    }

    return this.cache_;
  }

  static get(src) {
    return this.cache[src];
  }

  static set(src, blob) {
    this.cache[src] = blob;
    const keys = Object.keys(this.cache);

    if (keys.length > 100) {
      this.remove(keys[0]);
    }
  }

  static remove(src) {
    delete this.cache[src];
  }

}class LazyDirective extends rxcomp.Directive {
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('lazy');
    this.input$ = new rxjs.Subject().pipe(operators.distinctUntilChanged(), operators.switchMap(input => {
      const src = LazyCache.get(input);

      if (src) {
        return rxjs.of(src);
      }

      node.classList.remove('lazyed');
      return this.lazy$(input);
    }), operators.takeUntil(this.unsubscribe$));
    this.input$.subscribe(src => {
      LazyCache.set(this.lazy, src);
      node.setAttribute('src', src);
      node.classList.add('lazyed');
    });
  }

  onChanges() {
    this.input$.next(this.lazy);
  }

  lazy$(input) {
    const {
      node
    } = rxcomp.getContext(this);
    return IntersectionService.intersection$(node).pipe( // first(),
    operators.switchMap(() => ImageService.load$(input, this.size)), operators.first() // takeUntil(this.unsubscribe$),
    );
  }

}
LazyDirective.meta = {
  selector: '[lazy],[[lazy]]',
  inputs: ['lazy', 'size']
};class MessagePipe extends rxcomp.Pipe {
  static transform(text) {
    let html = MessagePipe.urlify(text);
    html = MessagePipe.breakLines(html); // console.log('MessagePipe', text, html);

    return html;
  }

  static urlify(text) {
    // const regex = new RegExp(URL_PATTERN, 'gim');
    const regex = /(?:(?:https?|ftp):\/\/|\b(?:[a-z\d]+\.))(?:(?:[^\s()<>]+|\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))?\))+(?:\((?:[^\s()<>]+|(?:\(?:[^\s()<>]+\)))?\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))?/gmi;
    return text.replace(regex, url => {
      return (
        /*html*/
        `<a href="${url}" target="_blank">${url}</a>`
      );
    }); // or alternatively
    // return text.replace(urlRegex, '<a href="$1">$1</a>')
  }

  static breakLines(text) {
    const regex = /\n/gm;
    return text.replace(regex, text => {
      return (
        /*html*/
        `<br>`
      );
    });
  }

}
MessagePipe.meta = {
  name: 'message'
};class ModalComponent extends rxcomp.Component {
  onInit() {
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }

  onClose() {
    ModalService.reject();
  }

}
ModalComponent.meta = {
  selector: '[modal]'
};class RouterLinkDirective extends rxcomp.Directive {
  constructor() {
    super(...arguments);
    this.path = void 0;
    this.segments = void 0;
    this.routerLink_ = void 0;
  }

  get routerLink() {
    return this.routerLink_;
  }

  set routerLink(routerLink) {
    this.routerLink_ = Array.isArray(routerLink) ? routerLink : [routerLink]; // this.segments = this.getSegments(this.routerLink_);
  }

  onInit() {
    // const { node, module } = getContext(this);
    // console.log('RouterLinkDirective.onInit', this.routerLink, node, module);
    this.routerLink$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }

  onChanges() {
    const {
      node
    } = rxcomp.getContext(this); // const routerLink = Array.isArray(this.routerLink) ? this.routerLink : [this.routerLink];

    const routerLink = this.routerLink;

    if (routerLink.length) {
      const routeUrl = RouterService.buildUrl(...routerLink); // RouterService.isActive(name, params, [strictEquality], [ignoreQueryParams])
      // console.log('RouterLinkDirective.routeUrl', routeUrl);

      node.setAttribute('href', routeUrl);
    } else {
      node.setAttribute('href', '');
    }
  }

  routerLink$() {
    const {
      node
    } = rxcomp.getContext(this);
    return rxjs.fromEvent(node, 'click').pipe(operators.map(event => {
      // console.log('RouterLinkDirective.routerLink$', this.routerLink);
      RouterService.setRouterLink(...this.routerLink);
      event.preventDefault();
      return false;
    }));
  }

  getSegments(routerLink) {
    // console.log('RouterLinkDirective.getSegments', routerLink);
    const segments = [];
    routerLink.forEach(item => {
      if (typeof item === 'string') {
        const regExp = /([^:]+)|\:([^\/]+)/g;
        const matches = item.matchAll(regExp);

        for (let match of matches) {
          const g1 = match[1];
          const g2 = match[2];

          if (g1) ; else if (g2) {
            const param = {};
            param[g2] = null;
          }
        }
      } else {
        segments.push(new RouteSegment('', {}));
      }
    });
    return segments;
  }

}
/*
get urlTree(): UrlTree {
	return RouterService.createUrlTree(this.routerLink, {
		relativeTo: this.route,
		queryParams: this.queryParams,
		fragment: this.fragment,
		preserveQueryParams: this.preserve,
		queryParamsHandling: this.queryParamsHandling,
		preserveFragment: this.preserveFragment,
	});
}
*/

RouterLinkDirective.meta = {
  selector: '[routerLink]',
  inputs: ['routerLink']
};class SupportRequestModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance
    } = rxcomp.getContext(this);

    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }

  onAccept(user) {
    ModalService.resolve();
  }

  onReject(user) {
    ModalService.reject();
  }

  onClose() {
    ModalService.reject();
  }

}
SupportRequestModalComponent.meta = {
  selector: '[support-request-modal]',
  template:
  /* html */
  `
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Un operatore è disponibile per un tour guidato.<br>Desideri Accettare?</div>
				<div class="group--cta">
					<button type="button" class="btn--accept" (click)="onAccept()">
						<span>Accetta</span>
					</button>
					<button type="button" class="btn--cancel" (click)="onReject()">
						<span>Rifiuta</span>
					</button>
				</div>
			</div>
		</div>
	`
};

SupportRequestModalComponent.chunk = () =>
/* html */
`<div class="support-request-modal" support-request-modal></div>`;class SvgIconStructure extends rxcomp.Structure {
  onInit() {
    this.update();
  }

  onChanges() {
    this.update();
  }

  update() {
    if (this.name_ !== this.name) {
      this.name_ = this.name;
      const {
        node
      } = rxcomp.getContext(this);

      if (node.parentNode) {
        const xmlns = 'http://www.w3.org/2000/svg';
        const element = document.createElementNS(xmlns, `svg`);
        const w = this.width || 24;
        const h = this.height || 24;
        element.setAttribute('class', `icon--${this.name}`); // element.setAttributeNS(null, 'width', w);
        // element.setAttributeNS(null, 'height', h);

        element.setAttributeNS(null, 'viewBox', `0 0 ${w} ${h}`);
        element.innerHTML = `<use xlink:href="#${this.name}"></use>`;
        element.rxcompId = node.rxcompId;
        element.classList.add(...node.classList);
        node.parentNode.replaceChild(element, node);
      }
    }
  }

}
SvgIconStructure.meta = {
  selector: 'svg-icon',
  inputs: ['name', 'width', 'height']
};
/*
<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
*/class TitleDirective extends rxcomp.Directive {
  set title(title) {
    if (this.title_ !== title) {
      this.title_ = title;
      const {
        node
      } = rxcomp.getContext(this);
      title ? node.setAttribute('title', title) : node.removeAttribute('title');
    }
  }

  get title() {
    return this.title_;
  }

}
TitleDirective.meta = {
  selector: '[[title]]',
  inputs: ['title']
};class UploadItemComponent extends rxcomp.Component {
  onInit() {
    // console.log('UploadItemComponent.onInit', this.item);
    if (this.item.preview === null) {
      this.read$(this.item.file).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(preview => {
        this.item.preview = preview;
        this.pushChanges();
      });
    }
  }

  read$(file) {
    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.switchMap(event => {
      const blob = event.target.result;

      if (this.item.type.name === AssetType.Image.name) {
        return this.resize$(blob);
      } else {
        return rxjs.of(blob);
      }
    }));
    reader.readAsDataURL(file);
    return reader$;
  }

  resize$(blob) {
    return new Promise((resolve, reject) => {
      const img = document.createElement('img');

      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;

        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }

        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        resolve(dataUrl);
      };

      img.onerror = function (error) {
        reject(error);
      };

      img.src = blob;
    });
  }

  onPause() {
    this.pause.next(this.item);
  }

  onResume() {
    this.resume.next(this.item);
  }

  onCancel() {
    this.cancel.next(this.item);
  }

  onRemove() {
    this.remove.next(this.item);
  }

}
UploadItemComponent.meta = {
  selector: '[upload-item]',
  outputs: ['pause', 'resume', 'cancel', 'remove'],
  inputs: ['item'],
  template:
  /* html */
  `
	<div class="upload-item" [class]="{ 'error': item.error, 'success': item.success }">
		<div class="picture">
			<img [lazy]="item.preview" [size]="{ width: 320, height: 240 }" *if="item.preview && item.type.name === 'image'" />
			<video [src]="item.preview" *if="item.preview && item.type.name === 'video'"></video>
			<svg class="spinner" width="24" height="24" viewBox="0 0 24 24" [class]="{ uploading: item.uploading }" *if="item.uploading"><use xlink:href="#spinner"></use></svg>
		</div>
		<div class="name">{{item.name}}</div>
		<!--
		<div class="group--info">
			<div>progress: {{item.progress}}</div>
			<div>size: {{item.size}} bytes</div>
			<div>current speed: {{item.currentSpeed}} bytes/s</div>
			<div>average speed: {{item.averageSpeed}} bytes/s</div>
			<div>time ramining: {{item.timeRemaining}}s</div>
			<div>paused: {{item.paused}}</div>
			<div>success: {{item.success}}</div>
			<div>complete: {{item.complete}}</div>
			<div>error: {{item.error}}</div>
		</div>
		-->
		<!--
		<div class="group--cta" *if="!item.complete && item.uploading">
			<div class="btn--pause" (click)="onPause()">pause</div>
			<div class="btn--resume" (click)="onResume()">resume</div>
			<div class="btn--cancel" (click)="onCancel()">cancel</div>
		</div>
		-->
		<div class="group--cta">
			<div class="btn--remove" (click)="onRemove()" *if="!item.complete">remove</div>
		</div>
	</div>
	`
};class HlsDirective extends rxcomp.Directive {
  set hls(hls) {
    if (this.hls_ !== hls) {
      this.hls_ = hls;
      this.play(hls);
    }
  }

  get hls() {
    return this.hls_;
  }

  play(src) {
    const {
      node
    } = rxcomp.getContext(this);

    if (Hls.isSupported()) {
      var hls = new Hls(); // bind them together

      hls.attachMedia(node);
      hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        hls.loadSource(src);
        hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
          // console.log('HlsDirective', data.levels);
          node.play();
        });
      });
    }
  }

}
HlsDirective.meta = {
  selector: '[[hls]]',
  inputs: ['hls']
};class VirtualItem extends rxcomp.Context {
  constructor(key, $key, value, $value, index, count, parentInstance) {
    super(parentInstance);
    this[key] = $key;
    this[value] = $value;
    this.index = index;
    this.count = count;
  }

  get first() {
    return this.index === 0;
  }

  get last() {
    return this.index === this.count - 1;
  }

  get even() {
    return this.index % 2 === 0;
  }

  get odd() {
    return !this.even;
  }

}const VirtualMode = {
  Responsive: 1,
  Grid: 2,
  Centered: 3,
  List: 4
};
class VirtualStructure extends rxcomp.Structure {
  onInit() {
    const {
      module,
      node
    } = rxcomp.getContext(this);
    const template = node.firstElementChild;
    const expression = node.getAttribute('*virtual');
    node.removeAttribute('*virtual');
    node.removeChild(template);
    const tokens = this.tokens = this.getExpressionTokens(expression);
    this.virtualFunction = module.makeFunction(tokens.iterable);
    this.container = node;
    this.template = template;
    this.mode = this.mode || 1;
    this.width = this.width || 250;
    this.gutter = this.gutter !== undefined ? this.gutter : 20;
    this.reverse = this.reverse === true ? true : false;
    this.options = {
      width: this.width,
      gutter: this.gutter,
      reverse: this.reverse,
      containerWidth: 0,
      containerHeight: 0,
      top: 0,
      cols: [0]
    };
    this.cachedRects = {};
    this.cachedInstances = [];
    this.cacheNodes = [];
    this.items$ = new rxjs.BehaviorSubject([]);
    this.update$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(visibleItems => {// console.log(visibleItems.length);
    });
  }

  onChanges(changes) {
    const context = rxcomp.getContext(this);
    const module = context.module; // resolve

    const items = module.resolve(this.virtualFunction, context.parentInstance, this) || [];
    this.mode = this.mode || 1;
    this.width = this.width || 250;
    this.gutter = this.gutter !== undefined ? this.gutter : 20;
    this.options.width = this.width;
    this.updateView(true);
    this.items$.next(items); // console.log('VirtualStructure', 'items.length', items.length);
  }

  update$() {
    this.updateView(true);
    return rxjs.merge(this.scroll$(), this.resize$(), this.items$.pipe(operators.distinctUntilChanged())).pipe(operators.map(_ => {
      const visibleItems = this.updateForward();
      return visibleItems;
    }));
  }

  updateForward() {
    const options = this.options;
    const items = this.items$.getValue();
    const total = items.length;
    this.container.position = 'relative';
    let highestHeight = 0;
    const width = this.getWidth();
    const gutter = this.getGutter(width);
    const visibleItems = [];

    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      let col, height, top, left, bottom;
      let rect = this.cachedRects[i];

      if (rect) {
        col = rect.col;
        height = rect.height;
        left = rect.left; // top = rect.top;
        // bottom = rect.bottom;
      } else {
        col = this.getCol();
        height = this.getHeight(width, item);
      }

      top = options.cols[col];

      if (this.intersect(top + options.top, top + height + options.top, 0, options.containerHeight)) {
        if (!rect) {
          left = this.getLeft(col, width, gutter);
        }

        const node = this.cachedNode(i, i, item, total);
        node.style.position = 'absolute';
        node.style.top = top + 'px';
        node.style.left = left + 'px';
        node.style.width = width + 'px';

        if (height !== node.offsetHeight) {
          height = node.offsetHeight;
        }

        bottom = top + height + options.gutter;
        highestHeight = Math.max(highestHeight, bottom);
        options.cols[col] = bottom;

        if (!rect) {
          this.cachedRects[i] = {
            col,
            width,
            height,
            left,
            top,
            bottom
          };
        } else {
          rect.height = height;
          rect.bottom = bottom;
        }

        visibleItems.push(item);
      } else {
        this.removeNode(i);
        bottom = top + height + options.gutter;
        options.cols[col] = bottom;
        highestHeight = Math.max(highestHeight, bottom);
      }
    }

    let removeIndex = items.length;

    while (removeIndex < this.cacheNodes.length) {
      this.removeNode(removeIndex);
      removeIndex++;
    }

    this.cacheNodes.length = items.length;
    const parentContainer = this.container.parentNode;

    if (this.reverse && highestHeight < parentContainer.offsetHeight - 1) {
      const diff = parentContainer.offsetHeight - 1 - highestHeight;
      items.forEach((item, i) => {
        if (visibleItems.indexOf(item) !== -1) {
          const rect = this.cachedRects[i];
          const node = this.cachedNode(i, i, item, total);
          node.style.top = rect.top + diff + 'px';
        }
      });
      this.container.style.height = `${parentContainer.offsetHeight - 1}px`;
    } else {
      this.container.style.height = `${highestHeight}px`;
    } // console.log('VirtualStructure.updateForward', 'items.length', items.length, highestHeight, visibleItems);


    return visibleItems;
  }
  /*
  updateForward__() {
  	const options = this.options;
  	const items = this.items$.getValue();
  	// console.log('VirtualStructure', 'items.length', items.length);
  	const total = items.length;
  	this.container.position = 'relative';
  	let highestHeight = 0;
  	const width = this.getWidth();
  	const gutter = this.getGutter(width);
  	const visibleItems = items.filter((item, i) => {
  		let col, height, top, left, bottom;
  		let rect = this.cachedRects[i];
  		if (rect) {
  			col = rect.col;
  			height = rect.height;
  			left = rect.left;
  			// top = rect.top;
  			// bottom = rect.bottom;
  		} else {
  			col = this.getCol();
  			height = this.getHeight(width, item);
  		}
  		top = options.cols[col];
  		if (this.intersect(top + options.top, top + height + options.top, options.top, options.top + options.containerHeight)) {
  			if (!rect) {
  				left = this.getLeft(col, width, gutter);
  			}
  			const node = this.cachedNode(i, i, item, total);
  			node.style.position = 'absolute';
  			node.style.top = top + 'px';
  			node.style.left = left + 'px';
  			node.style.width = width + 'px';
  			if (height !== node.offsetHeight) {
  				height = node.offsetHeight;
  			}
  			bottom = top + height + options.gutter;
  			highestHeight = Math.max(highestHeight, bottom);
  			options.cols[col] = bottom;
  			if (!rect) {
  				this.cachedRects[i] = { col, width, height, left, top, bottom };
  			} else {
  				rect.height = height;
  				rect.bottom = bottom;
  			}
  			return true;
  		} else {
  			this.removeNode(i);
  			bottom = top + height + options.gutter;
  			options.cols[col] = bottom;
  			highestHeight = Math.max(highestHeight, bottom);
  			return false;
  		}
  	});
  	let removeIndex = items.length;
  	while (removeIndex < this.cacheNodes.length) {
  		this.removeNode(removeIndex);
  		removeIndex++;
  	}
  	this.cacheNodes.length = items.length;
  	this.container.style.height = `${highestHeight}px`;
  	return visibleItems;
  }
  
  updateBackward__() {
  	const options = this.options;
  	const items = this.items$.getValue();
  	// console.log('VirtualStructure', 'items.length', items.length);
  	const total = items.length;
  	this.container.position = 'relative';
  	let lowestHeight = 0;
  	const width = this.getWidth();
  	const gutter = this.getGutter(width);
  	const visibleItems = [];
  	for (let i = items.length - 1; i >= 0; i--) {
  		const item = items[i];
  		let col, height, top, left, bottom;
  		let rect = this.cachedRects[i];
  		if (rect) {
  			col = rect.col;
  			height = rect.height;
  			left = rect.left;
  			// top = rect.top;
  			// bottom = rect.bottom;
  		} else {
  			col = this.getCol();
  			height = this.getHeight(width, item);
  		}
  		bottom = options.cols[col];
  		if (this.intersect(bottom - height + options.top, bottom + options.top, options.top, options.top + options.containerHeight)) {
  			if (!rect) {
  				left = this.getLeft(col, width, gutter);
  			}
  			const node = this.cachedNode(i, i, item, total);
  			node.style.position = 'absolute';
  			node.style.top = top + 'px';
  			node.style.left = left + 'px';
  			node.style.width = width + 'px';
  			if (height !== node.offsetHeight) {
  				height = node.offsetHeight;
  			}
  			top = bottom - height - options.gutter;
  			lowestHeight = Math.min(lowestHeight, -top);
  			options.cols[col] = top;
  			if (!rect) {
  				this.cachedRects[i] = { col, width, height, left, top, bottom: bottom };
  			} else {
  				rect.height = height;
  				rect.top = top;
  			}
  			visibleItems.push(item);
  		} else {
  			this.removeNode(i);
  			top = bottom - height - options.gutter;
  			options.cols[col] = top;
  			lowestHeight = Math.min(lowestHeight, top);
  		}
  	}
  	let removeIndex = items.length;
  	while (removeIndex < this.cacheNodes.length) {
  		this.removeNode(removeIndex);
  		removeIndex++;
  	}
  	this.cacheNodes.length = items.length;
  	this.container.style.height = `${-lowestHeight}px`;
  	return visibleItems;
  }
  */


  getCols() {
    const options = this.options;
    const cols = Math.floor((options.containerWidth + options.gutter) / (options.width + options.gutter)) || 1;
    return new Array(cols).fill(0);
  }

  getCol() {
    const options = this.options;
    let col;

    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
      case VirtualMode.Responsive:
        col = options.cols.reduce((p, c, i, a) => {
          return c < a[p] ? i : p;
        }, 0);
        break;

      case VirtualMode.List:
      default:
        col = 0;
    }

    return col;
  }

  getWidth() {
    const options = this.options;
    let width;

    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
        width = options.width;
        break;

      case VirtualMode.Responsive:
        width = (options.containerWidth - (options.cols.length - 1) * options.gutter) / options.cols.length;
        break;

      case VirtualMode.List:
      default:
        width = options.containerWidth;
    }

    return width;
  }

  getHeight(width, item) {
    const options = this.options;
    let height;

    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
      case VirtualMode.Responsive:
        height = options.width;
        break;

      case VirtualMode.List:
      default:
        height = 80;
    }

    return height;
  }

  getGutter(width) {
    const options = this.options;
    let gutter;

    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
        gutter = options.gutter;
        break;

      case VirtualMode.Responsive:
        gutter = (options.containerWidth - options.cols.length * width) / (options.cols.length - 1);
        break;

      case VirtualMode.List:
      default:
        gutter = 0;
    }

    return gutter;
  }

  getLeft(index, width, gutter) {
    const options = this.options;
    let left;

    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Responsive:
        left = index * (width + gutter);
        break;

      case VirtualMode.Centered:
        left = (options.containerWidth - options.cols.length * (width + gutter) + gutter) / 2 + index * (width + gutter);
        break;

      case VirtualMode.List:
      default:
        left = 0;
    }

    return left;
  }

  cachedNode(index, i, value, total) {
    if (this.cacheNodes[index]) {
      return this.updateNode(index, i, value);
    } else {
      return this.createNode(index, i, value, total);
    }
  }

  createNode(index, i, value, total) {
    const clonedNode = this.template.cloneNode(true);
    delete clonedNode.rxcompId;
    this.container.appendChild(clonedNode);
    this.cacheNodes[index] = clonedNode;
    const context = rxcomp.getContext(this);
    const module = context.module;
    const tokens = this.tokens;
    const args = [tokens.key, i, tokens.value, value, i, total, context.parentInstance];
    const instance = module.makeInstance(clonedNode, VirtualItem, context.selector, context.parentInstance, args);
    const forItemContext = rxcomp.getContext(instance);
    module.compile(clonedNode, forItemContext.instance);
    this.cachedInstances[index] = instance;
    return clonedNode;
  }

  updateNode(index, i, value) {
    const instance = this.cachedInstances[index];
    const tokens = this.tokens;

    if (instance[tokens.key] !== i) {
      instance[tokens.key] = i;
      instance[tokens.value] = value;
      instance.pushChanges();
    } // console.log(index, i, value);


    return this.cacheNodes[index];
  }

  removeNode(index) {
    this.cachedInstances[index] = undefined;
    const node = this.cacheNodes[index];

    if (node) {
      const context = rxcomp.getContext(this);
      const module = context.module;
      node.parentNode.removeChild(node);
      module.remove(node);
    }

    this.cacheNodes[index] = undefined;
    return node;
  }

  intersect(top1, bottom1, top2, bottom2) {
    // console.log(top2, '<', bottom1, bottom2, '>', top1);
    return top2 < bottom1 && bottom2 > top1;
  }

  resize$() {
    return rxjs.fromEvent(window, 'resize').pipe(operators.startWith(_ => null), operators.auditTime(100), operators.tap(() => this.updateView(true)));
  }

  scroll$() {
    const {
      node
    } = rxcomp.getContext(this); // console.log(node.parentNode, getComputedStyle(node.parentNode).overflowY, node.parentNode.style.overflowY);

    if (node.parentNode && getComputedStyle(node.parentNode).overflowY === 'auto') {
      return rxjs.fromEvent(node.parentNode, 'scroll').pipe(operators.tap(() => {
        this.updateView();
      }));
    } else {
      return rxjs.fromEvent(window, 'scroll').pipe(operators.tap(() => this.updateView()));
    }
  }

  updateView(reset) {
    const rect = this.container.getBoundingClientRect();
    const options = this.options;
    options.top = rect.top;
    options.containerWidth = rect.width; // options.containerHeight = rect.height;

    options.containerHeight = this.container.parentNode.offsetHeight;
    options.cols = this.getCols();

    if (reset) {
      this.cachedRects = {};
    }
  }

  getExpressionTokens(expression) {
    if (expression === null) {
      throw new Error('invalid virtual');
    }

    if (expression.trim().indexOf('let ') === -1 || expression.trim().indexOf(' of ') === -1) {
      throw new Error('invalid virtual');
    }

    const expressions = expression.split(';').map(x => x.trim()).filter(x => x !== '');
    const virtualExpressions = expressions[0].split(' of ').map(x => x.trim());
    let value = virtualExpressions[0].replace(/\s*let\s*/, '');
    const iterable = virtualExpressions[1];
    let key = 'index';
    const keyValueMatches = value.match(/\[(.+)\s*,\s*(.+)\]/);

    if (keyValueMatches) {
      key = keyValueMatches[1];
      value = keyValueMatches[2];
    }

    if (expressions.length > 1) {
      const indexExpressions = expressions[1].split(/\s*let\s*|\s*=\s*index/).map(x => x.trim());

      if (indexExpressions.length === 3) {
        key = indexExpressions[1];
      }
    }

    return {
      key,
      value,
      iterable
    };
  }

}
VirtualStructure.meta = {
  selector: '[*virtual]',
  inputs: ['mode', 'width', 'gutter', 'reverse']
};class MediaPlayerComponent extends rxcomp.Component {
  onInit() {
    // console.log('MediaPlayerComponent', this.media);
    this.playing = false;
    this.progress = 0;
    this.media$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    this.drag$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }

  media$() {
    const {
      node
    } = rxcomp.getContext(this);
    const page = document.querySelector('.page');
    return MediaLoader.events$.pipe( // filter(event => event.loader.item.id === this.media.item.id),
    operators.tap(event => {
      if (event instanceof MediaLoaderPlayEvent) {
        this.media = event.loader;
        this.playing = true;
        node.classList.add('active');
        page.classList.add('media-player-active');
        this.pushChanges();
      } else if (this.media === event.loader) {
        if (event instanceof MediaLoaderPauseEvent) {
          this.playing = false;
          this.pushChanges();
        } else if (event instanceof MediaLoaderTimeUpdateEvent) {
          if (!this.dragging) {
            this.progress = this.media.progress;
            this.pushChanges();
          }
        } else if (event instanceof MediaLoaderDisposeEvent) {
          this.media = null;
          node.classList.remove('active');
          page.classList.remove('media-player-active');
          this.pushChanges();
        }
      } // console.log('MediaPlayerComponent.MediaLoader.events$', event);

    }));
  }

  drag$() {
    const {
      node
    } = rxcomp.getContext(this);
    const track = node.querySelector('.track');
    let initialProgress;
    return DragService.observe$(track).pipe(operators.filter(_ => this.media), operators.tap(event => {
      if (event instanceof DragDownEvent) {
        const rect = track.getBoundingClientRect();
        initialProgress = Math.max(0, Math.min(1, (event.down.x - rect.left) / rect.width));
        this.dragging = true;
      } else if (event instanceof DragMoveEvent) {
        const rect = track.getBoundingClientRect();
        const progress = Math.max(0, Math.min(1, initialProgress + event.distance.x / rect.width));
        this.progress = progress;
        this.pushChanges();
      } else if (event instanceof DragUpEvent) {
        this.media.progress = this.progress;
        this.dragging = false;
      }
    }));
  }

  onPlay() {
    this.media.play();
  }

  onPause() {
    this.media.pause();
  }

  onTrack(event) {
    const rect = event.currentTarget.getBoundingClientRect();
    const progress = (event.screenX - rect.left) / rect.width;
    this.media.progress = progress; // console.log(rect.left, event.screenX);
  }

}
MediaPlayerComponent.meta = {
  selector: '[media-player]'
};// import * as THREE from 'three';
const PANEL_RADIUS$1 = PANORAMA_RADIUS - 0.01;
class ModelBannerComponent extends ModelComponent {
  get title() {
    return this.title_;
  }

  set title(title) {
    if (this.title_ !== title) {
      const init = this.title_ != null;
      this.title_ = title;

      if (!init) {
        this.createBanner();
      } else {
        this.updateBanner();
      }
    }
  }
  /*
  onInit() {
  	super.onInit();
  	// console.log('ModelBannerComponent.onInit', this.item);
  }
  
  onView() {
  	// console.log('ModelBannerComponent.onView', this.item);
  	if (this.viewed) {
  		return;
  	}
  	this.viewed = true;
  	// this.createBanner();
  }
  */


  onChanges() {
    // console.log('ModelBannerComponent.onChanges', this.item);
    this.title = this.item.title;
  }

  createBanner() {
    this.getCanvasTexture().then(result => {
      const texture = result.texture;
      const repeat = 24;
      texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
      texture.repeat.x = repeat;
      texture.encoding = THREE.sRGBEncoding;
      const aspect = result.width * repeat / result.height;
      const arc = Math.PI / 180 * 360;
      const width = PANEL_RADIUS$1 * arc;
      const height = width / aspect;
      const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS$1, PANEL_RADIUS$1, height, 80, 2, true, 0, arc);
      geometry.scale(-1, 1, 1);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0,
        toneMapped: false // side: THREE.DoubleSide,

      });
      const mesh = this.mesh;
      const banners = this.banners = new Array(1).fill(0).map(x => new THREE.Mesh(geometry, material));
      banners.forEach((banner, i) => {
        banner.rotation.y = Math.PI / 2 * i; // !!!
        // mesh.add(banner);
      });
      const from = {
        value: 0
      };
      gsap.to(from, {
        duration: 0.5,
        value: 1,
        delay: 0.0,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.opacity = from.value;
          material.needsUpdate = true;
        }
      });
      mesh.userData = {
        render: () => {
          mesh.rotation.y += Math.PI / 180 * 0.02; // texture.offset.x = (texture.offset.x - 0.01) % 1;

          material.needsUpdate = true;
        }
      };
    });
  }

  updateBanner() {
    this.getCanvasTexture().then(result => {// console.log('ModelBannerComponent.updateBanner', result);
    });
  }
  /*
  onViewBak() {
  	if (this.viewed) {
  		return;
  	}
  	this.viewed = true;
  	this.getCanvasTexture().then(result => {
  		const texture = result.texture;
  		const repeat = 3;
  		texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
  		texture.repeat.x = repeat;
  		texture.encoding = THREE.sRGBEncoding;
  		const aspect = (result.width * repeat) / result.height;
  		const arc = Math.PI / 180 * 45;
  		const width = PANEL_RADIUS * arc;
  		const height = width / aspect;
  		const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS, PANEL_RADIUS, height, 20, 2, true, 0, arc);
  		geometry.scale(-1, 1, 1);
  		const material = new THREE.MeshBasicMaterial({
  			map: texture,
  			transparent: true,
  			opacity: 0,
  			// side: THREE.DoubleSide,
  		});
  		const mesh = this.mesh;
  		const banners = this.banners = new Array(4).fill(0).map(x => new THREE.Mesh(geometry, material));
  		banners.forEach((banner, i) => {
  			banner.rotation.y = Math.PI / 2 * i;
  			mesh.add(banner);
  		});
  		const from = { value: 0 };
  		gsap.to(from, {
  			duration: 0.5,
  			value: 1,
  			delay: 0.0,
  			ease: Power2.easeInOut,
  			onUpdate: () => {
  				material.opacity = from.value;
  				material.needsUpdate = true;
  			}
  		});
  		mesh.userData = {
  			render: () => {
  				mesh.rotation.y += Math.PI / 180 * 0.2;
  				texture.offset.x = (texture.offset.x - 0.01) % 1;
  				material.needsUpdate = true;
  			}
  		};
  	});
  }
  */


  onCreate(mount, dismount) {
    const mesh = new THREE.Group();

    if (typeof mount === 'function') {
      mount(mesh);
    }
  }

  getCanvasTexture() {
    return new Promise((resolve, reject) => {
      const MIN_W = 512;
      let W = MIN_W;
      let H = 128;
      const F = Math.floor(H * 0.8);
      const L = Math.floor(H * 0.075);
      let canvas;

      if (this.canvas) {
        canvas = this.canvas;
      } else {
        canvas = this.canvas = document.createElement('canvas'); // canvas.classList.add('canvas--debug');
        // document.querySelector('body').appendChild(canvas);
      }

      canvas.width = W;
      canvas.height = H;
      const text = this.item.title;
      const ctx = canvas.getContext('2d'); // const ctx = text.material.map.image.getContext('2d');

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `${F}px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      W = metrics.width + 8;
      W = Math.max(MIN_W, Math.pow(2, Math.ceil(Math.log(W) / Math.log(2)))); // const x = W / 2;
      // const y = 16;

      canvas.width = W;
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#0000005A'; // 35% // '#000000C0'; // 75%

      ctx.fillRect(0, 0, W, H);
      ctx.font = `${F}px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.lineWidth = L;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!

      ctx.miterLimit = 2;
      ctx.strokeText(text, W / 2, H / 2);
      ctx.fillStyle = 'white';
      ctx.fillText(text, W / 2, H / 2, W); // text.material.map.needsUpdate = true;

      let texture;

      if (this.texture) {
        texture = this.texture;
        texture.needsUpdate = true;
      } else {
        texture = this.texture = new THREE.CanvasTexture(canvas);
      } // console.log(F, L, W, H);


      resolve({
        texture: texture,
        width: W,
        height: H
      });
    });
  }
  /*
  getCanvasTexture_() {
  	return new Promise((resolve, reject) => {
  		if (this.item.bannerTexture) {
  			resolve(this.item.bannerTexture);
  		} else {
  			const { node } = getContext(this);
  			setTimeout(() => {
  				html2canvas(node, {
  					backgroundColor: '#00000000', // '#000000ff',
  					scale: 2,
  				}).then(canvas => {
  					// !!!
  					// document.body.appendChild(canvas);
  					// const alpha = this.getAlphaFromCanvas(canvas);
  					// document.body.appendChild(alpha);
  					const texture = new THREE.CanvasTexture(canvas);
  					// const alphaMap = new THREE.CanvasTexture(alpha);
  					this.item.bannerTexture = {
  						texture: texture,
  						width: canvas.width,
  						height: canvas.height,
  					};
  					resolve(this.item.bannerTexture);
  				}, error => {
  					reject(error);
  				});
  			}, 1);
  		}
  	});
  }
  */


}
ModelBannerComponent.meta = {
  selector: '[model-banner]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};class ModelCurvedPlaneComponent extends ModelEditableComponent {
  onInit() {
    super.onInit(); // console.log('ModelCurvedPlaneComponent.onInit');
  }

  onChanges() {
    const selected = this.item.selected;
    this.editing = selected;

    if (this.mesh) {
      this.mesh.editing = selected;
    }
  }

  onCreate(mount, dismount) {
    const item = this.item;
    const view = this.view;
    view.items;
    const geometry = this.getCurvedPanelGeometry(item);
    this.onMeshDown = this.onMeshDown.bind(this);
    this.onMeshPlaying = this.onMeshPlaying.bind(this);
    this.onMeshZoomed = this.onMeshZoomed.bind(this);
    this.onMeshCurrentTime = this.onMeshCurrentTime.bind(this);
    let mesh;
    let subscription;
    MediaMesh.getStreamId$(item).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(streamId => {
      if (this.streamId !== streamId) {
        this.streamId = streamId; // !!! called by ModelComponent

        /*
        if (mesh) {
        	dismount(mesh, item);
        }
        */

        if (subscription) {
          subscription.unsubscribe();
          subscription = null;
        } // console.log('ModelCurvedPanel', streamId, item.asset)


        if (streamId || !item.asset) {
          item.streamId = streamId;
          mesh = this.disposableMesh = new MediaMesh(item, view, geometry, this.host);
          mesh.updateFromItem(item);
          mesh.name = 'curved-plane';
          mesh.load(() => {
            this.disposableMesh = null;

            if (typeof mount === 'function') {
              mount(mesh, item);
            }

            subscription = mesh.events$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(() => {});
          });
          this.addMeshListeners(mesh);
        } else if (this.mesh) {
          dismount(this.mesh, item);
        } // console.log('streamId', streamId, mesh);

      }
    });
  }

  addMeshListeners(mesh) {
    mesh.on('down', this.onMeshDown);
    mesh.on('playing', this.onMeshPlaying);
    mesh.on('zoomed', this.onMeshZoomed);
    mesh.on('currentTime', this.onMeshCurrentTime);
  }

  removeMeshListeners(mesh) {
    mesh.off('down', this.onMeshDown);
    mesh.off('playing', this.onMeshPlaying);
    mesh.off('zoomed', this.onMeshZoomed);
    mesh.off('currentTime', this.onMeshCurrentTime);
  }

  onMeshDown() {
    // console.log('ModelCurvedPanelComponent.onMeshDown');
    this.down.next(this);
  }

  onMeshPlaying(playing) {
    // console.log('ModelCurvedPanelComponent.playing', playing);
    this.play.next({
      itemId: this.item.id,
      playing
    });
  }

  onMeshZoomed(zoomed) {
    // console.log('ModelCurvedPanelComponent.zoomed', zoomed);
    this.zoom.next({
      itemId: this.item.id,
      zoomed
    });
  }

  onMeshCurrentTime(currentTime) {
    // console.log('ModelCurvedPanelComponent.playing', playing);
    this.currentTime.next({
      itemId: this.item.id,
      currentTime
    });
  }

  onDestroy() {
    // console.log('ModelCurvedPlaneComponent.onDestroy');
    super.onDestroy();

    if (this.disposableMesh) {
      this.removeMeshListeners(this.disposableMesh);
      this.disposableMesh.dispose();
    }

    if (this.mesh) {
      this.removeMeshListeners(this.mesh);
      this.mesh.dispose();
    }
  } // called by UpdateViewItemComponent


  onUpdate(item, mesh) {
    // console.log('ModelCurvedPlaneComponent.onUpdate', item);
    // !!! true
    if ((item.radius !== this.radius_ || item.height !== this.height_ || item.arc !== this.arc_)) {
      mesh.geometry.dispose();
      const geometry = this.getCurvedPanelGeometry(item);
      mesh.geometry = geometry;
    }

    mesh.updateFromItem(item);
    this.updateHelper();
  } // called by UpdateViewItemComponent


  onUpdateAsset(item, mesh) {
    // console.log('ModelCurvedPlaneComponent.onUpdateAsset', item);
    mesh.updateByItem(item);
    MediaMesh.getStreamId$(item).pipe(operators.filter(streamId => streamId !== null), operators.take(1)).subscribe(streamId => {
      item.streamId = streamId;
      mesh.load(() => {// console.log('ModelCurvedPlaneComponent.mesh.load.complete');
      });
    });
  } // called by WorldComponent


  onDragMove(position, normal, spherical) {
    // console.log('ModelCurvedPlaneComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    item.showPanel = false;
    this.editing = true;
    mesh.position.set(position.x, position.y, position.z);

    if (spherical) {
      position.normalize().multiplyScalar(20);
      mesh.lookAt(Host.origin);
    } else {
      mesh.position.set(0, 0, 0);
      mesh.lookAt(normal);
      mesh.position.set(position.x, position.y, position.z);
      mesh.position.add(normal.multiplyScalar(0.01));
    }

    this.updateHelper();
  } // called by WorldComponent


  onDragEnd() {
    const item = this.item;
    const mesh = this.mesh;
    item.position = mesh.position.toArray();
    item.rotation = mesh.rotation.toArray();
    item.scale = mesh.scale.toArray();
    mesh.updateFromItem(item);
    this.editing = false;
  }

  getCurvedPanelGeometry(item) {
    this.radius_ = item.radius;
    this.height_ = item.height;
    this.arc_ = item.arc;
    const arc = Math.PI / 180 * item.arc;
    const geometry = new THREE.CylinderBufferGeometry(item.radius, item.radius, item.height, 36, 2, true, 0, arc);
    geometry.rotateY(-Math.PI - arc / 2);
    geometry.scale(-1, 1, 1);
    return geometry;
  }

}
ModelCurvedPlaneComponent.textures = {};
ModelCurvedPlaneComponent.meta = {
  selector: '[model-curved-plane]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play', 'zoom', 'currentTime'],
  inputs: ['item', 'view']
};class DebugService {
  static getService() {
    if (!this.service_) {
      this.service_ = new DebugService();
    }

    return this.service_;
  }

  get message() {
    return this.message$.getValue();
  }

  constructor() {
    if (DebugService.service_) {
      throw 'DebugService is a singleton class!';
    }

    this.message$ = new rxjs.BehaviorSubject(null);
  }

  setMessage(message) {
    if (this.message !== message) {
      this.message$.next(message);
    }
  }

}class ModelDebugComponent extends ModelComponent {
  static getLoader() {
    return ModelDebugComponent.loader || (ModelDebugComponent.loader = new THREE.FontLoader());
  }

  static getFontLoader(callback) {
    return ModelDebugComponent.fontLoader || (ModelDebugComponent.fontLoader = ModelDebugComponent.getLoader().load(environment.getPath('fonts/helvetiker/helvetiker_regular.typeface.json'), callback));
  }

  get message() {
    return this.message_;
  }

  set message(message) {
    message = message && message !== '' ? message : null;

    if (this.message_ !== message) {
      this.message_ = message; // console.log('ModelDebugComponent.set.message', message);

      this.setText(message);
      /*
      if (this.font) {
      	this.setText(message);
      }
      */
    }
  }

  onInit() {
    super.onInit(); // console.log('ModelDebugComponent.onInit');
    // this.loadFont();

    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => {
      if (session) {
        if (this.text) {
          this.textGroup.add(this.text);
        }
      } else {
        if (this.text) {
          this.text.parent.remove(this.text);
        }
      }
    });
    const debugService = this.debugService = DebugService.getService();
    debugService.message$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => this.message = message);
  }

  createText() {
    const canvas = document.createElement('canvas'); // document.querySelector('body').appendChild(canvas);

    canvas.width = ModelDebugComponent.W;
    canvas.height = ModelDebugComponent.H;
    const texture = new THREE.CanvasTexture(canvas);
    texture.encoding = THREE.sRGBEncoding;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping;
    texture.needsUpdate = true;
    const geometry = new THREE.PlaneBufferGeometry(4, 1, 2, 2);
    const material = new THREE.MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      map: texture,
      color: 0xffffff,
      // 0x33c5f6,
      transparent: true,
      opacity: 1,
      toneMapped: false // blending: THREE.AdditiveBlending,
      // side: THREE.DoubleSide

    });
    const text = new THREE.Mesh(geometry, material);
    text.renderOrder = environment.renderOrder.debug;
    text.position.y = 0;
    return text;
  }

  loadFont() {
    this.fontLoader = ModelDebugComponent.getFontLoader(font => {
      this.font = font;

      if (this.message_) {
        this.setText(this.message_);
      }
    });
  }

  onCreate(mount, dismount) {
    const textGroup = this.textGroup = new THREE.Group();
    this.material = new THREE.MeshBasicMaterial({
      depthTest: false,
      color: 0xffffff,
      // 0x33c5f6,
      transparent: true,
      opacity: 1,
      side: THREE.DoubleSide
    });
    this.text = this.createText();

    if (typeof mount === 'function') {
      mount(textGroup);
    }
  } // onView() { const context = getContext(this); }
  // onChanges() {}


  render(time, tick) {
    const group = this.group;
    let camera = this.host.camera;
    const position = this.position;

    if (this.host.renderer.xr.isPresenting) {
      camera = this.host.renderer.xr.getCamera(camera); // camera.updateMatrixWorld(); // make sure the camera matrix is updated
      // camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }

    camera.getWorldDirection(position); // console.log(position);
    // if (position.lengthSq() > 0.01) {
    // normalize so we can get a constant speed
    // position.normalize();

    position.multiplyScalar(3); // move body, not the camera
    // VR.body.position.add(lookDirection);
    // console.log(position.x + '|' + position.y + '|' + position.z);

    group.position.copy(position);
    group.lookAt(Host.origin); // }
  }

  setText(message) {
    const text = this.text;

    if (text) {
      if (this.host.renderer.xr.isPresenting && message != null) {
        // draw
        const ctx = text.material.map.image.getContext('2d');
        ctx.clearRect(0, 0, ModelDebugComponent.W, ModelDebugComponent.H); // ctx.fillRect(0, 0, 10, 10);
        // ctx.fillRect(ModelDebugComponent.W - 10, ModelDebugComponent.H - 10, 10, 10);

        ctx.font = `30px ${environment.fontFamily}`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 5;
        ctx.fillText(message, ModelDebugComponent.W / 2, ModelDebugComponent.H / 2, ModelDebugComponent.W - 20);
        text.material.map.needsUpdate = true; // draw

        this.textGroup.add(text);
      } else if (text.parent) {
        text.parent.remove(text);
      }
    }
  }

}
ModelDebugComponent.W = 1024;
ModelDebugComponent.H = 256;
ModelDebugComponent.meta = {
  selector: '[model-debug]',
  hosts: {
    host: WorldComponent
  }
};const VERTEX_SHADER = `
varying vec2 vUv;
void main() {
	vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
const FRAGMENT_SHADER = `
varying vec2 vUv;
uniform sampler2D textureA;
uniform sampler2D textureB;
uniform float opacity;
uniform float tween;

void main() {
	vec4 colorA = texture2D(textureA, vUv);
	vec4 colorB = texture2D(textureB, vUv);
	vec4 color = mix(colorA, colorB, tween);
	color.a = clamp(color.a * opacity, 0.0, 1.0);
	color.rgb /= color.a;
	gl_FragColor = color;
}
`;
class ModelGridComponent extends ModelComponent {
  static getLoader() {
    return ModelGridComponent.loader || (ModelGridComponent.loader = new THREE.TextureLoader());
  }

  static getTexture() {
    return ModelGridComponent.texture || (ModelGridComponent.texture = ModelGridComponent.getLoader().load(environment.getPath('textures/ui/floor-nav.png')));
  }

  static getOverTexture() {
    return ModelGridComponent.textureOver || (ModelGridComponent.textureOver = ModelGridComponent.getLoader().load(environment.getPath('textures/ui/floor-nav-over.png')));
  }

  set coords(coords) {
    if (!coords && this.coords_ !== coords || !this.coords_ || coords.x !== this.coords_.x || coords.y !== this.coords_.y) {
      // changed!
      const tileMap = this.tileMap;

      if (this.coords_) {
        const previousTile = tileMap[`${this.coords_.x}_${this.coords_.y}`];
        const previousUniforms = previousTile.uniforms;
        gsap.to(previousUniforms, {
          tween: 0,
          duration: 0.4,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            previousTile.material.uniforms.tween.value = previousUniforms.tween;
            previousTile.material.needsUpdate = true;
          }
        });
      }

      if (coords) {
        const currentTile = this.currentTile = tileMap[`${coords.x}_${coords.y}`];
        const currentUniforms = currentTile.uniforms;
        gsap.to(currentUniforms, {
          tween: 1,
          duration: 0.4,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            currentTile.material.uniforms.tween.value = currentUniforms.tween;
            currentTile.material.needsUpdate = true;
          }
        }); // console.log(currentTile, `${coords.x}_${coords.y}`);
      }

      this.coords_ = coords;
    }
  }

  set coords__(coords) {
    if (!coords && this.coords_ !== coords || !this.coords_ || coords.x !== this.coords_.x || coords.y !== this.coords_.y) {
      // changed!
      const tileMap = this.tileMap;

      if (this.coords_) {
        const previousTile = tileMap[`${this.coords_.x}_${this.coords_.y}`];
        const from = {
          tween: 1
        };
        gsap.to(from, {
          duration: 0.4,
          tween: 0,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            previousTile.material.opacity = from.tween; // previousTile.material.needsUpdate = true;
          }
        });
      }

      if (coords) {
        const currentTile = this.currentTile = tileMap[`${coords.x}_${coords.y}`];
        const from = {
          tween: 0
        };
        gsap.to(from, {
          duration: 0.4,
          tween: 1,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            currentTile.material.opacity = from.tween; // currentTile.material.needsUpdate = true;
          }
        }); // console.log(currentTile, `${coords.x}_${coords.y}`);
      }

      this.coords_ = coords;
    }
  }

  getCoords(point) {
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m

    const col = Math.ceil((point.x + outerTileSize / 2) / outerTileSize) - 1;
    const row = Math.ceil((point.z + outerTileSize / 2) / outerTileSize) - 1;
    const dx = Math.floor(ModelGridComponent.COLS / 2);
    const dy = Math.floor(ModelGridComponent.ROWS / 2);
    const ci = Math.min(dx, Math.abs(col)) * (col ? Math.abs(col) / col : 1);
    const ri = Math.min(dy, Math.abs(row)) * (row ? Math.abs(row) / row : 1);

    if (this.view.hasTile(this.indices.x + ci, this.indices.y + ri)) {
      // console.log('col', col, 'row', row, 'ci', ci, 'ri', ri);
      return new THREE.Vector2(ci, ri);
    }
  }

  onInit() {
    super.onInit();
    this.indices = new THREE.Vector2(); // console.log('ModelGridComponent.onInit', this.view);

    this.view.index$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(index => {
      this.moveToIndex(index);
    });
  }

  addTiles(mesh) {
    // console.log('addTiles');
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m

    const innerTileSize = outerTileSize * 0.9;
    const geometry = new THREE.PlaneBufferGeometry(innerTileSize, innerTileSize, 2, 2);
    geometry.rotateX(-Math.PI / 2);
    const map = ModelGridComponent.getTexture();
    map.disposable = false;
    map.encoding = THREE.sRGBEncoding;
    const mapOver = ModelGridComponent.getOverTexture();
    mapOver.disposable = false;
    mapOver.encoding = THREE.sRGBEncoding; // geometry.scale(-1, 1, 1);

    const tileMap = this.tileMap = {};
    this.tiles = new Array(ModelGridComponent.COLS * ModelGridComponent.ROWS).fill(0).map((x, i) => {
      const material = new THREE.ShaderMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        toneMapped: false,
        vertexShader: VERTEX_SHADER,
        fragmentShader: FRAGMENT_SHADER,
        uniforms: {
          textureA: {
            type: 't',
            value: map
          },
          textureB: {
            type: 't',
            value: mapOver
          },
          tween: {
            value: 0
          },
          opacity: {
            value: 0
          }
        },
        extensions: {
          fragDepth: true
        } // side: THREE.DoubleSide

      });
      /*
      const material = new THREE.MeshBasicMaterial({
      	depthTest: false,
      	depthWrite: false,
      	map: map,
      	transparent: true,
      	opacity: 0,
      	// side: THREE.DoubleSide,
      });
      */

      const tile = new THREE.Mesh(geometry, material);
      const dx = Math.floor(ModelGridComponent.COLS / 2);
      const dy = Math.floor(ModelGridComponent.ROWS / 2);
      const row = Math.floor(i / ModelGridComponent.COLS);
      const col = i % ModelGridComponent.COLS;
      const ci = -dx + col;
      const ri = -dy + row; // console.log(ci, ri);

      tile.position.set(ci * outerTileSize, -ModelGridComponent.RADIUS * 0.15, ri * outerTileSize);
      tile.name = this.getName(`tile_${ci}_${ri}`);
      tile.uniforms = {
        tween: 0,
        opacity: 0,
        ci: ci,
        ri: ri
      };
      tileMap[`${ci}_${ri}`] = tile;
      mesh.add(tile);
      return tile;
    });
    this.showTiles();
  }

  showTiles() {
    this.tiles.forEach((tile, i) => {
      const ix = this.indices ? this.indices.x : 0;
      const iy = this.indices ? this.indices.y : 0;
      const visible = this.view.hasTile(ix + tile.uniforms.ci, iy + tile.uniforms.ri);
      const uniforms = tile.uniforms;
      gsap.to(uniforms, {
        opacity: visible ? 1 : 0,
        duration: 0.4,
        // delay: 0 + i * 0.02,
        ease: Power2.easeInOut,
        onUpdate: () => {
          tile.material.uniforms.opacity.value = uniforms.opacity;
          tile.material.needsUpdate = true;
        }
      });
    });
  }

  addHitArea(mesh) {
    this.onGroundOver = this.onGroundOver.bind(this);
    this.onGroundMove = this.onGroundMove.bind(this);
    this.onGroundDown = this.onGroundDown.bind(this);
    this.onGroundOut = this.onGroundOut.bind(this);
    ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    const geometry = new THREE.PlaneBufferGeometry(ModelGridComponent.RADIUS, ModelGridComponent.RADIUS, 8, 8); // 20, 20

    geometry.rotateX(-Math.PI / 2); // geometry.scale(-1, 1, 1);

    const material = new THREE.MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      toneMapped: false,
      opacity: 0 // side: THREE.DoubleSide,

    });
    const ground = this.ground = new InteractiveMesh(geometry, material);
    ground.name = this.getName('ground');
    ground.position.set(0, -ModelGridComponent.RADIUS * 0.15, 0);
    ground.on('over', this.onGroundOver);
    ground.on('move', this.onGroundMove);
    ground.on('out', this.onGroundOut);
    ground.on('down', this.onGroundDown);
    mesh.add(ground);
  }

  onGroundOver() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;
  }

  onGroundMove() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;
  }

  onGroundDown() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;

    if (coords) {
      const index = this.view.getTileIndex(this.indices.x + coords.x, this.indices.y + coords.y);
      this.view.index = index;
      this.nav.next(index);
      /*
      this.indices.x += coords.x;
      this.indices.y += coords.y;
      const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
      this.move.next({
      	indices: this.indices,
      	coords,
      	position: coords.clone().multiplyScalar(outerTileSize)
      });
      */
    }
  }

  onGroundOut() {
    this.coords = null;
  }

  moveToIndex(index) {
    // console.log('ModelGridComponent.moveToIndex', index);
    this.coords = null;
    const tile = this.view.tiles[index];
    const coords = new THREE.Vector2(tile.indices.x - this.indices.x, tile.indices.y - this.indices.y);
    this.indices.x = tile.indices.x;
    this.indices.y = tile.indices.y;
    this.showTiles();
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m

    this.move.next({
      indices: this.indices,
      coords,
      position: coords.clone().multiplyScalar(outerTileSize)
    });
  }

  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.tile;
    const mesh = new THREE.Group();
    this.addTiles(mesh);
    this.addHitArea(mesh);
    /*
    mesh.userData = {
    	render: () => {
    			}
    };
    */

    if (typeof mount === 'function') {
      mount(mesh);
    }
  }

  onDestroy() {
    super.onDestroy();
    const ground = this.ground;
    ground.off('over', this.onGroundOver);
    ground.off('move', this.onGroundMove);
    ground.off('down', this.onGroundDown);
    ground.off('out', this.onGroundOut);
  }

}
ModelGridComponent.RADIUS = 101;
ModelGridComponent.COLS = 11;
ModelGridComponent.ROWS = 11;
ModelGridComponent.meta = {
  selector: '[model-grid]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['move', 'nav'],
  inputs: ['view']
};class MenuButton extends InteractiveMesh {
  static getGrid(total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const rows = Math.ceil(total / cols);
    return [rows, cols];
  }

  static getX(index, total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const c = index % cols;
    const w = 1 / MenuButton.W * (MenuButton.W + MenuButton.G);
    return w / 2 - cols * w / 2 + c * w;
  }

  static getY(index, total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const rows = Math.ceil(total / cols);
    const r = Math.floor(index / cols);
    const h = 1 / MenuButton.W * (MenuButton.H + MenuButton.G);
    return rows * h / 2 - h / 2 + r * -h; // y flipped
  }

  static get geometry() {
    if (this.geometry_) {
      return this.geometry_;
    }

    const geometry = new THREE.PlaneBufferGeometry(1, 1 / MenuButton.W * MenuButton.H, 2, 2);
    this.geometry_ = geometry;
    return geometry;
  }

  static get material() {
    const material = new THREE.ShaderMaterial({
      depthTest: false,
      transparent: true,
      toneMapped: false,
      vertexShader: ModelMenuComponent.VERTEX_SHADER,
      fragmentShader: ModelMenuComponent.FRAGMENT_SHADER,
      uniforms: {
        textureA: {
          type: 't',
          value: null
        },
        textureB: {
          type: 't',
          value: null
        },
        resolutionA: {
          value: new THREE.Vector2()
        },
        resolutionB: {
          value: new THREE.Vector2()
        },
        tween: {
          value: 0
        },
        opacity: {
          value: 0
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    /*
    const material = new THREE.MeshBasicMaterial({
    	// depthTest: false,
    	transparent: true,
    	opacity: 0.8,
    	// side: THREE.DoubleSide,
    });
    */

    return material;
  }

  constructor(item, index, total) {
    const geometry = MenuButton.geometry;
    const material = MenuButton.material;
    super(geometry, material); // this.userData.item = item;
    // this.userData.index = index;

    this.renderOrder = environment.renderOrder.menu;
    this.name = item.name;
    this.item = item;
    this.index = index;
    this.total = total;
    this.tween = 0;
    this.opacity = 0;
    const textureA = this.textureA = this.getTextureA(item.name); // material.map = textureA;

    material.uniforms.textureA.value = textureA;
    material.uniforms.resolutionA.value = new THREE.Vector2(textureA.width, textureA.height);
    const textureB = this.textureB = this.getTextureB(item.name); // material.map = textureB;

    material.uniforms.textureB.value = textureB;
    material.uniforms.resolutionA.value = new THREE.Vector2(textureB.width, textureB.height);
    material.uniforms.tween.value = this.tween;
    material.uniforms.opacity.value = this.opacity;
    material.needsUpdate = true;
    this.position.set(MenuButton.getX(index, total), MenuButton.getY(index, total), 0);
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
  }

  getTextureA(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuForeground;
    this.writeText(ctx, text, w, h);
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping; // texture.encoding = THREE.sRGBEncoding;

    texture.needsUpdate = true;
    return texture;
  }

  getTextureB(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuOverBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuOverForeground;
    this.writeText(ctx, text, w, h);
    const texture = new THREE.CanvasTexture(canvas); // texture.encoding = THREE.sRGBEncoding;

    texture.magFilter = THREE.LinearFilter;
    texture.needsUpdate = true;
    return texture;
  }

  writeText(ctx, text, w, h) {
    this.setFont(ctx);
    const lineHeight = MenuButton.FONT_SIZE * MenuButton.LINE_HEIGHT;
    const lines = this.getLines(ctx, text, w);
    const lineCount = lines.length;
    this.setFont(ctx, lineCount - 1);
    lines.forEach((line, i) => {
      ctx.fillText(line, 10, (h - lineCount * lineHeight) * 0.5 + (0.5 + i) * lineHeight, w - 20);
    });
  }

  setFont(ctx, diff) {
    if (diff === void 0) {
      diff = 0;
    }

    ctx.textBaseline = 'middle';
    ctx.font = `${MenuButton.FONT_SIZE - diff * 2}px ${environment.fontFamily}`;
  }

  getLines(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = words[0];

    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      const width = ctx.measureText(currentLine + ' ' + word).width;

      if (width < maxWidth) {
        currentLine += ' ' + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }

    lines.push(currentLine);
    return lines;
  }

  onOver() {
    // DebugService.getService().setMessage('over ' + this.name);
    gsap.to(this, {
      duration: 0.4,
      tween: 1,
      ease: Power2.easeOut,
      onUpdate: () => {
        this.position.z = 0.1 * this.tween;
        this.material.uniforms.tween.value = this.tween;
        this.material.needsUpdate = true;
      }
    });
  }

  onOut() {
    gsap.to(this, {
      duration: 0.4,
      tween: 0,
      ease: Power2.easeOut,
      onUpdate: () => {
        this.position.z = 0.1 * this.tween;
        this.material.uniforms.tween.value = this.tween;
        this.material.needsUpdate = true;
      }
    });
  }

  dispose() {
    Interactive.dispose(this);
    this.textureA.dispose();
    this.textureB.dispose();
    this.material.dispose();
    this.geometry.dispose();
  }

}
MenuButton.FONT_SIZE = 19; // 20

MenuButton.LINE_HEIGHT = 0.9;
MenuButton.W = 256;
MenuButton.H = 64;
MenuButton.G = 2;
MenuButton.ROWS = 6;
class BackButton extends MenuButton {
  constructor(item, index, total) {
    super(item, index, total);
  }

  getTextureA(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuBackForeground;
    ctx.font = `${MenuButton.FONT_SIZE}px ${environment.fontFamily}`;
    ctx.fillText(text, 10, 50, w - 20);
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping;
    texture.needsUpdate = true;
    return texture;
  }

  getTextureB(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackOverBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuBackOverForeground;
    ctx.font = `${MenuButton.FONT_SIZE}px ${environment.fontFamily}`;
    ctx.fillText(text, 10, 50, w - 20);
    const texture = new THREE.CanvasTexture(canvas); // texture.encoding = THREE.sRGBEncoding;

    texture.magFilter = THREE.LinearFilter;
    texture.needsUpdate = true;
    return texture;
  }

}
class ModelMenuComponent extends ModelComponent {
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }

  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }

  get silencing() {
    return StateService.state.silencing;
  }

  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }

  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }

  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }

  get locked() {
    return this.controlled || this.spying;
  }

  get loading() {
    return this.loading_;
  }

  set loading(loading) {
    // console.log('loading', loading);
    if (this.loading_ !== loading) {
      this.loading_ = loading;
      const {
        node
      } = rxcomp.getContext(this);
      const btn = node.querySelector('.btn--menu');
      btn.classList.toggle('loading', loading);
    }
  }

  onInit() {
    super.onInit();
    this.onDown = this.onDown.bind(this);
    this.onToggle = this.onToggle.bind(this); // console.log('ModelMenuComponent.onInit');

    /*
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(
    	takeUntil(this.unsubscribe$),
    ).subscribe((session) => {
    	if (session) {
    		this.addToggler();
    	} else {
    		this.removeMenu();
    	}
    });
    */

    const {
      node
    } = rxcomp.getContext(this);
    this.progressIndicator = node.querySelector('.progress circle');
    LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
      this.loading = progress.count > 0;
      let strokeDashoffset = 144.51;

      if (progress.count) {
        strokeDashoffset = 144.51 * (1 - progress.value);
      }

      gsap.set(this.progressIndicator, {
        'strokeDashoffset': strokeDashoffset
      });
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // DebugService.getService().setMessage('ModelMenuComponent.MessageService ' + message.type);
      switch (message.type) {
        case MessageType.MenuToggle:
          this.onToggle();
          break;
      }
    });
  }
  /*
  buildMenu() {
  	if (!this.views) {
  		return;
  	}
  	MenuService.getModelMenu$(this.views, this.host.editor).pipe(
  		first(),
  	).subscribe(menu => this.groups = menu);
  }
  */


  onDestroy() {
    if (this.buttons) {
      this.buttons.forEach(x => Interactive.dispose(x));
    }

    super.onDestroy();
  }

  getContainer() {
    return this.host.cameraGroup;
  }

  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.menu;
    const menuGroup = this.menuGroup = new THREE.Group();

    if (typeof mount === 'function') {
      mount(menuGroup);
    }
  }

  render(time, tick) {
    const group = this.group;
    this.host.cameraGroup;
    let camera = this.host.camera;
    const position = this.position;

    if (this.host.renderer.xr.isPresenting) {
      camera = this.host.renderer.xr.getCamera(camera);
      camera.getWorldDirection(position);
      position.y += 0.5;
      position.multiplyScalar(3);
      this.host.cameraGroup.worldToLocal(position);
      position.y += this.host.cameraGroup.position.y;
      group.position.copy(position);
      group.scale.set(1, 1, 1);
      group.lookAt(Host.origin);
    } else {
      camera.getWorldDirection(position);

      if (OrbitService.mode === OrbitMode.Model) {
        position.multiplyScalar(0.01);
      } else {
        position.multiplyScalar(3);
      }

      group.position.copy(position);
      const s = 1 / camera.zoom;
      group.scale.set(s, s, s);
      group.lookAt(Host.origin);
    }
  }

  items$(item) {
    if (item === void 0) {
      item = null;
    }

    if (item) {
      return rxjs.of(item.items);
    } else if (this.rootItems) {
      return rxjs.of(this.rootItems);
    } else {
      return MenuService.getModelMenu$(this.views, this.host.editor).pipe(operators.first(), operators.tap(items => {
        if (!this.host.editor) {
          this.rootItems = items;
        }
      }));
    }
  }

  addMenu(item) {
    if (item === void 0) {
      item = null;
    }

    this.removeMenu(); // nav to view

    if (item && item.type.name !== 'menu-group') {
      /*
      if (this.host.renderer.xr.isPresenting) {
      	this.addToggler();
      }
      */
      this.nav.next(item);
      return;
    }

    MenuService.active = true;
    this.items$(item).pipe(operators.first()).subscribe(items => {
      if (items) {
        items = items.slice();
        const back = {
          type: {
            name: 'back'
          },
          name: item ? 'Back' : 'Close',
          backItem: item
        };
        items.push(back);
        const buttons = this.buttons = items.map((x, i, a) => {
          x.backItem = item;
          return x.type.name === 'back' ? new BackButton(x, i, a.length) : new MenuButton(x, i, a.length);
        });
        buttons.forEach(button => {
          button.depthTest = false;
          button.on('over', button.onOver);
          button.on('out', button.onOut);
          button.on('down', this.onDown);
          this.menuGroup.add(button);
          /*
          var box = new THREE.BoxHelper(button, 0xffff00);
          this.host.scene.add(box);
          */
        });
        gsap.to(buttons, {
          duration: 0.3,
          opacity: 0.8,
          ease: Power2.easeOut,
          stagger: {
            grid: MenuButton.getGrid(buttons.length),
            from: 0,
            // index
            amount: 0.02 * buttons.length
          },
          onUpdate: () => {
            buttons.forEach(button => {
              button.material.uniforms.opacity.value = button.opacity * (button.item.hidden ? 0.5 : 1); // button.material.needsUpdate = true;
            });
          }
        });
      }
    });
  }

  removeMenu() {
    MenuService.active = false;
    this.removeButtons();
    this.removeToggler();
  }

  removeButtons() {
    const buttons = this.buttons;

    if (buttons) {
      buttons.forEach(button => {
        this.menuGroup.remove(button);
        button.off('over', button.onOver);
        button.off('out', button.onOut);
        button.off('down', this.onDown);
        button.dispose();
      });
    }

    this.buttons = null;
  }

  addToggler() {
    this.removeMenu();
    const toggler = this.toggler = new MenuButton({
      type: {
        name: 'menu'
      },
      name: 'Menu'
    }, 0, 1); // toggler.position.y = -0.5;

    toggler.opacity = 0.8;
    toggler.material.uniforms.opacity.value = toggler.opacity;
    toggler.material.needsUpdate = true;
    toggler.on('over', toggler.onOver);
    toggler.on('out', toggler.onOut);
    toggler.on('down', this.onToggle);
    this.menuGroup.add(toggler);
  }

  removeToggler() {
    const toggler = this.toggler;

    if (toggler) {
      this.menuGroup.remove(toggler);
      toggler.off('over', toggler.onOver);
      toggler.off('out', toggler.onOut);
      toggler.off('down', this.onToggle);
      toggler.dispose();
    }

    this.toggler = null;
  }

  onDown(button) {
    // this.down.next(this.item);
    if (button.item && button.item.type.name === 'back') {
      this.removeMenu();

      if (button.item.backItem) {
        this.addMenu(button.item.backItem.backItem);
      } else {
        /*
        if (this.host.renderer.xr.isPresenting) {
        	this.addToggler();
        }
        */
        this.toggle.next();
      }
    } else {
      this.addMenu(button.item);
    }
  }

  onToggle(event) {
    if (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    if (this.locked) {
      return;
    }

    if (MenuService.active) {
      this.removeMenu();
      this.toggle.next();
    } else {
      this.addMenu();
      this.toggle.next(this);
    }
  }

}
ModelMenuComponent.VERTEX_SHADER = `
varying vec2 vUv;
void main() {
	vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
ModelMenuComponent.FRAGMENT_SHADER = `
varying vec2 vUv;
uniform float opacity;
uniform float tween;
uniform sampler2D textureA;
uniform sampler2D textureB;
uniform vec2 resolutionA;
uniform vec2 resolutionB;

void main() {
	vec4 colorA = texture2D(textureA, vUv);
	vec4 colorB = texture2D(textureB, vUv);
	vec4 color = vec4(mix(colorA.rgb, colorB.rgb, tween), opacity);
	gl_FragColor = color;
}
`;
ModelMenuComponent.meta = {
  selector: '[model-menu]',
  hosts: {
    host: WorldComponent
  },
  // outputs: ['over', 'out', 'down', 'nav'],
  outputs: ['nav', 'toggle'],
  inputs: ['views'],
  template:
  /* html */
  `
	<div class="btn--menu" (mousedown)="onToggle($event)">
		<svg class="menu-light" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#menu-light"></use></svg>
		<div class="btn--menu__spinner"></div>
		<svg class="bullets" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#menu"></use></svg>
		<svg class="progress" width="50" height="50" viewBox="0 0 50 50">
			<circle id="circle" r="23" cx="25" cy="25" fill="transparent"></circle>
		</svg>
	</div>
	`
};const _taskCache = new WeakMap();

class DRACOLoader extends three.Loader {

	constructor( manager ) {

		super( manager );

		this.decoderPath = '';
		this.decoderConfig = {};
		this.decoderBinary = null;
		this.decoderPending = null;

		this.workerLimit = 4;
		this.workerPool = [];
		this.workerNextTaskID = 1;
		this.workerSourceURL = '';

		this.defaultAttributeIDs = {
			position: 'POSITION',
			normal: 'NORMAL',
			color: 'COLOR',
			uv: 'TEX_COORD'
		};
		this.defaultAttributeTypes = {
			position: 'Float32Array',
			normal: 'Float32Array',
			color: 'Float32Array',
			uv: 'Float32Array'
		};

	}

	setDecoderPath( path ) {

		this.decoderPath = path;

		return this;

	}

	setDecoderConfig( config ) {

		this.decoderConfig = config;

		return this;

	}

	setWorkerLimit( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new three.FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			const taskConfig = {
				attributeIDs: this.defaultAttributeIDs,
				attributeTypes: this.defaultAttributeTypes,
				useUniqueIDs: false
			};

			this.decodeGeometry( buffer, taskConfig )
				.then( onLoad )
				.catch( onError );

		}, onProgress, onError );

	}

	/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
	decodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {

		const taskConfig = {
			attributeIDs: attributeIDs || this.defaultAttributeIDs,
			attributeTypes: attributeTypes || this.defaultAttributeTypes,
			useUniqueIDs: !! attributeIDs
		};

		this.decodeGeometry( buffer, taskConfig ).then( callback );

	}

	decodeGeometry( buffer, taskConfig ) {

		// TODO: For backward-compatibility, support 'attributeTypes' objects containing
		// references (rather than names) to typed array constructors. These must be
		// serialized before sending them to the worker.
		for ( const attribute in taskConfig.attributeTypes ) {

			const type = taskConfig.attributeTypes[ attribute ];

			if ( type.BYTES_PER_ELEMENT !== undefined ) {

				taskConfig.attributeTypes[ attribute ] = type.name;

			}

		}

		//

		const taskKey = JSON.stringify( taskConfig );

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache.has( buffer ) ) {

			const cachedTask = _taskCache.get( buffer );

			if ( cachedTask.key === taskKey ) {

				return cachedTask.promise;

			} else if ( buffer.byteLength === 0 ) {

				// Technically, it would be possible to wait for the previous task to complete,
				// transfer the buffer back, and decode again with the second configuration. That
				// is complex, and I don't know of any reason to decode a Draco buffer twice in
				// different ways, so this is left unimplemented.
				throw new Error(

					'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
					'settings. Buffer has already been transferred.'

				);

			}

		}

		//

		let worker;
		const taskID = this.workerNextTaskID ++;
		const taskCost = buffer.byteLength;

		// Obtain a worker and assign a task, and construct a geometry instance
		// when the task completes.
		const geometryPending = this._getWorker( taskID, taskCost )
			.then( ( _worker ) => {

				worker = _worker;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.geometry ) );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		geometryPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					// this.debug();

				}

			} );

		// Cache the task result.
		_taskCache.set( buffer, {

			key: taskKey,
			promise: geometryPending

		} );

		return geometryPending;

	}

	_createGeometry( geometryData ) {

		const geometry = new three.BufferGeometry();

		if ( geometryData.index ) {

			geometry.setIndex( new three.BufferAttribute( geometryData.index.array, 1 ) );

		}

		for ( let i = 0; i < geometryData.attributes.length; i ++ ) {

			const attribute = geometryData.attributes[ i ];
			const name = attribute.name;
			const array = attribute.array;
			const itemSize = attribute.itemSize;

			geometry.setAttribute( name, new three.BufferAttribute( array, itemSize ) );

		}

		return geometry;

	}

	_loadLibrary( url, responseType ) {

		const loader = new three.FileLoader( this.manager );
		loader.setPath( this.decoderPath );
		loader.setResponseType( responseType );
		loader.setWithCredentials( this.withCredentials );

		return new Promise( ( resolve, reject ) => {

			loader.load( url, resolve, undefined, reject );

		} );

	}

	preload() {

		this._initDecoder();

		return this;

	}

	_initDecoder() {

		if ( this.decoderPending ) return this.decoderPending;

		const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
		const librariesPending = [];

		if ( useJS ) {

			librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

		} else {

			librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
			librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

		}

		this.decoderPending = Promise.all( librariesPending )
			.then( ( libraries ) => {

				const jsContent = libraries[ 0 ];

				if ( ! useJS ) {

					this.decoderConfig.wasmBinary = libraries[ 1 ];

				}

				const fn = DRACOWorker.toString();

				const body = [
					'/* draco decoder */',
					jsContent,
					'',
					'/* worker */',
					fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
				].join( '\n' );

				this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

			} );

		return this.decoderPending;

	}

	_getWorker( taskID, taskCost ) {

		return this._initDecoder().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				const worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

				worker.onmessage = function ( e ) {

					const message = e.data;

					switch ( message.type ) {

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? - 1 : 1;

				} );

			}

			const worker = this.workerPool[ this.workerPool.length - 1 ];
			worker._taskCosts[ taskID ] = taskCost;
			worker._taskLoad += taskCost;
			return worker;

		} );

	}

	_releaseTask( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	}

	debug() {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	}

	dispose() {

		for ( let i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		return this;

	}

}

/* WEB WORKER */

function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();
					const decoderBuffer = new draco.DecoderBuffer();
					decoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );

					try {

						const geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoderBuffer );
						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( decoderBuffer );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and `.drc` files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === - 1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			geometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}class ModelModelComponent extends ModelEditableComponent {
  get freezed() {
    return this.freezed_;
  }

  set freezed(freezed) {
    if (this.freezed_ !== freezed) {
      this.freezed_ = freezed;
      const mesh = this.mesh;

      if (mesh) {
        mesh.traverse(child => {
          if (child.isInteractiveMesh) {
            child.freezed = freezed;
          }
        });
      }
    }
  }

  onInit() {
    super.onInit();
    this.isPresenting = false;
    MenuService.active$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(active => this.freezed = active);
  }

  onChanges() {
    this.editing = this.item.selected;
  }

  onCreate(mount, dismount) {
    this.loadGlb(environment.getPath(this.item.asset.folder), this.item.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, mount, dismount);
    });
  }

  loadGlb(path, file, callback) {
    this.host.renderer; // const roughnessMipmapper = new RoughnessMipmapper(renderer); // optional

    const progressRef = LoaderService.getRef(); // console.log('progressRef');

    const loader = new GLTFLoader().setPath(path); // Optional: Provide a DRACOLoader instance to decode compressed mesh data

    const decoderPath = `${environment.dist}js/draco/`; // console.log(decoderPath);

    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(decoderPath);
    loader.setDRACOLoader(dracoLoader);
    loader.load(file, glb => {
      /*
      glb.scene.traverse((child) => {
      	if (child.isMesh) {
      		// roughnessMipmapper.generateMipmaps(child.material);
      	}
      });
      */
      if (typeof callback === 'function') {
        callback(glb.scene, glb.animations);
      }

      LoaderService.setProgress(progressRef, 1); // roughnessMipmapper.dispose();
    }, progressEvent => {
      LoaderService.setProgress(progressRef, progressEvent.loaded, progressEvent.total);
    });
  }

  onGlbLoaded(mesh, animations, mount, dismount) {
    // animations
    this.parseAnimations(mesh, animations); // scale

    const box = new THREE.Box3().setFromObject(mesh);
    const size = box.max.clone().sub(box.min);
    const max = Math.max(size.x, size.y, size.z);
    const scale = 1.7 / max;
    mesh.scale.set(scale, scale, scale); // repos

    let dummy;
    const view = this.view;
    const item = this.item;

    if (view.type.name === ViewType.Model.name) {
      // this.onUpdateVRSession(this.vrService.currentSession);
      dummy = new THREE.Group();
      dummy.add(mesh);
      box.setFromObject(dummy);
      const center = box.getCenter(new THREE.Vector3());
      dummy.position.set(mesh.position.x - center.x, mesh.position.y - center.y, mesh.position.z - center.z + (this.host.renderer.xr.isPresenting ? -2 : 0) // mesh.position.z - center.z,
      );
      const endY = dummy.position.y;
      const from = {
        tween: 1
      };

      const onUpdate = () => {
        dummy.position.y = endY + 3 * from.tween;
        dummy.rotation.y = 0 + Math.PI * from.tween;
      };

      onUpdate();
      this.makeInteractive(mesh);
      gsap.to(from, {
        duration: 1.5,
        tween: 0,
        delay: 0.1,
        ease: Power2.easeInOut,
        onUpdate: onUpdate,
        onComplete: () => {
          this.updateHelper();
        }
      });
    } else {
      box.setFromObject(mesh);
      const center = box.getCenter(new THREE.Vector3());
      mesh.position.set(-center.x, -center.y, -center.z);
      dummy = new THREE.Group();
      dummy.add(mesh);

      if (item.position) {
        dummy.position.fromArray(item.position);
      }

      if (item.rotation) {
        dummy.rotation.fromArray(item.rotation);
      }

      if (item.scale) {
        dummy.scale.fromArray(item.scale);
      }

      this.makeInteractive(mesh);
      /*
      const geometry = ModelModelComponent.getInteractiveGeometry();
      const sphere = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
      	depthTest: false,
      	depthWrite: false,
      	transparent: true,
      	// wireframe: true,
      	// opacity: 1.0,
      	opacity: 0.0,
      	color: 0x00ffff,
      }));
      const radius = max * scale / 1.7;
      sphere.scale.set(radius, radius, radius);
      sphere.name = `[model] ${this.item.id}`;
      // sphere.depthTest = false;
      sphere.renderOrder = 0;
      dummy.add(sphere);
      sphere.on('down', () => {
      	// console.log('ModelModelComponent.down');
      	this.down.next(this);
      });
      */

      this.updateHelper();
    }

    if (typeof mount === 'function') {
      mount(dummy, this.item);
      this.freezed = MenuService.active;
    }
  }

  parseAnimations(mesh, animations) {
    // animations
    // console.log('ModelModelComponent.onGlbLoaded', 'animations', animations);
    this.actionIndex = -1;
    const actions = this.actions = [];

    if (animations && animations.length) {
      this.clock = new THREE.Clock();
      const mixer = this.mixer = new THREE.AnimationMixer(mesh);
      mixer.timeScale = 1;
      animations.forEach(animation => {
        const action = mixer.clipAction(animation);
        action.enabled = true;
        action.setEffectiveTimeScale(1);
        action.setEffectiveWeight(1); // action.setLoop(THREE.LoopPingPong);

        action.setLoop(THREE.LoopRepeat); // action.clampWhenFinished = true; // pause on last frame

        actions.push(action);
      });
    }
  }

  onClipToggle() {
    let actionIndex;
    const actions = this.actions;

    if (actions.length === 1) {
      actionIndex = this.actionIndex === -1 ? 0 : -1;
      this.setSingleAction(actionIndex);
    } else if (actions.length > 1) {
      actionIndex = this.actionIndex + 1;

      if (actionIndex === actions.length) {
        actionIndex = -1;
      }

      this.setMultiAction(actionIndex);
    }

    this.play.next({
      itemId: this.item.id,
      actionIndex
    });
  }

  setSingleAction(actionIndex) {
    if (this.actionIndex !== actionIndex) {
      this.actionIndex = actionIndex;
      const action = this.actions[0];

      if (actionIndex === 0) {
        if (action.paused || action.timeScale === 0) {
          action.paused = false;
        } else {
          action.play();
        }
      } else if (actionIndex === -1) {
        action.halt(0.3);
      }
    }
  }

  setMultiAction(actionIndex) {
    if (this.actionIndex !== actionIndex) {
      const actions = this.actions;
      const previousClip = this.actionIndex > -1 ? actions[this.actionIndex] : null;
      this.actionIndex = actionIndex;

      if (previousClip) {
        previousClip.halt(0.3);
      } // console.log('setMultiAction', actionIndex, actions.length);


      if (actionIndex > -1) {
        const action = actions[actionIndex];

        if (action.paused) {
          action.paused = false;
        }

        if (action.timeScale === 0) {
          action.timeScale = 1;
        }

        action.play();
      }
    }
  }

  onMessage(message) {
    switch (message.type) {
      case MessageType.PlayModel:
        const actions = this.actions;

        if (actions.length === 1) {
          this.setSingleAction(message.actionIndex);
        } else if (actions.length > 1) {
          this.setMultiAction(message.actionIndex);
        }

        break;
    }
  }

  render(time, tick) {
    const view = this.view;
    this.item;
    const mesh = this.mesh;
    const isPresenting = this.host.renderer.xr.isPresenting;
    this.group;

    if (mesh) {
      if (view.type.name === ViewType.Model.name) {
        if (this.isPresenting !== isPresenting) {
          this.isPresenting = isPresenting;

          if (isPresenting) {
            mesh.position.x = 0;
            mesh.position.y = 0;
            mesh.position.z = -2;
            mesh.rotation.y = 0;
          } else {
            mesh.position.x = 0;
            mesh.position.y = 0;
            mesh.position.z = 0;
            mesh.rotation.y = 0;
          }
        }

        if (isPresenting) {
          mesh.rotation.y -= Math.PI / 180 / 60 * 5;
        }
      } else {
        if (isPresenting) {
          mesh.rotation.y -= Math.PI / 180 / 60 * 5;
        }
      }
    }

    const mixer = this.mixer;
    const clock = this.clock;

    if (mixer) {
      const delta = clock.getDelta();
      mixer.update(delta);
    }
  } // called by UpdateViewItemComponent


  onUpdate(item, mesh) {
    // console.log('ModelModelComponent.onUpdate', item);
    const view = this.view;

    if (view.type.name !== ViewType.Model.name) {
      if (item.position) {
        mesh.position.fromArray(item.position);
      }

      if (item.rotation) {
        mesh.rotation.fromArray(item.rotation);
      }

      if (item.scale) {
        mesh.scale.fromArray(item.scale);
      }
    }

    this.updateHelper();
  } // called by UpdateViewItemComponent


  onUpdateAsset(item, mesh) {
    // console.log('ModelModelComponent.onUpdateAsset', item);
    this.loadGlb(environment.getPath(item.asset.folder), item.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, (mesh, item) => this.onMount(mesh, item), (mesh, item) => this.onDismount(mesh, item));
    });
    /*
    this.mesh.updateByItem(item);
    this.mesh.load(() => {
    	// console.log('ModelModelComponent.mesh.load.complete');
    });
    */
  } // called by WorldComponent


  onDragMove(position, normal, spherical) {
    // console.log('ModelModelComponent.onDragMove', position, normal, spherical);
    if (spherical) {
      position.normalize().multiplyScalar(4);
    }

    this.editing = true;
    const view = this.view;

    if (view.type.name !== ViewType.Model.name) {
      this.mesh.position.set(position.x, position.y, position.z); // this.mesh.lookAt(Host.origin);
    }

    this.updateHelper();
  } // called by WorldComponent


  onDragEnd() {
    // console.log('ModelModelComponent.onDragEnd');
    const view = this.view;

    if (view.type.name !== ViewType.Model.name) {
      this.item.position = this.mesh.position.toArray();
      this.item.rotation = this.mesh.rotation.toArray();
      this.item.scale = this.mesh.scale.toArray();
    }

    this.editing = false;
  }

  static getInteractiveDescriptors() {
    let descriptors = ModelModelComponent.interactiveDescriptors;

    if (!descriptors) {
      const freezableDescriptors = Object.getOwnPropertyDescriptors(FreezableMesh.prototype);
      const emittableDescriptors = Object.getOwnPropertyDescriptors(EmittableMesh.prototype);
      const interactiveDescriptors = Object.getOwnPropertyDescriptors(InteractiveMesh.prototype);
      descriptors = Object.assign({}, freezableDescriptors, emittableDescriptors, interactiveDescriptors);
      ModelModelComponent.interactiveDescriptors = descriptors;
    }

    return descriptors;
  }

  makeInteractive(mesh) {
    const interactiveDescriptors = ModelModelComponent.getInteractiveDescriptors();
    mesh.traverse(child => {
      if (child.isMesh) {
        Object.keys(interactiveDescriptors).forEach(key => {
          if (key !== 'constructor') {
            Object.defineProperty(child, key, interactiveDescriptors[key]);
          }
        });
        child.freezed = false;
        child.events = {};
        child.depthTest = true;
        child.over_ = false;
        child.down_ = false;
        Interactive.items.push(child);
        child.on('down', () => {
          // console.log('ModelModelComponent.down', child);
          this.onClipToggle();
          this.down.next(this);
        });
      }
    });
  }

}
ModelModelComponent.meta = {
  selector: '[model-model]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play'],
  inputs: ['item', 'view']
};// import * as THREE from 'three';
class FreezableSprite extends THREE.Sprite {
  get freezed() {
    return this.freezed_;
  }

  set freezed(freezed) {
    // !!! cycle through freezable and not freezable
    this.freezed_ = freezed;
    this.children.filter(x => x.__lookupGetter__('freezed')).forEach(x => x.freezed = freezed);
  }

  constructor(material) {
    material = material || new THREE.SpriteMaterial({
      color: 0xff00ff // opacity: 1,
      // transparent: true,

    });
    super(material);
    this.freezed = false;
  }

  freeze() {
    this.freezed = true;
  }

  unfreeze() {
    this.freezed = false;
  }

}// import * as THREE from 'three';
class EmittableSprite extends FreezableSprite {
  constructor(material) {
    material = material || new THREE.SpriteMaterial({
      color: 0xff00ff // opacity: 1,
      // transparent: true,

    });
    super(material);
    this.events = {};
  }

  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }

  off(type, callback) {
    const event = this.events[type];

    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }

  emit(type, data) {
    const event = this.events[type];

    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }

    const broadcast = this.events.broadcast;

    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }

}class InteractiveSprite extends EmittableSprite {
  constructor(material) {
    super(material);
    this.depthTest = true;
    this.over_ = false;
    this.down_ = false;
    Interactive.items.push(this);
  }

  get isInteractiveSprite() {
    return true;
  }

  get over() {
    return this.over_;
  }

  set over(over) {
    if (this.over_ != over) {
      this.over_ = over;
      /*
      if (over) {
      	this.emit('hit', this);
      }
      */

      if (over) {
        this.emit('over', this);
      } else {
        this.emit('out', this);
      }
    }
  }

  get down() {
    return this.down_;
  }

  set down(down) {
    down = down && this.over;

    if (this.down_ != down) {
      this.down_ = down;

      if (down) {
        this.emit('down', this);
      } else {
        this.emit('up', this);
      }
    }
  }

}// import domtoimage from 'dom-to-image';

class ModelPanelComponent extends ModelComponent {
  constructor() {
    super(...arguments);
    this.isMobile_ = void 0;
  }

  get isMobile() {
    return this.isMobile_;
  }

  set isMobile(isMobile) {
    if (this.isMobile_ !== isMobile) {
      this.isMobile_ = isMobile;
      this.setScale();
    }
  }

  render(time, tick) {
    // console.log('render', this.host.worldRect.width);
    this.isMobile = this.host.worldRect.width < 768;
  }

  setScale(pow) {
    if (pow === void 0) {
      pow = 0;
    }

    const textureWidth = this.textureWidth;
    const textureHeight = this.textureHeight;
    const item = this.item;
    const panel = this.panel;

    if (panel) {
      const scale = 0.2 * (item.asset ? 1.5 : 1.0) * (this.isMobile ? 1.6 : 1);
      const aspect = textureWidth / textureHeight;
      const width = ModelPanelComponent.PANEL_RADIUS * scale;
      const height = ModelPanelComponent.PANEL_RADIUS * scale / aspect;
      const dy = width * 0.25;
      const position = item.mesh.position.normalize().multiplyScalar(ModelPanelComponent.PANEL_RADIUS);
      panel.position.set(position.x, position.y + (height + dy * 2) - dy * (1 - pow), position.z);
      panel.scale.set(0.02 * width, 0.02 * height, 1);
    }
  }

  onInit() {
    super.onInit();
    this.textureWidth = 0;
    this.textureHeight = 0; // console.log('ModelPanelComponent.onInit', this.item);
  }

  onView() {
    if (this.viewed) {
      return;
    }

    this.viewed = true;
    const {
      node
    } = rxcomp.getContext(this);
    this.getCanvasTexture(node).then(texture => {
      this.textureWidth = texture.width;
      this.textureHeight = texture.height;

      if (this.mesh && this.item) {
        const material = new THREE.SpriteMaterial({
          depthTest: false,
          transparent: true,
          opacity: 0,
          map: texture.map,
          sizeAttenuation: false,
          toneMapped: false
        });
        const item = this.item;
        const panel = this.panel = new InteractiveSprite(material);
        panel.renderOrder = environment.renderOrder.panel;
        this.setScale(1);
        panel.on('down', event => {
          // console.log(event.intersection.uv.x, event.intersection.uv.y, node.offsetWidth, node.offsetHeight);
          const xy = {
            x: parseInt(event.intersection.uv.x * node.offsetWidth),
            y: parseInt((1 - event.intersection.uv.y) * node.offsetHeight)
          }; // console.log('ModelPanelComponent.down.xy', xy);

          const linkNodes = Array.prototype.slice.call(node.querySelectorAll('.panel__link')); // console.log('linkNodes', linkNodes);

          const linkNode = linkNodes.find(link => {
            const inside = xy.x >= link.offsetLeft && xy.y >= link.offsetTop && xy.x <= link.offsetLeft + link.offsetWidth && xy.y <= link.offsetTop + link.offsetHeight;
            /*
            console.log(
            	(link.offsetLeft + link.offsetWidth), '>=', xy.x, '>=', link.offsetLeft,
            	(link.offsetTop + link.offsetHeight), '>=', xy.y, '>=', link.offsetTop,
            	inside,
            );
            */

            return inside;
          }); // console.log('linkNode', linkNode);

          if (linkNode) {
            const linkIndex = linkNodes.indexOf(linkNode);
            const link = item.links[linkIndex]; // console.log('ModelPanelComponent.down.link', link, linkNode, linkNodes);

            this.down.next({
              item,
              link,
              linkIndex
            });
            const rect = node.getBoundingClientRect();
            const mouseEvent = {
              button: 0,
              buttons: 0,
              clientX: xy.x + rect.left,
              clientY: xy.y + rect.top,
              movementX: 0,
              movementY: 0,
              relatedTarget: linkNode,
              screenX: xy.x,
              screenY: xy.y
            };
            const event = new MouseEvent('mouseup', mouseEvent);
            linkNode.dispatchEvent(event); // console.log('ModelPanelComponent.dispatchEvent', mouseEvent);

            setTimeout(() => {
              DragService.dismissEvent(event, DragService.events$, DragService.dismiss$, DragService.downEvent);
            }, 1);
          }
        });
        this.mesh.add(panel);
        const from = {
          value: 0
        };
        gsap.to(from, {
          duration: 0.5,
          value: 1,
          delay: 0.0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            this.setScale(1 - from.value);
            panel.lookAt(Host.origin);
            panel.material.opacity = from.value;
            panel.material.needsUpdate = true;
          }
        });
      }
    }, error => {
      console.log('ModelPanelComponent.getCanvasTexture.error', error);
    });
  }

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();

    if (typeof mount === 'function') {
      mount(mesh);
    }
  }

  onDestroy() {
    // console.log('ModelPanelComponent.onDestroy');
    super.onDestroy();
  }

  imagesLoaded() {
    const {
      node
    } = rxcomp.getContext(this);

    if (node) {
      const images = Array.prototype.slice.call(node.querySelectorAll('img'));
      const promises = images.map(x => new Promise(function (resolve, reject) {
        const cors = x.src && x.src.indexOf(location.origin) === -1;

        if (x.complete) {
          return setTimeout(() => {
            resolve(cors);
          }, 10);
        }

        const removeListeners = () => {
          x.removeEventListener('load', onLoad);
          x.removeEventListener('error', onError);
        };

        const onLoad = () => {
          // console.log('loaded!');
          removeListeners();
          setTimeout(() => {
            resolve(cors);
          }, 10);
        };

        const onError = () => {
          // console.log('error!');
          removeListeners();
          resolve(false);
        };

        const addListeners = () => {
          x.addEventListener('load', onLoad);
          x.addEventListener('error', onError);
        };

        addListeners();
      }));

      if (promises.length) {
        return Promise.all(promises);
      } else {
        return Promise.resolve();
      }
    }
  }

  getCanvasTexture(node) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (this.item.panelTexture) {
          resolve(this.item.panelTexture);
        } else {
          this.imagesLoaded().then(results => {
            const context = rxcomp.getContext(this);

            if (context && context.node) {
              node = context.node;
              const useCORS = results && results.find(x => x === true) != null; // !!! keep loose equality
              // console.log('ModelPanelComponent.getCanvasTexture.useCORS', useCORS);

              /*
              if (USE_DOM_TO_IMAGE) {
              	domtoimage.toBlob(node, { cacheBust: true }).then(function(blob) {
              		createImageBitmap(blob).then(function(imageBitmap) {
              			const map = new THREE.Texture();
              			map.image = imageBitmap;
              			map.needsUpdate = true;
              			this.item.panelTexture = {
              				map: map,
              				width: imageBitmap.width,
              				height: imageBitmap.height,
              			};
              			resolve(this.item.panelTexture);
              				}, error => {
              			reject(error);
              		});
              	}, error => {
              		reject(error);
              	});
              } else {
              */

              /*
              htmlToImage.toCanvas(node).then((canvas) => {
              	// !!!
              	// document.body.appendChild(canvas);
              	// const alpha = this.getAlphaFromCanvas(canvas);
              	// document.body.appendChild(alpha);
              	const map = new THREE.CanvasTexture(canvas);
              	// const alphaMap = new THREE.CanvasTexture(alpha);
              	// console.log(canvas.width, canvas.height);
              	this.item.panelTexture = {
              		map: map,
              		width: canvas.width,
              		height: canvas.height,
              	};
              	resolve(this.item.panelTexture);
              }).catch(error => {
              	console.log('htmlToImage', error);
              	reject(error);
              });
              */

              html2canvas__default["default"](node, {
                backgroundColor: '#ffffff00',
                scale: 1,
                useCORS // logging: true,

              }).then(canvas => {
                // !!!
                // document.body.appendChild(canvas);
                // const alpha = this.getAlphaFromCanvas(canvas);
                // document.body.appendChild(alpha);
                const map = new THREE.CanvasTexture(canvas); // const alphaMap = new THREE.CanvasTexture(alpha);
                // console.log(canvas.width, canvas.height);

                this.item.panelTexture = {
                  map: map,
                  width: canvas.width,
                  height: canvas.height
                };
                resolve(this.item.panelTexture);
              }, error => {
                reject(error);
              }); // }
            }
          });
        }
      }, 1); // keep it for childnode images to be compiled
    });
  }

}
ModelPanelComponent.PANEL_RADIUS = 99;
ModelPanelComponent.meta = {
  selector: '[model-panel]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['over', 'out', 'down'],
  inputs: ['item'],
  template:
  /* html */
  `
		<div class="panel__title"><span [innerHTML]="item.title"></span></div>
		<div class="panel__abstract"><span [innerHTML]="item.abstract"></span></div>
		<img class="panel__picture" [src]="item.asset | asset" *if="item.asset">
		<a class="panel__link" [href]="link.href" target="_blank" rel="noopener" *for="let link of item.links">
			<span [innerHTML]="link.title"></span>
		</a>
	`
};// import * as THREE from 'three';
class ModelPictureComponent extends ModelComponent {
  onInit() {
    super.onInit(); // console.log('ModelPictureComponent.onInit');
  }

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();

    if (typeof mount === 'function') {
      mount(mesh);
    }
  } // onView() { const context = getContext(this); }
  // onChanges() {}


}
ModelPictureComponent.meta = {
  selector: '[model-picture]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};class ModelPlaneComponent extends ModelEditableComponent {
  onInit() {
    super.onInit(); // console.log('ModelPlaneComponent.onInit');
  }

  onChanges() {
    const selected = this.item.selected;
    this.editing = selected;

    if (this.mesh) {
      this.mesh.editing = selected;
    }
  }

  onCreate(mount, dismount) {
    const item = this.item;
    const view = this.view;
    view.items;
    const geometry = Geometry.planeGeometry;
    this.onMeshDown = this.onMeshDown.bind(this);
    this.onMeshPlaying = this.onMeshPlaying.bind(this);
    this.onMeshZoomed = this.onMeshZoomed.bind(this);
    this.onMeshCurrentTime = this.onMeshCurrentTime.bind(this);
    let mesh;
    let subscription;
    MediaMesh.getStreamId$(item).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(streamId => {
      // console.log('ModelPlaneComponent.onCreate.streamId', streamId);
      if (this.streamId !== streamId) {
        this.streamId = streamId; // !!! called by ModelComponent

        /*
        if (mesh) {
        	dismount(mesh, item);
        }
        */

        if (subscription) {
          subscription.unsubscribe();
          subscription = null;
        }

        if (streamId || !item.asset) {
          item.streamId = streamId;
          mesh = this.disposableMesh = new MediaMesh(item, view, geometry, this.host);
          mesh.updateFromItem(item);
          mesh.name = 'plane';
          mesh.load(() => {
            this.disposableMesh = null;

            if (typeof mount === 'function') {
              mount(mesh, item);
            }

            subscription = mesh.events$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(() => {});
          });
          this.addMeshListeners(mesh);
        } else if (this.mesh) {
          dismount(this.mesh, item);
        } // console.log('streamId', streamId, mesh);

      }
    });
  }

  addMeshListeners(mesh) {
    mesh.on('down', this.onMeshDown);
    mesh.on('playing', this.onMeshPlaying);
    mesh.on('zoomed', this.onMeshZoomed);
    mesh.on('currentTime', this.onMeshCurrentTime);
  }

  removeMeshListeners(mesh) {
    mesh.off('down', this.onMeshDown);
    mesh.off('playing', this.onMeshPlaying);
    mesh.off('zoomed', this.onMeshZoomed);
    mesh.off('currentTime', this.onMeshCurrentTime);
  }

  onMeshDown() {
    // console.log('ModelPanelComponent.onMeshDown');
    this.down.next(this);
  }

  onMeshPlaying(playing) {
    // console.log('ModelPanelComponent.playing', playing);
    this.play.next({
      itemId: this.item.id,
      playing
    });
  }

  onMeshZoomed(zoomed) {
    // console.log('ModelPanelComponent.zoomed', zoomed);
    this.zoom.next({
      itemId: this.item.id,
      zoomed
    });
  }

  onMeshCurrentTime(currentTime) {
    // console.log('ModelPanelComponent.playing', playing);
    this.currentTime.next({
      itemId: this.item.id,
      currentTime
    });
  }

  onDestroy() {
    // console.log('ModelPlaneComponent.onDestroy');
    super.onDestroy();

    if (this.disposableMesh) {
      this.removeMeshListeners(this.disposableMesh);
      this.disposableMesh.dispose();
    }

    if (this.mesh) {
      this.removeMeshListeners(this.mesh);
      this.mesh.dispose();
    }
  } // called by UpdateViewItemComponent


  onUpdate(item, mesh) {
    // console.log('ModelPlaneComponent.onUpdate', item);
    mesh.updateFromItem(item);
    this.updateHelper();
  } // called by UpdateViewItemComponent


  onUpdateAsset(item, mesh) {
    // console.log('ModelPlaneComponent.onUpdateAsset', item);
    mesh.updateByItem(item);
    MediaMesh.getStreamId$(item).pipe(operators.filter(streamId => streamId !== null), operators.take(1)).subscribe(streamId => {
      item.streamId = streamId;
      mesh.load(() => {// console.log('ModelPlaneComponent.mesh.load.complete');
      });
    });
  } // called by WorldComponent


  onDragMove(position, normal, spherical) {
    // console.log('ModelPlaneComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    item.showPanel = false;
    this.editing = true;

    if (spherical) {
      position.normalize().multiplyScalar(20);
      mesh.position.set(position.x, position.y, position.z);
      mesh.lookAt(Host.origin);
    } else {
      mesh.position.set(0, 0, 0);
      mesh.lookAt(normal);
      mesh.position.set(position.x, position.y, position.z);
      mesh.position.add(normal.multiplyScalar(0.01));
    }

    this.updateHelper();
  } // called by WorldComponent


  onDragEnd() {
    // console.log('ModelPlaneComponent.onDragEnd');
    const item = this.item;
    const mesh = this.mesh;
    item.position = mesh.position.toArray();
    item.rotation = mesh.rotation.toArray();
    item.scale = mesh.scale.toArray();
    mesh.updateFromItem(item);
    this.editing = false;
  }

}
ModelPlaneComponent.textures = {};
ModelPlaneComponent.meta = {
  selector: '[model-plane]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play', 'zoom', 'currentTime'],
  inputs: ['item', 'view']
};// export const WAITING_BANNER = { title: LabelPipe.transform('waiting_host') };

const PANEL_RADIUS = PANORAMA_RADIUS - 0.01;
class ModelProgressComponent extends ModelComponent {
  get title() {
    return this.title_;
  }

  set title(title) {
    if (this.title_ !== title) {
      this.title_ = title;

      if (title === LabelPipe.transform('waiting_host') || title !== '' && this.visible_) {
        this.updateProgress();
        this.show();
      } else {
        this.hide();
      }
    }
  }

  get visible() {
    return this.visible_;
  }

  set visible(visible) {
    if (this.visible_ !== visible) {
      this.visible_ = visible;

      if (visible && this.title_ !== '') {
        this.updateProgress();
        this.show();
      } else {
        this.hide();
      }
    }
  }

  onInit() {
    this.title_ = '';
    this.visible_ = this.host.renderer.xr.isPresenting;
    super.onInit();
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => this.visible = session != null); // loose
    // this.progress = LoaderService.progress;

    /*
    const { node } = getContext(this);
    const inner = node.querySelector('.inner');
    LoaderService.progress$.pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe(progress => {
    	progress.count > 0 ? node.classList.add('active') : node.classList.remove('active');
    	inner.style.width = `${progress.count}%`;
    });
    */
  }

  onCreate(mount, dismount) {
    // console.log('ModelProgressComponent.onCreate');
    const {
      node
    } = rxcomp.getContext(this);
    const inner = node.querySelector('.inner');
    this.getCanvasTexture().then(result => {
      const mesh = this.createMesh(result);

      if (typeof mount === 'function') {
        mount(mesh);
      }

      LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
        progress.count > 0 ? node.classList.add('active') : node.classList.remove('active');
        inner.style.width = `${progress.value * 100}%`;

        if (progress.count) {
          this.title = progress.value === 0 ? LabelPipe.transform('loading') : progress.title;
        } else {
          this.title = this.getTitle();
        }
      });
    });
  }

  getTitle() {
    if (this.view && this.view.type.name === ViewType.WaitingRoom.name) {
      return LabelPipe.transform('waiting_host');
    } else {
      return '';
    }
  }

  show() {
    this.mesh.add(this.banner);
    this.material.opacity = 1;
    this.material.needsUpdate = true;
    /*
    const material = this.material;
    const from = { value: material.opacity };
    gsap.to(from, {
    	duration: 0.5,
    	value: 1,
    	delay: 0.0,
    	ease: Power2.easeInOut,
    	overwrite: 'all',
    	onUpdate: () => {
    		material.opacity = from.value;
    		material.needsUpdate = true;
    	}
    });
    */
  }

  hide() {
    this.mesh.remove(this.banner);
    this.material.opacity = 0;
    this.material.needsUpdate = true;
    /*
    const from = { value: material.opacity };
    gsap.to(from, {
    	duration: 0.5,
    	value: 0,
    	delay: 0.0,
    	ease: Power2.easeInOut,
    	overwrite: 'all',
    	onUpdate: () => {
    		material.opacity = from.value;
    		material.needsUpdate = true;
    	},
    	onComplete: () => {
    		this.mesh.remove(this.banner);
    	}
    });
    */
  }

  createMesh(result) {
    const mesh = new THREE.Group(); // const repeat = 24;
    // const aspect = (result.width * repeat) / result.height;

    const arc = Math.PI / 180 * 360;
    const width = PANEL_RADIUS * arc;
    const height = width / 360 * 2.4;
    const w = result.width * height / result.height;
    const repeat = width / w;
    const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS, PANEL_RADIUS, height, 80, 2, true, 0, arc);
    geometry.scale(-1, 1, 1);
    const texture = result.texture;
    texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
    texture.repeat.x = repeat;
    texture.encoding = THREE.sRGBEncoding;
    const material = this.material = new THREE.MeshBasicMaterial({
      map: texture,
      transparent: true,
      opacity: 0,
      toneMapped: false // side: THREE.DoubleSide,

    });
    this.banner = new THREE.Mesh(geometry, material);
    mesh.userData = {
      render: () => {
        mesh.rotation.y += Math.PI / 180 * 0.02; // texture.offset.x = (texture.offset.x - 0.01) % 1;
        // material.needsUpdate = true;
      }
    };
    return mesh;
  }

  updateProgress() {
    this.getCanvasTexture().then(result => {
      // console.log('ModelProgressComponent.updateProgress', result);
      const arc = Math.PI / 180 * 360;
      const width = PANEL_RADIUS * arc;
      const height = width / 360 * 2.4;
      const w = result.width * height / result.height;
      const repeat = width / w;
      this.texture.repeat.x = repeat;
    });
  }

  getCanvasTexture() {
    return new Promise((resolve, reject) => {
      const MIN_W = 512;
      let W = MIN_W;
      let H = 64;
      const F = Math.floor(H * 0.75);
      const L = Math.floor(H * 0.05);
      let canvas;

      if (this.canvas) {
        canvas = this.canvas;
      } else {
        canvas = this.canvas = document.createElement('canvas'); // canvas.classList.add('canvas--debug');
        // document.querySelector('body').appendChild(canvas);
      }

      canvas.width = W;
      canvas.height = H;
      const text = this.title_; // console.log('ModelProgressComponent.getCanvasTexture', text);

      const ctx = canvas.getContext('2d'); // const ctx = text.material.map.image.getContext('2d');

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `300 ${F}px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      W = metrics.width + 8;
      W = Math.max(MIN_W, Math.pow(2, Math.ceil(Math.log(W) / Math.log(2)))); // const x = W / 2;
      // const y = 16;

      canvas.width = W;
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#0000005A'; // 35% // '#000000C0'; // 75%

      ctx.fillRect(0, 0, W, H);
      ctx.font = `300 ${F}px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.35)';
      ctx.lineWidth = L;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!

      ctx.miterLimit = 2;
      ctx.strokeText(text, W / 2, H / 2);
      ctx.fillStyle = 'white';
      ctx.fillText(text, W / 2, H / 2, W); // text.material.map.needsUpdate = true;

      let texture;

      if (this.texture) {
        texture = this.texture;
        texture.needsUpdate = true;
      } else {
        texture = this.texture = new THREE.CanvasTexture(canvas);
      } // console.log(F, L, W, H);


      resolve({
        texture: texture,
        width: W,
        height: H
      });
    });
  }

}
ModelProgressComponent.meta = {
  selector: '[model-progress]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['view']
};class ModelRoomComponent extends ModelComponent {
  static get transparentMaterial() {
    if (!this.transparentMaterial_) {
      this.transparentMaterial_ = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0 // side: THREE.DoubleSide

      });
    }

    return this.transparentMaterial_;
  }

  get freezed() {
    return this.freezed_;
  }

  set freezed(freezed) {
    if (this.freezed_ !== freezed) {
      this.freezed_ = freezed;
      const mesh = this.mesh;

      if (mesh) {
        mesh.traverse(child => {
          if (child.isInteractiveMesh) {
            child.freezed = freezed;
          }
        });
      }
    }
  }

  onInit() {
    // console.log('ModelRoomComponent.onInit');
    super.onInit();
    this.isPresenting = false;
    MenuService.active$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(active => this.freezed = active);
  }

  onChanges() {
    this.editing = this.view.selected;
  }

  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.room;
    this.loadGlb(environment.getPath(this.view.asset.folder), this.view.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, mount, dismount);
    });
  } // onView() { const context = getContext(this); }
  // onChanges() {}


  loadGlb(path, file, callback) {
    this.host.renderer; // const roughnessMipmapper = new RoughnessMipmapper(renderer); // optional

    const progressRef = LoaderService.getRef(); // console.log('progressRef');

    const loader = new GLTFLoader().setPath(path); // Optional: Provide a DRACOLoader instance to decode compressed mesh data

    const decoderPath = `${environment.dist}js/draco/`; // console.log(decoderPath);

    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(decoderPath);
    loader.setDRACOLoader(dracoLoader);
    loader.load(file, glb => {
      /*
      glb.scene.traverse((child) => {
      	if (child.isMesh) {
      		// roughnessMipmapper.generateMipmaps(child.material);
      	}
      });
      */
      if (typeof callback === 'function') {
        callback(glb.scene, glb.animations);
      } // console.log('ModelRoomComponent.loadGlb');


      LoaderService.setProgress(progressRef, 1); // roughnessMipmapper.dispose();
    }, progressEvent => {
      LoaderService.setProgress(progressRef, progressEvent.loaded, progressEvent.total);
    });
  }

  onGlbLoaded(mesh, animations, mount, dismount) {
    const view = this.view; // scale

    mesh.position.set(0, -1.76, 0); // nav

    const intersectObjects = [];
    mesh.traverse(child => {
      if (child.isMesh) {
        intersectObjects.push(child);
      }

      if (child.name === 'nav') {
        // child.parent.remove(child);
        view.navIntersectObjects = [child];
        this.makeTransparent(child);
      }
    });
    view.intersectObjects = intersectObjects; // animations

    let dummy;
    dummy = new THREE.Group();
    dummy.add(mesh);

    if (typeof mount === 'function') {
      mount(dummy, this.view);
    }
  }

  makeTransparent(object) {
    if (object.isMesh) {
      object.material = ModelRoomComponent.transparentMaterial;
    }

    object.traverse(child => {
      if (child.isMesh) {
        child.material = ModelRoomComponent.transparentMaterial;
      }
    });
  } // called by UpdateViewItemComponent


  onUpdateAsset(view, mesh) {
    // console.log('ModelRoomComponent.onUpdateAsset', view);
    this.loadGlb(environment.getPath(view.asset.folder), view.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, (mesh, view) => this.onMount(mesh, view), (mesh, view) => this.onDismount(mesh, view));
    });
  }

}
ModelRoomComponent.meta = {
  selector: '[model-room]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['view']
};// import * as THREE from 'three';
class ModelTextComponent extends ModelComponent {
  onInit() {
    super.onInit(); // console.log('ModelTextComponent.onInit');
  }

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();

    if (typeof mount === 'function') {
      mount(mesh);
    }
  } // onView() { const context = getContext(this); }
  // onChanges() {}


}
ModelTextComponent.meta = {
  selector: '[model-text]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};AgoraService.fixLegacy();
class AppModule extends rxcomp.Module {}
AppModule.meta = {
  imports: [rxcomp.CoreModule, rxcompForm.FormModule, EditorModule],
  declarations: [AccessCodeComponent, AccessComponent, AgoraChatComponent, AgoraChatEmojiComponent, AgoraCheckComponent, AgoraChecklistComponent, AgoraComponent, AgoraConfigureFirewallModalComponent, AgoraDeviceComponent, AgoraDevicePreviewComponent, AgoraLinkComponent, AgoraLoginComponent, AgoraNameComponent, AgoraStreamComponent, AssetPipe, ControlAssetComponent, ControlAssetsComponent, ControlCheckboxComponent, ControlCustomSelectComponent, ControlLinkComponent, ControlLocalizedAssetComponent, ControlMenuComponent, ControlModelComponent, ControlNumberComponent, ControlPasswordComponent, ControlRequestModalComponent, ControlsComponent, ControlSelectComponent, ControlTextareaComponent, ControlTextComponent, ControlVectorComponent, DisabledDirective, DropDirective, DropdownDirective, DropdownItemDirective, EnvPipe, ErrorsComponent, FlagPipe, GenericComponent, GenericModalComponent, HlsDirective, HtmlPipe, IframeModalComponent, IdDirective, InputValueComponent, LabelPipe, LanguageComponent, LayoutComponent, LazyDirective, MediaPlayerComponent, MessagePipe, ModalComponent, ModalOutletComponent, ModelBannerComponent, ModelComponent, ModelCurvedPlaneComponent, ModelDebugComponent, ModelGridComponent, ModelMenuComponent, ModelModelComponent, ModelNavComponent, ModelPanelComponent, ModelPictureComponent, ModelPlaneComponent, ModelProgressComponent, ModelRoomComponent, ModelTextComponent, RoutePipe, SupportRequestModalComponent, SvgIconStructure, TestComponent, TitleDirective, TryInARComponent, TryInARModalComponent, UploadItemComponent, ValueDirective, VirtualStructure, WorldComponent, RouterOutletStructure, RouterLinkDirective],
  bootstrap: AppComponent
};rxcomp.Browser.bootstrap(AppModule);}));